{
  "internal/bootstrap_node": "// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by node::LoadEnvironment in src/node.cc, and is\n// responsible for bootstrapping the node.js core. As special caution is given\n// to the performance of the startup process, many dependencies are invoked\n// lazily.\n\n'use strict';\n\n(function(process) {\n\n  function startup() {\n    const EventEmitter = NativeModule.require('events');\n    process._eventsCount = 0;\n\n    const origProcProto = Object.getPrototypeOf(process);\n    Object.setPrototypeOf(process, Object.create(EventEmitter.prototype, {\n      constructor: Object.getOwnPropertyDescriptor(origProcProto, 'constructor')\n    }));\n\n    EventEmitter.call(process);\n\n    setupProcessObject();\n\n    // do this good and early, since it handles errors.\n    setupProcessFatal();\n\n    setupProcessICUVersions();\n\n    setupGlobalVariables();\n    if (!process._noBrowserGlobals) {\n      setupGlobalTimeouts();\n      setupGlobalConsole();\n    }\n\n    const _process = NativeModule.require('internal/process');\n\n    _process.setup_hrtime();\n    _process.setup_cpuUsage();\n    _process.setupMemoryUsage();\n    _process.setupConfig(NativeModule._source);\n    NativeModule.require('internal/process/warning').setup();\n    NativeModule.require('internal/process/next_tick').setup();\n    NativeModule.require('internal/process/stdio').setup();\n    _process.setupKillAndExit();\n    _process.setupSignalHandlers();\n    if (global.__coverage__)\n      NativeModule.require('internal/process/write-coverage').setup();\n\n    // Do not initialize channel in debugger agent, it deletes env variable\n    // and the main thread won't see it.\n    if (process.argv[1] !== '--debug-agent')\n      _process.setupChannel();\n\n    _process.setupRawDebug();\n\n    // Ensure setURLConstructor() is called before the native\n    // URL::ToObject() method is used.\n    NativeModule.require('internal/url');\n\n    Object.defineProperty(process, 'argv0', {\n      enumerable: true,\n      configurable: false,\n      value: process.argv[0]\n    });\n    process.argv[0] = process.execPath;\n\n    // Handle `--debug*` deprecation and invalidation\n    if (process._invalidDebug) {\n      process.emitWarning(\n        '`node --debug` and `node --debug-brk` are invalid. ' +\n        'Please use `node --inspect` or `node --inspect-brk` instead.',\n        'DeprecationWarning', 'DEP0062', startup, true);\n      process.exit(9);\n    } else if (process._deprecatedDebugBrk) {\n      process.emitWarning(\n        '`node --inspect --debug-brk` is deprecated. ' +\n        'Please use `node --inspect-brk` instead.',\n        'DeprecationWarning', 'DEP0062', startup, true);\n    }\n\n    // There are various modes that Node can run in. The most common two\n    // are running from a script and running the REPL - but there are a few\n    // others like the debugger or running --eval arguments. Here we decide\n    // which mode we run in.\n\n    if (NativeModule.exists('_third_party_main')) {\n      // To allow people to extend Node in different ways, this hook allows\n      // one to drop a file lib/_third_party_main.js into the build\n      // directory which will be executed instead of Node's normal loading.\n      process.nextTick(function() {\n        NativeModule.require('_third_party_main');\n      });\n\n    } else if (process.argv[1] === 'inspect' || process.argv[1] === 'debug') {\n      if (process.argv[1] === 'debug') {\n        process.emitWarning(\n          '`node debug` is deprecated. Please use `node inspect` instead.',\n          'DeprecationWarning', 'DEP0068');\n      }\n\n      // Start the debugger agent\n      process.nextTick(function() {\n        NativeModule.require('node-inspect/lib/_inspect').start();\n      });\n\n    } else if (process.argv[1] === '--remote_debugging_server') {\n      // Start the debugging server\n      NativeModule.require('internal/inspector/remote_debugging_server');\n\n    } else if (process.argv[1] === '--debug-agent') {\n      // Start the debugger agent\n      NativeModule.require('_debug_agent').start();\n\n    } else if (process.profProcess) {\n      NativeModule.require('internal/v8_prof_processor');\n\n    } else {\n      // There is user code to be run\n\n      // If this is a worker in cluster mode, start up the communication\n      // channel. This needs to be done before any user code gets executed\n      // (including preload modules).\n      if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n        const cluster = NativeModule.require('cluster');\n        cluster._setupWorker();\n\n        // Make sure it's not accidentally inherited by child processes.\n        delete process.env.NODE_UNIQUE_ID;\n      }\n\n      if (process._eval != null && !process._forceRepl) {\n        // User passed '-e' or '--eval' arguments to Node without '-i' or\n        // '--interactive'\n        preloadModules();\n\n        const internalModule = NativeModule.require('internal/module');\n        internalModule.addBuiltinLibsToObject(global);\n        evalScript('[eval]');\n      } else if (process.argv[1] && process.argv[1] !== '-') {\n        // make process.argv[1] into a full path\n        const path = NativeModule.require('path');\n        process.argv[1] = path.resolve(process.argv[1]);\n\n        const Module = NativeModule.require('module');\n\n        // check if user passed `-c` or `--check` arguments to Node.\n        if (process._syntax_check_only != null) {\n          const fs = NativeModule.require('fs');\n          // read the source\n          const filename = Module._resolveFilename(process.argv[1]);\n          var source = fs.readFileSync(filename, 'utf-8');\n          checkScriptSyntax(source, filename);\n          process.exit(0);\n        }\n\n        preloadModules();\n        Module.runMain();\n      } else {\n        preloadModules();\n        // If -i or --interactive were passed, or stdin is a TTY.\n        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n          // REPL\n          const cliRepl = NativeModule.require('internal/repl');\n          cliRepl.createInternalRepl(process.env, function(err, repl) {\n            if (err) {\n              throw err;\n            }\n            repl.on('exit', function() {\n              if (repl._flushing) {\n                repl.pause();\n                return repl.once('flushHistory', function() {\n                  process.exit();\n                });\n              }\n              process.exit();\n            });\n          });\n\n          if (process._eval != null) {\n            // User passed '-e' or '--eval'\n            evalScript('[eval]');\n          }\n        } else {\n          // Read all of stdin - execute it.\n          process.stdin.setEncoding('utf8');\n\n          var code = '';\n          process.stdin.on('data', function(d) {\n            code += d;\n          });\n\n          process.stdin.on('end', function() {\n            if (process._syntax_check_only != null) {\n              checkScriptSyntax(code, '[stdin]');\n            } else {\n              process._eval = code;\n              evalScript('[stdin]');\n            }\n          });\n        }\n      }\n    }\n  }\n\n  function setupProcessObject() {\n    process._setupProcessObject(pushValueToArray);\n\n    function pushValueToArray() {\n      for (var i = 0; i < arguments.length; i++)\n        this.push(arguments[i]);\n    }\n  }\n\n  function setupGlobalVariables() {\n    Object.defineProperty(global, Symbol.toStringTag, {\n      value: 'global',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    global.process = process;\n    const util = NativeModule.require('util');\n\n    function makeGetter(name) {\n      return util.deprecate(function() {\n        return this;\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    function makeSetter(name) {\n      return util.deprecate(function(value) {\n        Object.defineProperty(this, name, {\n          configurable: true,\n          writable: true,\n          enumerable: true,\n          value: value\n        });\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    Object.defineProperties(global, {\n      GLOBAL: {\n        configurable: true,\n        get: makeGetter('GLOBAL'),\n        set: makeSetter('GLOBAL')\n      },\n      root: {\n        configurable: true,\n        get: makeGetter('root'),\n        set: makeSetter('root')\n      }\n    });\n\n    global.Buffer = NativeModule.require('buffer').Buffer;\n    process.domain = null;\n    process._exiting = false;\n  }\n\n  function setupGlobalTimeouts() {\n    const timers = NativeModule.require('timers');\n    global.clearImmediate = timers.clearImmediate;\n    global.clearInterval = timers.clearInterval;\n    global.clearTimeout = timers.clearTimeout;\n    global.setImmediate = timers.setImmediate;\n    global.setInterval = timers.setInterval;\n    global.setTimeout = timers.setTimeout;\n  }\n\n  function setupGlobalConsole() {\n    const originalConsole = global.console;\n    let console;\n    Object.defineProperty(global, 'console', {\n      configurable: true,\n      enumerable: true,\n      get: function() {\n        if (!console) {\n          console = originalConsole === undefined ?\n              NativeModule.require('console') :\n              installInspectorConsole(originalConsole);\n        }\n        return console;\n      }\n    });\n  }\n\n  function installInspectorConsole(globalConsole) {\n    const wrappedConsole = NativeModule.require('console');\n    const inspector = process.binding('inspector');\n    const config = {};\n    for (const key of Object.keys(wrappedConsole)) {\n      if (!globalConsole.hasOwnProperty(key))\n        continue;\n      // If global console has the same method as inspector console,\n      // then wrap these two methods into one. Native wrapper will preserve\n      // the original stack.\n      wrappedConsole[key] = inspector.consoleCall.bind(wrappedConsole,\n                                                       globalConsole[key],\n                                                       wrappedConsole[key],\n                                                       config);\n    }\n    for (const key of Object.keys(globalConsole)) {\n      if (wrappedConsole.hasOwnProperty(key))\n        continue;\n      wrappedConsole[key] = globalConsole[key];\n    }\n    return wrappedConsole;\n  }\n\n  function setupProcessFatal() {\n    const async_wrap = process.binding('async_wrap');\n    // Arrays containing hook flags and ids for async_hook calls.\n    const { async_hook_fields, async_uid_fields } = async_wrap;\n    // Internal functions needed to manipulate the stack.\n    const { clearIdStack, popAsyncIds } = async_wrap;\n    const { kAfter, kCurrentAsyncId, kInitTriggerId } = async_wrap.constants;\n\n    process._fatalException = function(er) {\n      var caught;\n\n      // It's possible that kInitTriggerId was set for a constructor call that\n      // threw and was never cleared. So clear it now.\n      async_uid_fields[kInitTriggerId] = 0;\n\n      if (process.domain && process.domain._errorHandler)\n        caught = process.domain._errorHandler(er);\n\n      if (!caught)\n        caught = process.emit('uncaughtException', er);\n\n      // If someone handled it, then great.  otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event\n      if (!caught) {\n        try {\n          if (!process._exiting) {\n            process._exiting = true;\n            process.emit('exit', 1);\n          }\n        } catch (er) {\n          // nothing to be done about it at this point.\n        }\n\n      } else {\n        // If we handled an error, then make sure any ticks get processed\n        NativeModule.require('timers').setImmediate(process._tickCallback);\n\n        // Emit the after() hooks now that the exception has been handled.\n        if (async_hook_fields[kAfter] > 0) {\n          do {\n            NativeModule.require('async_hooks').emitAfter(\n                async_uid_fields[kCurrentAsyncId]);\n          // popAsyncIds() returns true if there are more ids on the stack.\n          } while (popAsyncIds(async_uid_fields[kCurrentAsyncId]));\n        // Or completely empty the id stack.\n        } else {\n          clearIdStack();\n        }\n      }\n\n      return caught;\n    };\n  }\n\n  function setupProcessICUVersions() {\n    const icu = process.binding('config').hasIntl ?\n      process.binding('icu') : undefined;\n    if (!icu) return;  // no Intl/ICU: nothing to add here.\n    // With no argument, getVersion() returns a comma separated list\n    // of possible types.\n    const versionTypes = icu.getVersion().split(',');\n\n    function makeGetter(name) {\n      return () => {\n        // With an argument, getVersion(type) returns\n        // the actual version string.\n        const version = icu.getVersion(name);\n        // Replace the current getter with a new property.\n        delete process.versions[name];\n        Object.defineProperty(process.versions, name, {\n          value: version,\n          writable: false,\n          enumerable: true\n        });\n        return version;\n      };\n    }\n\n    for (var n = 0; n < versionTypes.length; n++) {\n      var name = versionTypes[n];\n      Object.defineProperty(process.versions, name, {\n        configurable: true,\n        enumerable: true,\n        get: makeGetter(name)\n      });\n    }\n  }\n\n  function tryGetCwd(path) {\n    var threw = true;\n    var cwd;\n    try {\n      cwd = process.cwd();\n      threw = false;\n    } finally {\n      if (threw) {\n        // getcwd(3) can fail if the current working directory has been deleted.\n        // Fall back to the directory name of the (absolute) executable path.\n        // It's not really correct but what are the alternatives?\n        return path.dirname(process.execPath);\n      }\n    }\n    return cwd;\n  }\n\n  function evalScript(name) {\n    const Module = NativeModule.require('module');\n    const path = NativeModule.require('path');\n    const cwd = tryGetCwd(path);\n\n    const module = new Module(name);\n    module.filename = path.join(cwd, name);\n    module.paths = Module._nodeModulePaths(cwd);\n    const body = process._eval;\n    const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n                   'global.exports = exports;\\n' +\n                   'global.module = module;\\n' +\n                   'global.__dirname = __dirname;\\n' +\n                   'global.require = require;\\n' +\n                   'return require(\"vm\").runInThisContext(' +\n                   `${JSON.stringify(body)}, { filename: ` +\n                   `${JSON.stringify(name)}, displayErrors: true });\\n`;\n    const result = module._compile(script, `${name}-wrapper`);\n    if (process._print_eval) console.log(result);\n    // Handle any nextTicks added in the first tick of the program.\n    process._tickCallback();\n  }\n\n  // Load preload modules\n  function preloadModules() {\n    if (process._preload_modules) {\n      NativeModule.require('module')._preloadModules(process._preload_modules);\n    }\n  }\n\n  function checkScriptSyntax(source, filename) {\n    const Module = NativeModule.require('module');\n    const vm = NativeModule.require('vm');\n    const internalModule = NativeModule.require('internal/module');\n\n    // remove Shebang\n    source = internalModule.stripShebang(source);\n    // remove BOM\n    source = internalModule.stripBOM(source);\n    // wrap it\n    source = Module.wrap(source);\n    // compile the script, this will throw if it fails\n    new vm.Script(source, {displayErrors: true, filename});\n  }\n\n  // Below you find a minimal module system, which is used to load the node\n  // core modules found in lib/*.js. All core modules are compiled into the\n  // node binary, so they can be loaded faster.\n\n  const ContextifyScript = process.binding('contextify').ContextifyScript;\n  function runInThisContext(code, options) {\n    const script = new ContextifyScript(code, options);\n    return script.runInThisContext();\n  }\n\n  function NativeModule(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n    this.loading = false;\n  }\n\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {};\n\n  NativeModule.require = function(id) {\n    if (id === 'native_module') {\n      return NativeModule;\n    }\n\n    const cached = NativeModule.getCached(id);\n    if (cached && (cached.loaded || cached.loading)) {\n      return cached.exports;\n    }\n\n    if (!NativeModule.exists(id)) {\n      // Model the error off the internal/errors.js model, but\n      // do not use that module given that it could actually be\n      // the one causing the error if there's a bug in Node.js\n      const err = new Error(`No such built-in module: ${id}`);\n      err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';\n      err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';\n      throw err;\n    }\n\n    process.moduleLoadList.push(`NativeModule ${id}`);\n\n    const nativeModule = new NativeModule(id);\n\n    nativeModule.cache();\n    nativeModule.compile();\n\n    return nativeModule.exports;\n  };\n\n  NativeModule.getCached = function(id) {\n    return NativeModule._cache[id];\n  };\n\n  NativeModule.exists = function(id) {\n    return NativeModule._source.hasOwnProperty(id);\n  };\n\n  const config = process.binding('config');\n\n  if (config.exposeInternals) {\n    NativeModule.nonInternalExists = NativeModule.exists;\n\n    NativeModule.isInternal = function(id) {\n      return false;\n    };\n  } else {\n    NativeModule.nonInternalExists = function(id) {\n      return NativeModule.exists(id) && !NativeModule.isInternal(id);\n    };\n\n    NativeModule.isInternal = function(id) {\n      return id.startsWith('internal/');\n    };\n  }\n\n\n  NativeModule.getSource = function(id) {\n    return NativeModule._source[id];\n  };\n\n  NativeModule.wrap = function(script) {\n    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n  };\n\n  NativeModule.wrapper = [\n    '(function (exports, require, module, __filename, __dirname) { ',\n    '\\n});'\n  ];\n\n  NativeModule.prototype.compile = function() {\n    var source = NativeModule.getSource(this.id);\n    source = NativeModule.wrap(source);\n\n    this.loading = true;\n\n    try {\n      const fn = runInThisContext(source, {\n        filename: this.filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      fn(this.exports, NativeModule.require, this, this.filename);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n  };\n\n  NativeModule.prototype.cache = function() {\n    NativeModule._cache[this.id] = this;\n  };\n\n  startup();\n});\n",
  "async_hooks": "'use strict';\n\nconst async_wrap = process.binding('async_wrap');\n/* Both these arrays are used to communicate between JS and C++ with as little\n * overhead as possible.\n *\n * async_hook_fields is a Uint32Array() that communicates the number of each\n * type of active hooks of each type and wraps the uin32_t array of\n * node::Environment::AsyncHooks::fields_.\n *\n * async_uid_fields is a Float64Array() that contains the async/trigger ids for\n * several operations. These fields are as follows:\n *   kCurrentAsyncId: The async id of the current execution stack.\n *   kCurrentTriggerId: The trigger id of the current execution stack.\n *   kAsyncUidCntr: Counter that tracks the unique ids given to new resources.\n *   kInitTriggerId: Written to just before creating a new resource, so the\n *    constructor knows what other resource is responsible for its init().\n *    Used this way so the trigger id doesn't need to be passed to every\n *    resource's constructor.\n */\nconst { async_hook_fields, async_uid_fields } = async_wrap;\n// Used to change the state of the async id stack.\nconst { pushAsyncIds, popAsyncIds } = async_wrap;\n// Array of all AsyncHooks that will be iterated whenever an async event fires.\n// Using var instead of (preferably const) in order to assign\n// tmp_active_hooks_array if a hook is enabled/disabled during hook execution.\nvar active_hooks_array = [];\n// Track whether a hook callback is currently being processed. Used to make\n// sure active_hooks_array isn't altered in mid execution if another hook is\n// added or removed.\nvar processing_hook = false;\n// Use to temporarily store and updated active_hooks_array if the user enables\n// or disables a hook while hooks are being processed.\nvar tmp_active_hooks_array = null;\n// Keep track of the field counts held in tmp_active_hooks_array.\nvar tmp_async_hook_fields = null;\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step, that step can bail out early.\nconst { kInit, kBefore, kAfter, kDestroy, kCurrentAsyncId, kCurrentTriggerId,\n    kAsyncUidCntr, kInitTriggerId } = async_wrap.constants;\n\nconst { async_id_symbol, trigger_id_symbol } = async_wrap;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\n\nlet setupHooksCalled = false;\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = { message: e };\n    Error.captureStackTrace(o, fatalError);\n    process._rawDebug(o.stack);\n  }\n  if (process.execArgv.some(\n      (e) => /^--abort[_-]on[_-]uncaught[_-]exception$/.test(e))) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\n\n// Public API //\n\nclass AsyncHook {\n  constructor({ init, before, after, destroy }) {\n    if (init !== undefined && typeof init !== 'function')\n      throw new TypeError('init must be a function');\n    if (before !== undefined && typeof before !== 'function')\n      throw new TypeError('before must be a function');\n    if (after !== undefined && typeof after !== 'function')\n      throw new TypeError('after must be a function');\n    if (destroy !== undefined && typeof destroy !== 'function')\n      throw new TypeError('destroy must be a function');\n\n    this[init_symbol] = init;\n    this[before_symbol] = before;\n    this[after_symbol] = after;\n    this[destroy_symbol] = destroy;\n  }\n\n  enable() {\n    // The set of callbacks for a hook should be the same regardless of whether\n    // enable()/disable() are run during their execution. The following\n    // references are reassigned to the tmp arrays if a hook is currently being\n    // processed.\n    const [hooks_array, hook_fields] = getHookArrays();\n\n    // Each hook is only allowed to be added once.\n    if (hooks_array.includes(this))\n      return;\n\n    if (!setupHooksCalled) {\n      setupHooksCalled = true;\n      // Setup the callbacks that node::AsyncWrap will call when there are\n      // hooks to process. They use the same functions as the JS embedder API.\n      async_wrap.setupHooks({ init,\n                              before: emitBeforeN,\n                              after: emitAfterN,\n                              destroy: emitDestroyN });\n    }\n\n    // createHook() has already enforced that the callbacks are all functions,\n    // so here simply increment the count of whether each callbacks exists or\n    // not.\n    hook_fields[kInit] += +!!this[init_symbol];\n    hook_fields[kBefore] += +!!this[before_symbol];\n    hook_fields[kAfter] += +!!this[after_symbol];\n    hook_fields[kDestroy] += +!!this[destroy_symbol];\n    hooks_array.push(this);\n    return this;\n  }\n\n  disable() {\n    const [hooks_array, hook_fields] = getHookArrays();\n\n    const index = hooks_array.indexOf(this);\n    if (index === -1)\n      return;\n\n    hook_fields[kInit] -= +!!this[init_symbol];\n    hook_fields[kBefore] -= +!!this[before_symbol];\n    hook_fields[kAfter] -= +!!this[after_symbol];\n    hook_fields[kDestroy] -= +!!this[destroy_symbol];\n    hooks_array.splice(index, 1);\n    return this;\n  }\n}\n\n\nfunction getHookArrays() {\n  if (!processing_hook)\n    return [active_hooks_array, async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (tmp_active_hooks_array === null)\n    storeActiveHooks();\n  return [tmp_active_hooks_array, tmp_async_hook_fields];\n}\n\n\nfunction storeActiveHooks() {\n  tmp_active_hooks_array = active_hooks_array.slice();\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  tmp_async_hook_fields = [];\n  tmp_async_hook_fields[kInit] = async_hook_fields[kInit];\n  tmp_async_hook_fields[kBefore] = async_hook_fields[kBefore];\n  tmp_async_hook_fields[kAfter] = async_hook_fields[kAfter];\n  tmp_async_hook_fields[kDestroy] = async_hook_fields[kDestroy];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreTmpHooks() {\n  active_hooks_array = tmp_active_hooks_array;\n  async_hook_fields[kInit] = tmp_async_hook_fields[kInit];\n  async_hook_fields[kBefore] = tmp_async_hook_fields[kBefore];\n  async_hook_fields[kAfter] = tmp_async_hook_fields[kAfter];\n  async_hook_fields[kDestroy] = tmp_async_hook_fields[kDestroy];\n\n  tmp_active_hooks_array = null;\n  tmp_async_hook_fields = null;\n}\n\n\nfunction createHook(fns) {\n  return new AsyncHook(fns);\n}\n\n\nfunction currentId() {\n  return async_uid_fields[kCurrentAsyncId];\n}\n\n\nfunction triggerId() {\n  return async_uid_fields[kCurrentTriggerId];\n}\n\n\n// Embedder API //\n\nclass AsyncResource {\n  constructor(type, triggerId) {\n    this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    // Read and reset the current kInitTriggerId so that when the constructor\n    // finishes the kInitTriggerId field is always 0.\n    if (triggerId === undefined) {\n      triggerId = initTriggerId();\n    // If a triggerId was passed, any kInitTriggerId still must be null'd.\n    } else {\n      async_uid_fields[kInitTriggerId] = 0;\n    }\n    this[trigger_id_symbol] = triggerId;\n\n    // Return immediately if there's nothing to do.\n    if (async_hook_fields[kInit] === 0)\n      return;\n\n    if (typeof type !== 'string' || type.length <= 0)\n      throw new TypeError('type must be a string with length > 0');\n    if (!Number.isSafeInteger(triggerId) || triggerId < 0)\n      throw new RangeError('triggerId must be an unsigned integer');\n\n    processing_hook = true;\n    for (var i = 0; i < active_hooks_array.length; i++) {\n      if (typeof active_hooks_array[i][init_symbol] === 'function') {\n        runInitCallback(active_hooks_array[i][init_symbol],\n                        this[async_id_symbol],\n                        type,\n                        triggerId,\n                        this);\n      }\n    }\n    processing_hook = false;\n  }\n\n  emitBefore() {\n    emitBeforeS(this[async_id_symbol], this[trigger_id_symbol]);\n    return this;\n  }\n\n  emitAfter() {\n    emitAfterS(this[async_id_symbol]);\n    return this;\n  }\n\n  emitDestroy() {\n    emitDestroyS(this[async_id_symbol]);\n    return this;\n  }\n\n  asyncId() {\n    return this[async_id_symbol];\n  }\n\n  triggerId() {\n    return this[trigger_id_symbol];\n  }\n}\n\n\nfunction runInAsyncIdScope(asyncId, cb) {\n  // Store the async id now to make sure the stack is still good when the ids\n  // are popped off the stack.\n  const prevId = currentId();\n  pushAsyncIds(asyncId, prevId);\n  try {\n    cb();\n  } finally {\n    popAsyncIds(asyncId);\n  }\n}\n\n\n// Sensitive Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newUid() {\n  return ++async_uid_fields[kAsyncUidCntr];\n}\n\n\n// Return the triggerId meant for the constructor calling it. It's up to the\n// user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction initTriggerId() {\n  var tId = async_uid_fields[kInitTriggerId];\n  // Reset value after it's been called so the next constructor doesn't\n  // inherit it by accident.\n  async_uid_fields[kInitTriggerId] = 0;\n  if (tId <= 0)\n    tId = async_uid_fields[kCurrentAsyncId];\n  return tId;\n}\n\n\nfunction setInitTriggerId(triggerId) {\n  // CHECK(Number.isSafeInteger(triggerId))\n  // CHECK(triggerId > 0)\n  async_uid_fields[kInitTriggerId] = triggerId;\n}\n\n\nfunction emitInitS(asyncId, type, triggerId, resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  // Even though it bypasses all the argument checks. The performance savings\n  // here is critical.\n  if (async_hook_fields[kInit] === 0)\n    return;\n\n  // This can run after the early return check b/c running this function\n  // manually means that the embedder must have used initTriggerId().\n  if (!Number.isSafeInteger(triggerId)) {\n    if (triggerId !== undefined)\n      resource = triggerId;\n    triggerId = initTriggerId();\n  }\n\n  // I'd prefer allowing these checks to not exist, or only throw in a debug\n  // build, in order to improve performance.\n  if (!Number.isSafeInteger(asyncId) || asyncId < 0)\n    throw new RangeError('asyncId must be an unsigned integer');\n  if (typeof type !== 'string' || type.length <= 0)\n    throw new TypeError('type must be a string with length > 0');\n  if (!Number.isSafeInteger(triggerId) || triggerId < 0)\n    throw new RangeError('triggerId must be an unsigned integer');\n\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][init_symbol] === 'function') {\n      runInitCallback(\n        active_hooks_array[i][init_symbol], asyncId, type, triggerId, resource);\n    }\n  }\n  processing_hook = false;\n\n  // Isn't null if hooks were added/removed while the hooks were running.\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\nfunction emitBeforeN(asyncId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][before_symbol] === 'function') {\n      runCallback(active_hooks_array[i][before_symbol], asyncId);\n    }\n  }\n  processing_hook = false;\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// Usage: emitBeforeS(asyncId[, triggerId]). If triggerId is omitted then\n// asyncId will be used instead.\nfunction emitBeforeS(asyncId, triggerId = asyncId) {\n  // CHECK(Number.isSafeInteger(asyncId) && asyncId > 0)\n  // CHECK(Number.isSafeInteger(triggerId) && triggerId > 0)\n\n  // Validate the ids.\n  if (asyncId < 0 || triggerId < 0) {\n    fatalError('before(): asyncId or triggerId is less than zero ' +\n               `(asyncId: ${asyncId}, triggerId: ${triggerId})`);\n  }\n\n  pushAsyncIds(asyncId, triggerId);\n\n  if (async_hook_fields[kBefore] === 0) {\n    return;\n  }\n\n  emitBeforeN(asyncId);\n}\n\n\n// Called from native. The asyncId stack handling is taken care of there before\n// this is called.\nfunction emitAfterN(asyncId) {\n  if (async_hook_fields[kAfter] > 0) {\n    processing_hook = true;\n    for (var i = 0; i < active_hooks_array.length; i++) {\n      if (typeof active_hooks_array[i][after_symbol] === 'function') {\n        runCallback(active_hooks_array[i][after_symbol], asyncId);\n      }\n    }\n    processing_hook = false;\n  }\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// TODO(trevnorris): Calling emitBefore/emitAfter from native can't adjust the\n// kIdStackIndex. But what happens if the user doesn't have both before and\n// after callbacks.\nfunction emitAfterS(asyncId) {\n  emitAfterN(asyncId);\n  popAsyncIds(asyncId);\n}\n\n\nfunction emitDestroyS(asyncId) {\n  // Return early if there are no destroy callbacks, or on attempt to emit\n  // destroy on the void.\n  if (async_hook_fields[kDestroy] === 0 || asyncId === 0)\n    return;\n  async_wrap.addIdToDestroyList(asyncId);\n}\n\n\nfunction emitDestroyN(asyncId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][destroy_symbol] === 'function') {\n      runCallback(active_hooks_array[i][destroy_symbol], asyncId);\n    }\n  }\n  processing_hook = false;\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// Emit callbacks for native calls. Since some state can be setup directly from\n// C++ there's no need to perform all the work here.\n\n// This should only be called if hooks_array has kInit > 0. There are no global\n// values to setup. Though hooks_array will be cloned if C++ needed to call\n// init().\n// TODO(trevnorris): Perhaps have MakeCallback call a single JS function that\n// does the before/callback/after calls to remove two additional calls to JS.\nfunction init(asyncId, type, resource, triggerId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][init_symbol] === 'function') {\n      runInitCallback(\n        active_hooks_array[i][init_symbol], asyncId, type, triggerId, resource);\n    }\n  }\n  processing_hook = false;\n}\n\n\n// Generalized callers for all callbacks that handles error handling.\n\n// If either runInitCallback() or runCallback() throw then force the\n// application to shutdown if one of the callbacks throws. This may change in\n// the future depending on whether it can be determined if there's a slim\n// chance of the application remaining stable after handling one of these\n// exceptions.\n\nfunction runInitCallback(cb, asyncId, type, triggerId, resource) {\n  try {\n    cb(asyncId, type, triggerId, resource);\n  } catch (e) {\n    fatalError(e);\n  }\n}\n\n\nfunction runCallback(cb, asyncId) {\n  try {\n    cb(asyncId);\n  } catch (e) {\n    fatalError(e);\n  }\n}\n\n\n// Placing all exports down here because the exported classes won't export\n// otherwise.\nmodule.exports = {\n  // Public API\n  createHook,\n  currentId,\n  triggerId,\n  // Embedder API\n  AsyncResource,\n  runInAsyncIdScope,\n  // Sensitive Embedder API\n  newUid,\n  initTriggerId,\n  setInitTriggerId,\n  emitInit: emitInitS,\n  emitBefore: emitBeforeS,\n  emitAfter: emitAfterS,\n  emitDestroy: emitDestroyS,\n};\n",
  "assert": "// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// UTILITY\nconst compare = process.binding('buffer').compare;\nconst util = require('util');\nconst { isSet, isMap } = process.binding('util');\nconst objectToString = require('internal/util').objectToString;\nconst Buffer = require('buffer').Buffer;\n\nvar errors;\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\n// The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nconst assert = module.exports = ok;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  if (arguments.length === 1)\n    message = actual;\n  if (arguments.length === 2)\n    operator = '!=';\n  const errors = lazyErrors();\n  throw new errors.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// The AssertionError is defined in internal/error.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected });\nassert.AssertionError = lazyErrors().AssertionError;\n\n\n// Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n/* eslint-disable no-restricted-properties */\nassert.equal = function equal(actual, expected, message) {\n  // eslint-disable-next-line eqeqeq\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// The non-equality assertion tests for whether two objects are not\n// equal with !=.\n// assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  // eslint-disable-next-line eqeqeq\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n/* eslint-enable */\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction areSimilarRegExps(a, b) {\n  return a.source === b.source && a.flags === b.flags;\n}\n\nfunction areSimilarTypedArrays(a, b) {\n  return compare(Buffer.from(a.buffer,\n                             a.byteOffset,\n                             a.byteLength),\n                 Buffer.from(b.buffer,\n                             b.byteOffset,\n                             b.byteLength)) === 0;\n}\n\nfunction isNullOrNonObj(object) {\n  return object === null || typeof object !== 'object';\n}\n\nfunction isFloatTypedArrayTag(tag) {\n  return tag === '[object Float32Array]' || tag === '[object Float64Array]';\n}\n\nfunction isArguments(tag) {\n  return tag === '[object Arguments]';\n}\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  // For primitives / functions\n  // (determined by typeof value !== 'object'),\n  // or null, equivalence is determined by === or ==.\n  if (isNullOrNonObj(actual) && isNullOrNonObj(expected)) {\n    // eslint-disable-next-line eqeqeq\n    return strict ? actual === expected : actual == expected;\n  }\n\n  // If they bypass the previous check, then at least\n  // one of them must be an non-null object.\n  // If the other one is null or undefined, they must not be equal.\n  if (actual === null || actual === undefined ||\n      expected === null || expected === undefined)\n    return false;\n\n  // Notes: Type tags are historical [[Class]] properties that can be set by\n  // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n  // and retrieved using Object.prototype.toString.call(obj) in JS\n  // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n  // for a list of tags pre-defined in the spec.\n  // There are some unspecified tags in the wild too (e.g. typed array tags).\n  // Since tags can be altered, they only serve fast failures\n  const actualTag = objectToString(actual);\n  const expectedTag = objectToString(expected);\n\n  // Passing null or undefined to Object.getPrototypeOf() will throw\n  // so this must done after previous checks.\n  // For strict comparison, objects should have\n  // a) The same prototypes.\n  // b) The same built-in type tags\n  if (strict) {\n    if (Object.getPrototypeOf(actual) !== Object.getPrototypeOf(expected)) {\n      return false;\n    }\n\n    if (actualTag !== expectedTag) {\n      return false;\n    }\n  }\n\n  // Do fast checks for builtin types.\n  // If they don't match, they must not be equal.\n  // If they match, return true for non-strict comparison.\n  // For strict comparison we need to exam further.\n\n  // If both values are Date objects,\n  // check if the time underneath are equal first.\n  if (util.isDate(actual) && util.isDate(expected)) {\n    if (actual.getTime() !== expected.getTime()) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n  }\n\n  // If both values are RegExp, check if they have\n  // the same source and flags first\n  if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    if (!areSimilarRegExps(actual, expected)) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n  }\n\n  // Ensure reflexivity of deepEqual with `arguments` objects.\n  // See https://github.com/nodejs/node-v0.x-archive/pull/7178\n  if (isArguments(actualTag) !== isArguments(expectedTag)) {\n    return false;\n  }\n\n  // Check typed arrays and buffers by comparing the content in their\n  // underlying ArrayBuffer. This optimization requires that it's\n  // reasonable to interpret their underlying memory in the same way,\n  // which is checked by comparing their type tags.\n  // (e.g. a Uint8Array and a Uint16Array with the same memory content\n  // could still be different because they will be interpreted differently)\n  // Never perform binary comparisons for Float*Arrays, though,\n  // since e.g. +0 === -0 is true despite the two values' bit patterns\n  // not being identical.\n  if (ArrayBuffer.isView(actual) && ArrayBuffer.isView(expected) &&\n      actualTag === expectedTag && !isFloatTypedArrayTag(actualTag)) {\n    if (!areSimilarTypedArrays(actual, expected)) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n\n    // Buffer.compare returns true, so actual.length === expected.length\n    // if they both only contain numeric keys, we don't need to exam further\n    if (Object.keys(actual).length === actual.length &&\n        Object.keys(expected).length === expected.length) {\n      return true;\n    }\n  }\n\n  // For all other Object pairs, including Array objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n\n  // Use memos to handle cycles.\n  if (!memos) {\n    memos = {\n      actual: { map: new Map(), position: 0 },\n      expected: { map: new Map(), position: 0 }\n    };\n  }\n\n  const actualPosition = memos.actual.map.get(actual);\n  if (actualPosition !== undefined) {\n    if (actualPosition === memos.expected.map.get(expected)) {\n      return true;\n    }\n  } else {\n    memos.actual.map.set(actual, memos.actual.position++);\n  }\n  if (!memos.expected.map.has(expected)) {\n    memos.expected.map.set(expected, memos.expected.position++);\n  }\n\n  return objEquiv(actual, expected, strict, memos);\n}\n\nfunction setHasSimilarElement(set, val1, strict, memo) {\n  if (set.has(val1))\n    return true;\n\n  // In strict mode the only things which can match a primitive or a function\n  // will already be detected by set.has(val1).\n  if (strict && (util.isPrimitive(val1) || util.isFunction(val1)))\n    return false;\n\n  // Otherwise go looking.\n  for (const val2 of set) {\n    if (_deepEqual(val1, val2, strict, memo))\n      return true;\n  }\n\n  return false;\n}\n\nfunction setEquiv(a, b, strict, memo) {\n  // This code currently returns false for this pair of sets:\n  //   assert.deepEqual(new Set(['1', 1]), new Set([1]))\n  //\n  // In theory, all the items in the first set have a corresponding == value in\n  // the second set, but the sets have different sizes. Its a silly case,\n  // and more evidence that deepStrictEqual should always be preferred over\n  // deepEqual.\n  if (a.size !== b.size)\n    return false;\n\n  for (const val1 of a) {\n    // If the value doesn't exist in the second set by reference, and its an\n    // object or an array we'll need to go hunting for something thats\n    // deep-equal to it. Note that this is O(n^2) complexity, and will get\n    // slower if large, very similar sets / maps are nested inside.\n    // Unfortunately there's no real way around this.\n    if (!setHasSimilarElement(b, val1, strict, memo)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction mapHasSimilarEntry(map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[1, 'a'], ['1', 'b']]) vs Map([['1', 'a'], [1, 'b']])\n  // or:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n\n  // This check is not strictly necessary. The loop performs this check, but\n  // doing it here improves performance of the common case when reference-equal\n  // keys exist (which includes all primitive-valued keys).\n  if (map.has(key1) && _deepEqual(item1, map.get(key1), strict, memo))\n    return true;\n\n  if (strict && (util.isPrimitive(key1) || util.isFunction(key1)))\n    return false;\n\n  for (const [key2, item2] of map) {\n    // This case is checked above.\n    if (key2 === key1)\n      continue;\n\n    if (_deepEqual(key1, key2, strict, memo) &&\n        _deepEqual(item1, item2, strict, memo)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a, b, strict, memo) {\n  // Caveat: In non-strict mode, this implementation does not handle cases\n  // where maps contain two equivalent-but-not-reference-equal keys.\n  //\n  // For example, maps like this are currently considered not equivalent:\n  if (a.size !== b.size)\n    return false;\n\n  for (const [key1, item1] of a) {\n    // Just like setEquiv above, this hunt makes this function O(n^2) when\n    // using objects and lists as keys\n    if (!mapHasSimilarEntry(b, key1, item1, strict, memo))\n      return false;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  // If one of them is a primitive, the other must be the same.\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  var key, i;\n\n  // The pair must have the same number of owned properties\n  // (keys incorporates hasOwnProperty).\n  if (aKeys.length !== bKeys.length)\n    return false;\n\n  // The pair must have the same set of keys (although not\n  // necessarily in the same order).\n  aKeys.sort();\n  bKeys.sort();\n  // Cheap key test:\n  for (i = aKeys.length - 1; i >= 0; i--) {\n    if (aKeys[i] !== bKeys[i])\n      return false;\n  }\n\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  if (isSet(a)) {\n    if (!isSet(b) || !setEquiv(a, b, strict, actualVisitedObjects))\n      return false;\n  } else if (isSet(b)) {\n    return false;\n  }\n\n  if (isMap(a)) {\n    if (!isMap(b) || !mapEquiv(a, b, strict, actualVisitedObjects))\n      return false;\n  } else if (isMap(b)) {\n    return false;\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = aKeys.length - 1; i >= 0; i--) {\n    key = aKeys[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n// The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// The strict non-equality assertion tests for strict inequality, as\n// determined by !==.\n// assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  // actual is guaranteed to be an Error object, but we need to check expected.\n  if (!expected) {\n    return false;\n  }\n\n  if (objectToString(expected) === '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore. The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    const errors = lazyErrors();\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'block', 'function',\n                               typeof block);\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ')' : '') +\n            (message ? ': ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  const userProvidedMessage = typeof message === 'string';\n  const isUnwantedException = !shouldThrow && util.isError(actual);\n  const isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// Expected to throw an error.\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function throws(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = doesNotThrow;\nfunction doesNotThrow(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n}\n\nassert.ifError = function ifError(err) { if (err) throw err; };\n",
  "buffer": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst binding = process.binding('buffer');\nconst config = process.binding('config');\nconst { compare: compare_, compareOffset } = binding;\nconst { isAnyArrayBuffer, isUint8Array } = process.binding('util');\nconst bindingObj = {};\nconst internalUtil = require('internal/util');\nconst pendingDeprecation = !!config.pendingDeprecation;\n\nclass FastBuffer extends Uint8Array {\n  constructor(arg1, arg2, arg3) {\n    super(arg1, arg2, arg3);\n  }\n}\nFastBuffer.prototype.constructor = Buffer;\n\nBuffer.prototype = FastBuffer.prototype;\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nexports.kMaxLength = binding.kMaxLength;\n\nconst kFromErrorMsg = 'First argument must be a string, Buffer, ' +\n                      'ArrayBuffer, Array, or array-like object.';\n\nBuffer.poolSize = 8 * 1024;\nvar poolSize, poolOffset, allocPool;\n\n\nbinding.setupBufferJS(Buffer.prototype, bindingObj);\n\n// |binding.zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nconst zeroFill = bindingObj.zeroFill || [0];\n\nfunction createUnsafeBuffer(size) {\n  return new FastBuffer(createUnsafeArrayBuffer(size));\n}\n\nfunction createUnsafeArrayBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new ArrayBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeArrayBuffer(poolSize);\n  poolOffset = 0;\n}\ncreatePool();\n\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nvar bufferWarn = true;\nconst bufferWarning = 'The Buffer() and new Buffer() constructors are not ' +\n                      'recommended for use due to security and usability ' +\n                      'concerns. Please use the new Buffer.alloc(), ' +\n                      'Buffer.allocUnsafe(), or Buffer.from() construction ' +\n                      'methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarn) {\n    // This is a *pending* deprecation warning. It is not emitted by\n    // default unless the --pending-deprecation command-line flag is\n    // used or the NODE_PENDING_DEPRECATION=1 envvar is set.\n    process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');\n    bufferWarn = false;\n  }\n}\n\nconst doFlaggedDeprecation =\n  pendingDeprecation ?\n    showFlaggedDeprecation :\n    function() {};\n\n/**\n * The Buffer() construtor is deprecated in documentation and should not be\n * used moving forward. Rather, developers should use one of the three new\n * factory APIs: Buffer.from(), Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n **/\nfunction Buffer(arg, encodingOrOffset, length) {\n  doFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      );\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg, encodingOrOffset, length);\n}\n\nObject.defineProperty(Buffer, Symbol.species, {\n  enumerable: false,\n  configurable: true,\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function(value, encodingOrOffset, length) {\n  if (typeof value === 'string')\n    return fromString(value, encodingOrOffset);\n\n  if (isAnyArrayBuffer(value))\n    return fromArrayBuffer(value, encodingOrOffset, length);\n\n  var b = fromObject(value);\n  if (b)\n    return b;\n\n  if (typeof value === 'number')\n    throw new TypeError('\"value\" argument must not be a number');\n  throw new TypeError(kFromErrorMsg);\n};\n\nObject.setPrototypeOf(Buffer, Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nfunction assertSize(size) {\n  let err = null;\n\n  if (typeof size !== 'number')\n    err = new TypeError('\"size\" argument must be a number');\n  else if (size < 0)\n    err = new RangeError('\"size\" argument must not be negative');\n  else if (size > binding.kMaxLength)\n    err = new RangeError('\"size\" argument must not be larger ' +\n                         'than ' + binding.kMaxLength);\n\n  if (err) {\n    Error.captureStackTrace(err, assertSize);\n    throw err;\n  }\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function(size, fill, encoding) {\n  assertSize(size);\n  if (size > 0 && fill !== undefined) {\n    // Since we are filling anyway, don't zero fill initially.\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    if (typeof encoding !== 'string')\n      encoding = undefined;\n    return createUnsafeBuffer(size).fill(fill, encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer.\n **/\nBuffer.allocUnsafe = function(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set, will zero-fill the buffer.\n **/\nBuffer.allocUnsafeSlow = function(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set, a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  // eslint-disable-next-line eqeqeq\n  if (+length != length)\n    length = 0;\n  assertSize(+length);\n  return createUnsafeBuffer(+length);\n}\n\nObject.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(SlowBuffer, Uint8Array);\n\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    var b = new FastBuffer(allocPool, poolOffset, size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  } else {\n    return createUnsafeBuffer(size);\n  }\n}\n\n\nfunction fromString(string, encoding) {\n  var length;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    encoding = 'utf8';\n    if (string.length === 0)\n      return new FastBuffer();\n    length = binding.byteLengthUtf8(string);\n  } else {\n    length = byteLength(string, encoding, true);\n    if (length === -1)\n      throw new TypeError('\"encoding\" must be a valid string encoding');\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return binding.createFromString(string, encoding);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  var b = new FastBuffer(allocPool, poolOffset, length);\n  const actual = b.write(string, encoding);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case, though.\n    b = new FastBuffer(allocPool, poolOffset, actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromArrayLike(obj) {\n  const length = obj.length;\n  const b = allocate(length);\n  for (var i = 0; i < length; i++)\n    b[i] = obj[i];\n  return b;\n}\n\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  // convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    // check for NaN\n    if (byteOffset !== byteOffset)\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new RangeError(\"'offset' is out of bounds\");\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // convert length to non-negative integer\n    length = +length;\n    // Check for NaN\n    if (length !== length) {\n      length = 0;\n    } else if (length > 0) {\n      length = (length < Number.MAX_SAFE_INTEGER ?\n                length : Number.MAX_SAFE_INTEGER);\n      if (length > maxLength)\n        throw new RangeError(\"'length' is out of bounds\");\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj, byteOffset, length);\n}\n\nfunction fromObject(obj) {\n  if (isUint8Array(obj)) {\n    const b = allocate(obj.length);\n\n    if (b.length === 0)\n      return b;\n\n    binding.copy(obj, b, 0, 0, obj.length);\n    return b;\n  }\n\n  if (obj != null) {\n    if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n      if (typeof obj.length !== 'number' || obj.length !== obj.length) {\n        return new FastBuffer();\n      }\n      return fromArrayLike(obj);\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n}\n\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\n\nBuffer.compare = function compare(a, b) {\n  if (!isUint8Array(a) || !isUint8Array(b)) {\n    throw new TypeError('Arguments must be Buffers or Uint8Arrays');\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  return binding.compare(a, b);\n};\n\n\nBuffer.isEncoding = function(encoding) {\n  return typeof encoding === 'string' &&\n         typeof internalUtil.normalizeEncoding(encoding) === 'string';\n};\nBuffer[internalUtil.kIsEncodingSymbol] = Buffer.isEncoding;\n\nconst kConcatErrMsg = '\"list\" argument must be an Array ' +\n                      'of Buffer or Uint8Array instances';\n\nBuffer.concat = function(list, length) {\n  var i;\n  if (!Array.isArray(list))\n    throw new TypeError(kConcatErrMsg);\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; i++)\n      length += list[i].length;\n  } else {\n    length = length >>> 0;\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; i++) {\n    var buf = list[i];\n    if (!isUint8Array(buf))\n      throw new TypeError(kConcatErrMsg);\n    binding.copy(buf, buffer, pos);\n    pos += buf.length;\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length, i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    buffer.fill(0, pos, length);\n  }\n\n  return buffer;\n};\n\n\nfunction base64ByteLength(str, bytes) {\n  // Handle padding\n  if (str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\n\nfunction byteLength(string, encoding) {\n  if (typeof string !== 'string') {\n    if (ArrayBuffer.isView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new TypeError('\"string\" must be a string, Buffer, or ArrayBuffer');\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : binding.byteLengthUtf8(string));\n\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ucs2') return len * 2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ucs2') return len * 2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ascii') return len;\n      if (encoding === 'ucs-2') return len * 2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ascii') return len;\n      if (encoding === 'ucs-2') return len * 2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return len * 2;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return len * 2;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary') return len;\n      if (encoding === 'base64') return base64ByteLength(string, len);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary') return len;\n      if (encoding === 'base64') return base64ByteLength(string, len);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return len >>> 1;\n      break;\n  }\n  return (mustMatch ? -1 : binding.byteLengthUtf8(string));\n}\n\nBuffer.byteLength = byteLength;\n\n\n// For backwards compatibility.\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\n\nfunction stringSlice(buf, encoding, start, end) {\n  if (encoding === undefined) return buf.utf8Slice(start, end);\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return buf.utf8Slice(start, end);\n      if (encoding === 'ucs2') return buf.ucs2Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return buf.utf8Slice(start, end);\n      if (encoding === 'ucs2') return buf.ucs2Slice(start, end);\n      break;\n    case 5:\n      if (encoding === 'utf-8') return buf.utf8Slice(start, end);\n      if (encoding === 'ascii') return buf.asciiSlice(start, end);\n      if (encoding === 'ucs-2') return buf.ucs2Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return buf.utf8Slice(start, end);\n      if (encoding === 'ascii') return buf.asciiSlice(start, end);\n      if (encoding === 'ucs-2') return buf.ucs2Slice(start, end);\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return buf.latin1Slice(start, end);\n      if (encoding === 'base64') return buf.base64Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary')\n        return buf.latin1Slice(start, end);\n      if (encoding === 'base64') return buf.base64Slice(start, end);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return buf.hexSlice(start, end);\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return buf.ucs2Slice(start, end);\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return buf.ucs2Slice(start, end);\n      break;\n  }\n  throw new TypeError('Unknown encoding: ' + encoding);\n}\n\n\nBuffer.prototype.copy = function(target, targetStart, sourceStart, sourceEnd) {\n  return binding.copy(this, target, targetStart, sourceStart, sourceEnd);\n};\n\n// No need to verify that \"buf.length <= MAX_UINT32\" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function(encoding, start, end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0, this.length);\n  }\n\n  const len = this.length;\n  if (len === 0)\n    return '';\n\n  if (!start || start < 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n\n  if (end === undefined || end > len)\n    end = len;\n  else if (end <= 0)\n    return '';\n\n  start |= 0;\n  end |= 0;\n\n  if (end <= start)\n    return '';\n  return stringSlice(this, encoding, start, end);\n};\n\n\nBuffer.prototype.equals = function equals(b) {\n  if (!isUint8Array(b))\n    throw new TypeError('Argument must be a Buffer or Uint8Array');\n\n  if (this === b)\n    return true;\n\n  return binding.compare(this, b) === 0;\n};\n\n\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[internalUtil.customInspectSymbol] = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max)\n    str += ' ... ';\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[internalUtil.customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target,\n                                            start,\n                                            end,\n                                            thisStart,\n                                            thisEnd) {\n  if (!isUint8Array(target))\n    throw new TypeError('Argument must be a Buffer or Uint8Array');\n  if (arguments.length === 1)\n    return compare_(this, target);\n\n  if (start === undefined)\n    start = 0;\n  else if (start < 0)\n    throw new RangeError('out of range index');\n  else\n    start >>>= 0;\n\n  if (end === undefined)\n    end = target.length;\n  else if (end > target.length)\n    throw new RangeError('out of range index');\n  else\n    end >>>= 0;\n\n  if (thisStart === undefined)\n    thisStart = 0;\n  else if (thisStart < 0)\n    throw new RangeError('out of range index');\n  else\n    thisStart >>>= 0;\n\n  if (thisEnd === undefined)\n    thisEnd = this.length;\n  else if (thisEnd > this.length)\n    throw new RangeError('out of range index');\n  else\n    thisEnd >>>= 0;\n\n  if (thisStart >= thisEnd)\n    return (start >= end ? 0 : -1);\n  else if (start >= end)\n    return 1;\n\n  return compareOffset(this, target, start, thisStart, end, thisEnd);\n};\n\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined, \"foo\", {}, coerces to NaN, search whole buffer.\n  // `x !== x`-style conditionals are a faster form of `isNaN(x)`\n  if (byteOffset !== byteOffset) {\n    byteOffset = dir ? 0 : buffer.length;\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'string') {\n    if (encoding === undefined) {\n      return binding.indexOfString(buffer, val, byteOffset, encoding, dir);\n    }\n    return slowIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (isUint8Array(val)) {\n    return binding.indexOfBuffer(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    return binding.indexOfNumber(buffer, val, byteOffset, dir);\n  }\n\n  throw new TypeError('\"val\" argument must be string, number, Buffer ' +\n                      'or Uint8Array');\n}\n\n\nfunction slowIndexOf(buffer, val, byteOffset, encoding, dir) {\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'utf8':\n      case 'utf-8':\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n      case 'latin1':\n      case 'binary':\n        return binding.indexOfString(buffer, val, byteOffset, encoding, dir);\n\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return binding.indexOfBuffer(\n            buffer, Buffer.from(val, encoding), byteOffset, encoding, dir);\n\n      default:\n        if (loweredCase) {\n          throw new TypeError('Unknown encoding: ' + encoding);\n        }\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    var normalizedEncoding = internalUtil.normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n\n    if (val.length === 0) {\n      // Previously, if val === '', the Buffer would not fill,\n      // which is rather surprising.\n      val = 0;\n    } else if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if ((normalizedEncoding === 'utf8' && code < 128) ||\n          normalizedEncoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || end > this.length)\n    throw new RangeError('Out of range index');\n\n  if (end <= start)\n    return this;\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  binding.fill(this, val, start, end, encoding);\n\n  return this;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string, 0, this.length);\n\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n    if (isFinite(length)) {\n      length = length >>> 0;\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n      length = remaining;\n\n    if (string.length > 0 && (length < 0 || offset < 0))\n      throw new RangeError('Attempt to write outside buffer bounds');\n  } else {\n    // if someone is still calling the obsolete form of write(), tell them.\n    // we don't want eg buf.write(\"foo\", \"utf8\", 10) to silently turn into\n    // buf.write(\"foo\", \"utf8\"), so we can't ignore extra args\n    throw new Error('Buffer.write(string, encoding, offset[, length]) ' +\n                    'is no longer supported');\n  }\n\n  if (!encoding) return this.utf8Write(string, offset, length);\n\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ucs2') return this.ucs2Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ucs2') return this.ucs2Write(string, offset, length);\n      break;\n    case 5:\n      if (encoding === 'utf-8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ascii') return this.asciiWrite(string, offset, length);\n      if (encoding === 'ucs-2') return this.ucs2Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ascii') return this.asciiWrite(string, offset, length);\n      if (encoding === 'ucs-2') return this.ucs2Write(string, offset, length);\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return this.ucs2Write(string, offset, length);\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return this.ucs2Write(string, offset, length);\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return this.latin1Write(string, offset, length);\n      if (encoding === 'base64')\n        return this.base64Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary')\n        return this.latin1Write(string, offset, length);\n      if (encoding === 'base64')\n        return this.base64Write(string, offset, length);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return this.hexWrite(string, offset, length);\n      break;\n  }\n  throw new TypeError('Unknown encoding: ' + encoding);\n};\n\n\nBuffer.prototype.toJSON = function() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (var i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer', data };\n  } else {\n    return { type: 'Buffer', data: [] };\n  }\n};\n\n\nfunction adjustOffset(offset, length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence, don't use offset | 0 or similar techniques.\n  offset = Math.trunc(offset);\n  // `x !== x`-style conditionals are a faster form of `isNaN(x)`\n  if (offset === 0 || offset !== offset) {\n    return 0;\n  } else if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  } else {\n    return offset < length ? offset : length;\n  }\n}\n\n\nBuffer.prototype.slice = function slice(start, end) {\n  const srcLength = this.length;\n  start = adjustOffset(start, srcLength);\n  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n};\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset + ext > length)\n    throw new RangeError('Index out of range');\n}\n\n\nBuffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100))\n    val += this[offset + i] * mul;\n\n  return val;\n};\n\n\nBuffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100))\n    val += this[offset + --byteLength] * mul;\n\n  return val;\n};\n\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8);\n};\n\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1];\n};\n\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000);\n};\n\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n      ((this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      this[offset + 3]);\n};\n\n\nBuffer.prototype.readIntLE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100))\n    val += this[offset + i] * mul;\n  mul *= 0x80;\n\n  if (val >= mul)\n    val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\n\nBuffer.prototype.readIntBE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100))\n    val += this[offset + --i] * mul;\n  mul *= 0x80;\n\n  if (val >= mul)\n    val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\n\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  var val = this[offset];\n  return !(val & 0x80) ? val : (0xff - val + 1) * -1;\n};\n\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16) |\n      (this[offset + 3] << 24);\n};\n\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3]);\n};\n\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n  return binding.readFloatLE(this, offset);\n};\n\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n  return binding.readFloatBE(this, offset);\n};\n\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 8, this.length);\n  return binding.readDoubleLE(this, offset);\n};\n\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 8, this.length);\n  return binding.readDoubleBE(this, offset);\n};\n\n\nfunction checkInt(buffer, value, offset, ext, max, min) {\n  if (value > max || value < min)\n    throw new TypeError('\"value\" argument is out of bounds');\n  if (offset + ext > buffer.length)\n    throw new RangeError('Index out of range');\n}\n\n\nBuffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value;\n  while (++i < byteLength && (mul *= 0x100))\n    this[offset + i] = (value / mul) >>> 0;\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value;\n  while (--i >= 0 && (mul *= 0x100))\n    this[offset + i] = (value / mul) >>> 0;\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = (value >>> 24);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 1] = (value >>> 8);\n  this[offset] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkInt(this,\n             value,\n             offset,\n             byteLength,\n             Math.pow(2, 8 * byteLength - 1) - 1,\n             -Math.pow(2, 8 * byteLength - 1));\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\n      sub = 1;\n    this[offset + i] = ((value / mul) >> 0) - sub;\n  }\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkInt(this,\n             value,\n             offset,\n             byteLength,\n             Math.pow(2, 8 * byteLength - 1) - 1,\n             -Math.pow(2, 8 * byteLength - 1));\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\n      sub = 1;\n    this[offset + i] = ((value / mul) >> 0) - sub;\n  }\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0x7f, -0x80);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 3] = (value >>> 24);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeFloatLE(this, val, offset);\n  else\n    binding.writeFloatLE(this, val, offset, true);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeFloatBE(this, val, offset);\n  else\n    binding.writeFloatBE(this, val, offset, true);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeDoubleLE(this, val, offset);\n  else\n    binding.writeDoubleLE(this, val, offset, true);\n  return offset + 8;\n};\n\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeDoubleBE(this, val, offset);\n  else\n    binding.writeDoubleBE(this, val, offset, true);\n  return offset + 8;\n};\n\nconst swap16n = binding.swap16;\nconst swap32n = binding.swap32;\nconst swap64n = binding.swap64;\n\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  if (len < 128) {\n    for (var i = 0; i < len; i += 2)\n      swap(this, i, i + 1);\n    return this;\n  }\n  return swap16n(this);\n};\n\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  if (len < 192) {\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  }\n  return swap32n(this);\n};\n\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  if (len < 192) {\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  }\n  return swap64n(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n// Put this at the end because internal/buffer has a circular\n// dependency on Buffer.\nconst internalBuffer = require('internal/buffer');\nexports.transcode = internalBuffer.transcode;\ninternalBuffer.FastBuffer = FastBuffer;\n",
  "child_process": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst {\n  deprecate, convertToValidSignal, customPromisifyArgs\n} = require('internal/util');\nconst debug = util.debuglog('child_process');\n\nconst uv = process.binding('uv');\nconst spawn_sync = process.binding('spawn_sync');\nconst Buffer = require('buffer').Buffer;\nconst Pipe = process.binding('pipe_wrap').Pipe;\nconst { isUint8Array } = process.binding('util');\nconst child_process = require('internal/child_process');\n\nconst errnoException = util._errnoException;\nconst _validateStdio = child_process._validateStdio;\nconst setupChannel = child_process.setupChannel;\nconst ChildProcess = exports.ChildProcess = child_process.ChildProcess;\n\nfunction stdioStringToArray(option) {\n  switch (option) {\n    case 'ignore':\n    case 'pipe':\n    case 'inherit':\n      return [option, option, option, 'ipc'];\n    default:\n      throw new TypeError('Incorrect value of stdio option: ' + option);\n  }\n}\n\nexports.fork = function(modulePath /*, args, options*/) {\n\n  // Get options and args arguments.\n  var execArgv;\n  var options = {};\n  var args = [];\n  var pos = 1;\n  if (pos < arguments.length && Array.isArray(arguments[pos])) {\n    args = arguments[pos++];\n  }\n\n  if (pos < arguments.length && arguments[pos] != null) {\n    if (typeof arguments[pos] !== 'object') {\n      throw new TypeError('Incorrect value of args option');\n    }\n\n    options = util._extend({}, arguments[pos++]);\n  }\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = execArgv.lastIndexOf(process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = execArgv.slice();\n      execArgv.splice(index - 1, 2);\n    }\n  }\n\n  args = execArgv.concat([modulePath], args);\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio);\n  } else if (!Array.isArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin, stdout,\n    // and stderr from the parent if silent isn't set.\n    options.stdio = options.silent ? stdioStringToArray('pipe') :\n        stdioStringToArray('inherit');\n  } else if (options.stdio.indexOf('ipc') === -1) {\n    throw new TypeError('Forked processes must have an IPC channel');\n  }\n\n  options.execPath = options.execPath || process.execPath;\n\n  return spawn(options.execPath, args, options);\n};\n\n\nexports._forkChild = function(fd) {\n  // set process.send()\n  var p = new Pipe(true);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process, p);\n  process.on('newListener', function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.ref();\n  });\n  process.on('removeListener', function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unref();\n  });\n};\n\n\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options);\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command,\n    options: options,\n    callback: callback\n  };\n}\n\n\nexports.exec = function(command /*, options, callback*/) {\n  var opts = normalizeExecArgs.apply(null, arguments);\n  return exports.execFile(opts.file,\n                          opts.options,\n                          opts.callback);\n};\n\nObject.defineProperty(exports.exec, customPromisifyArgs,\n                      { value: ['stdout', 'stderr'], enumerable: false });\n\n\nexports.execFile = function(file /*, args, options, callback*/) {\n  var args = [];\n  var callback;\n  var options = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null,\n    shell: false\n  };\n\n  // Parse the optional positional parameters.\n  var pos = 1;\n  if (pos < arguments.length && Array.isArray(arguments[pos])) {\n    args = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\n    util._extend(options, arguments[pos++]);\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\n    callback = arguments[pos++];\n  }\n\n  if (!callback && pos < arguments.length && arguments[pos] != null) {\n    throw new TypeError('Incorrect value of args option');\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  var encoding;\n  var _stdout;\n  var _stderr;\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n    _stdout = '';\n    _stderr = '';\n  } else {\n    _stdout = [];\n    _stderr = [];\n    encoding = null;\n  }\n  var stdoutLen = 0;\n  var stderrLen = 0;\n  var killed = false;\n  var exited = false;\n  var timeoutId;\n\n  var ex = null;\n\n  var cmd = file;\n\n  function exithandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    var stdout;\n    var stderr;\n    if (encoding) {\n      stdout = _stdout;\n      stderr = _stderr;\n    } else {\n      stdout = Buffer.concat(_stdout);\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    if (args.length !== 0)\n      cmd += ' ' + args.join(' ');\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code < 0 ? uv.errname(code) : code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data', function onChildStdout(chunk) {\n      stdoutLen += encoding ? Buffer.byteLength(chunk, encoding) : chunk.length;\n\n      if (stdoutLen > options.maxBuffer) {\n        ex = new Error('stdout maxBuffer exceeded');\n        kill();\n      } else {\n        if (encoding)\n          _stdout += chunk;\n        else\n          _stdout.push(chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data', function onChildStderr(chunk) {\n      stderrLen += encoding ? Buffer.byteLength(chunk, encoding) : chunk.length;\n\n      if (stderrLen > options.maxBuffer) {\n        ex = new Error('stderr maxBuffer exceeded');\n        kill();\n      } else {\n        if (encoding)\n          _stderr += chunk;\n        else\n          _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener('close', exithandler);\n  child.addListener('error', errorhandler);\n\n  return child;\n};\n\nObject.defineProperty(exports.execFile, customPromisifyArgs,\n                      { value: ['stdout', 'stderr'], enumerable: false });\n\nconst _deprecatedCustomFds = deprecate(\n  function deprecateCustomFds(options) {\n    options.stdio = options.customFds.map(function mapCustomFds(fd) {\n      return fd === -1 ? 'pipe' : fd;\n    });\n  }, 'child_process: options.customFds option is deprecated. ' +\n     'Use options.stdio instead.', 'DEP0006');\n\nfunction _convertCustomFds(options) {\n  if (options.customFds && !options.stdio) {\n    _deprecatedCustomFds(options);\n  }\n}\n\nfunction normalizeSpawnArguments(file, args, options) {\n  if (typeof file !== 'string' || file.length === 0)\n    throw new TypeError('\"file\" argument must be a non-empty string');\n\n  if (Array.isArray(args)) {\n    args = args.slice(0);\n  } else if (args !== undefined &&\n             (args === null || typeof args !== 'object')) {\n    throw new TypeError('Incorrect value of args option');\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = {};\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be an object');\n\n  // Validate the cwd, if present.\n  if (options.cwd != null &&\n      typeof options.cwd !== 'string') {\n    throw new TypeError('\"cwd\" must be a string');\n  }\n\n  // Validate detached, if present.\n  if (options.detached != null &&\n      typeof options.detached !== 'boolean') {\n    throw new TypeError('\"detached\" must be a boolean');\n  }\n\n  // Validate the uid, if present.\n  if (options.uid != null && !Number.isInteger(options.uid)) {\n    throw new TypeError('\"uid\" must be an integer');\n  }\n\n  // Validate the gid, if present.\n  if (options.gid != null && !Number.isInteger(options.gid)) {\n    throw new TypeError('\"gid\" must be an integer');\n  }\n\n  // Validate the shell, if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new TypeError('\"shell\" must be a boolean or string');\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null &&\n      typeof options.argv0 !== 'string') {\n    throw new TypeError('\"argv0\" must be a string');\n  }\n\n  // Validate windowsVerbatimArguments, if present.\n  if (options.windowsVerbatimArguments != null &&\n      typeof options.windowsVerbatimArguments !== 'boolean') {\n    throw new TypeError('\"windowsVerbatimArguments\" must be a boolean');\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options);\n\n  if (options.shell) {\n    const command = [file].concat(args).join(' ');\n\n    if (process.platform === 'win32') {\n      file = typeof options.shell === 'string' ? options.shell :\n              process.env.comspec || 'cmd.exe';\n      args = ['/d', '/s', '/c', '\"' + command + '\"'];\n      options.windowsVerbatimArguments = true;\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c', command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    args.unshift(options.argv0);\n  } else {\n    args.unshift(file);\n  }\n\n  var env = options.env || process.env;\n  var envPairs = [];\n\n  for (var key in env) {\n    envPairs.push(key + '=' + env[key]);\n  }\n\n  _convertCustomFds(options);\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: envPairs\n  };\n}\n\n\nvar spawn = exports.spawn = function(/*file, args, options*/) {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n  var options = opts.options;\n  var child = new ChildProcess();\n\n  debug('spawn', opts.args, options);\n\n  child.spawn({\n    file: opts.file,\n    args: opts.args,\n    cwd: options.cwd,\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments,\n    detached: !!options.detached,\n    envPairs: opts.envPairs,\n    stdio: options.stdio,\n    uid: options.uid,\n    gid: options.gid\n  });\n\n  return child;\n};\n\nfunction spawnSync(/*file, args, options*/) {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n\n  var options = opts.options;\n\n  var i;\n\n  debug('spawnSync', opts.args, options);\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.file = opts.file;\n  options.args = opts.args;\n  options.envPairs = opts.envPairs;\n\n  // Validate and translate the kill signal, if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;\n\n  if (options.input) {\n    var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd, ensure it is a valid buffer\n  for (i = 0; i < options.stdio.length; i++) {\n    var input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);\n      if (isUint8Array(input))\n        pipe.input = input;\n      else if (typeof input === 'string')\n        pipe.input = Buffer.from(input, options.encoding);\n      else\n        throw new TypeError(util.format(\n            'stdio[%d] should be Buffer, Uint8Array or string not %s',\n            i,\n            typeof input));\n    }\n  }\n\n  var result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error, 'spawnSync ' + opts.file);\n    result.error.path = opts.file;\n    result.error.spawnargs = opts.args.slice(1);\n  }\n\n  util._extend(result, opts);\n\n  return result;\n}\nexports.spawnSync = spawnSync;\n\n\nfunction checkExecSyncError(ret) {\n  if (ret.error || ret.status !== 0) {\n    var err = ret.error;\n    ret.error = null;\n\n    if (!err) {\n      var msg = 'Command failed: ';\n      msg += ret.cmd || ret.args.join(' ');\n      if (ret.stderr && ret.stderr.length > 0)\n        msg += '\\n' + ret.stderr.toString();\n      err = new Error(msg);\n    }\n\n    util._extend(err, ret);\n    return err;\n  }\n\n  return false;\n}\n\n\nfunction execFileSync(/*command, args, options*/) {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n  var inheritStderr = !opts.options.stdio;\n\n  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  var err = checkExecSyncError(ret);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\nexports.execFileSync = execFileSync;\n\n\nfunction execSync(command /*, options*/) {\n  var opts = normalizeExecArgs.apply(null, arguments);\n  var inheritStderr = !opts.options.stdio;\n\n  var ret = spawnSync(opts.file, opts.options);\n  ret.cmd = command;\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  var err = checkExecSyncError(ret);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\nexports.execSync = execSync;\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new TypeError('\"timeout\" must be an unsigned integer');\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new TypeError('\"maxBuffer\" must be a positive number');\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new TypeError('\"killSignal\" must be a string or number');\n  }\n}\n",
  "console": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\n\nfunction Console(stdout, stderr, ignoreErrors = true) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr, ignoreErrors);\n  }\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  } else if (typeof stderr.write !== 'function') {\n    throw new TypeError('Console expects writable stream instances');\n  }\n\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = ignoreErrors;\n  Object.defineProperty(this, '_ignoreErrors', prop);\n  prop.value = new Map();\n  Object.defineProperty(this, '_times', prop);\n  prop.value = createWriteErrorHandler(stdout);\n  Object.defineProperty(this, '_stdoutErrorHandler', prop);\n  prop.value = createWriteErrorHandler(stderr);\n  Object.defineProperty(this, '_stderrErrorHandler', prop);\n\n  // bind the prototype functions to this Console instance\n  var keys = Object.keys(Console.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var k = keys[v];\n    this[k] = this[k].bind(this);\n  }\n}\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(stream) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    if (err && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes won’t be affected.\n      stream.once('error', noop);\n    }\n  };\n}\n\nfunction write(ignoreErrors, stream, string, errorhandler) {\n  if (!ignoreErrors) return stream.write(string);\n\n  // There may be an error occurring synchronously (e.g. for files or TTYs\n  // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n  // handle both situations.\n  try {\n    // Add and later remove a noop error handler to catch synchronous errors.\n    stream.once('error', noop);\n\n    stream.write(string, errorhandler);\n  } catch (e) {\n    // Sorry, there’s no proper way to pass along the error here.\n  } finally {\n    stream.removeListener('error', noop);\n  }\n}\n\n\n// As of v8 5.0.71.32, the combination of rest param, template string\n// and .apply(null, args) benchmarks consistently faster than using\n// the spread operator when calling util.format.\nConsole.prototype.log = function log(...args) {\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.format.apply(null, args)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.info = Console.prototype.log;\n\n\nConsole.prototype.warn = function warn(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        `${util.format.apply(null, args)}\\n`,\n        this._stderrErrorHandler);\n};\n\n\nConsole.prototype.error = Console.prototype.warn;\n\n\nConsole.prototype.dir = function dir(object, options) {\n  options = Object.assign({customInspect: false}, options);\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.inspect(object, options)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.time = function time(label) {\n  this._times.set(label, process.hrtime());\n};\n\n\nConsole.prototype.timeEnd = function timeEnd(label) {\n  const time = this._times.get(label);\n  if (!time) {\n    process.emitWarning(`No such label '${label}' for console.timeEnd()`);\n    return;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n  this.log('%s: %sms', label, ms.toFixed(3));\n  this._times.delete(label);\n};\n\n\nConsole.prototype.trace = function trace(...args) {\n  // TODO probably can to do this better with V8's debug object once that is\n  // exposed.\n  var err = new Error();\n  err.name = 'Trace';\n  err.message = util.format.apply(null, args);\n  Error.captureStackTrace(err, trace);\n  this.error(err.stack);\n};\n\n\nConsole.prototype.assert = function assert(expression, ...args) {\n  if (!expression) {\n    require('assert').ok(false, util.format.apply(null, args));\n  }\n};\n\n\nmodule.exports = new Console(process.stdout, process.stderr);\nmodule.exports.Console = Console;\n\nfunction noop() {}\n",
  "constants": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// This module is deprecated in documentation only. Users should be directed\n// towards using the specific constants exposed by the individual modules on\n// which they are most relevant.\n// Deprecation Code: DEP0008\nconst constants = process.binding('constants');\nObject.assign(exports,\n              constants.os.errno,\n              constants.os.signals,\n              constants.fs,\n              constants.crypto);\n",
  "crypto": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Note: In 0.8 and before, crypto functions all defaulted to using\n// binary-encoded strings rather than buffers.\n\n'use strict';\n\nconst internalUtil = require('internal/util');\ninternalUtil.assertCrypto();\n\nexports.DEFAULT_ENCODING = 'buffer';\n\nconst constants = process.binding('constants').crypto;\nconst binding = process.binding('crypto');\nconst randomBytes = binding.randomBytes;\nconst getCiphers = binding.getCiphers;\nconst getHashes = binding.getHashes;\nconst getCurves = binding.getCurves;\nconst getFipsCrypto = binding.getFipsCrypto;\nconst setFipsCrypto = binding.setFipsCrypto;\nconst timingSafeEqual = binding.timingSafeEqual;\n\nconst Buffer = require('buffer').Buffer;\nconst kBufferMaxLength = require('buffer').kMaxLength;\nconst stream = require('stream');\nconst util = require('util');\nconst { isUint8Array } = process.binding('util');\nconst LazyTransform = require('internal/streams/lazy_transform');\n\nconst DH_GENERATOR = 2;\n\nObject.defineProperty(exports, 'constants', {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n\n// This is here because many functions accepted binary strings without\n// any explicit encoding in older versions of node, and we don't want\n// to break them unnecessarily.\nfunction toBuf(str, encoding) {\n  if (typeof str === 'string') {\n    if (encoding === 'buffer' || !encoding)\n      encoding = 'utf8';\n    return Buffer.from(str, encoding);\n  }\n  return str;\n}\nexports._toBuf = toBuf;\n\n\nconst assert = require('assert');\nconst StringDecoder = require('string_decoder').StringDecoder;\n\n\nexports.createHash = exports.Hash = Hash;\nfunction Hash(algorithm, options) {\n  if (!(this instanceof Hash))\n    return new Hash(algorithm, options);\n  this._handle = new binding.Hash(algorithm);\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Hash, LazyTransform);\n\nHash.prototype._transform = function _transform(chunk, encoding, callback) {\n  this._handle.update(chunk, encoding);\n  callback();\n};\n\nHash.prototype._flush = function _flush(callback) {\n  this.push(this._handle.digest());\n  callback();\n};\n\nHash.prototype.update = function update(data, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  this._handle.update(data, encoding);\n  return this;\n};\n\n\nHash.prototype.digest = function digest(outputEncoding) {\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n  // Explicit conversion for backward compatibility.\n  return this._handle.digest(`${outputEncoding}`);\n};\n\n\nexports.createHmac = exports.Hmac = Hmac;\n\nfunction Hmac(hmac, key, options) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hmac, key, options);\n  this._handle = new binding.Hmac();\n  this._handle.init(hmac, toBuf(key));\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Hmac, LazyTransform);\n\nHmac.prototype.update = Hash.prototype.update;\nHmac.prototype.digest = Hash.prototype.digest;\nHmac.prototype._flush = Hash.prototype._flush;\nHmac.prototype._transform = Hash.prototype._transform;\n\n\nfunction getDecoder(decoder, encoding) {\n  encoding = internalUtil.normalizeEncoding(encoding);\n  decoder = decoder || new StringDecoder(encoding);\n  assert(decoder.encoding === encoding, 'Cannot change encoding');\n  return decoder;\n}\n\n\nexports.createCipher = exports.Cipher = Cipher;\nfunction Cipher(cipher, password, options) {\n  if (!(this instanceof Cipher))\n    return new Cipher(cipher, password, options);\n  this._handle = new binding.CipherBase(true);\n\n  this._handle.init(cipher, toBuf(password));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Cipher, LazyTransform);\n\nCipher.prototype._transform = function _transform(chunk, encoding, callback) {\n  this.push(this._handle.update(chunk, encoding));\n  callback();\n};\n\nCipher.prototype._flush = function _flush(callback) {\n  try {\n    this.push(this._handle.final());\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  callback();\n};\n\nCipher.prototype.update = function update(data, inputEncoding, outputEncoding) {\n  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n\n  var ret = this._handle.update(data, inputEncoding);\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    ret = this._decoder.write(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.final = function final(outputEncoding) {\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n  var ret = this._handle.final();\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    ret = this._decoder.end(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.setAutoPadding = function setAutoPadding(ap) {\n  this._handle.setAutoPadding(ap);\n  return this;\n};\n\nCipher.prototype.getAuthTag = function getAuthTag() {\n  return this._handle.getAuthTag();\n};\n\n\nCipher.prototype.setAuthTag = function setAuthTag(tagbuf) {\n  this._handle.setAuthTag(tagbuf);\n  return this;\n};\n\nCipher.prototype.setAAD = function setAAD(aadbuf) {\n  this._handle.setAAD(aadbuf);\n  return this;\n};\n\nexports.createCipheriv = exports.Cipheriv = Cipheriv;\nfunction Cipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Cipheriv))\n    return new Cipheriv(cipher, key, iv, options);\n  this._handle = new binding.CipherBase(true);\n  this._handle.initiv(cipher, toBuf(key), toBuf(iv));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Cipheriv, LazyTransform);\n\nCipheriv.prototype._transform = Cipher.prototype._transform;\nCipheriv.prototype._flush = Cipher.prototype._flush;\nCipheriv.prototype.update = Cipher.prototype.update;\nCipheriv.prototype.final = Cipher.prototype.final;\nCipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\nCipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;\nCipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;\nCipheriv.prototype.setAAD = Cipher.prototype.setAAD;\n\nexports.createDecipher = exports.Decipher = Decipher;\nfunction Decipher(cipher, password, options) {\n  if (!(this instanceof Decipher))\n    return new Decipher(cipher, password, options);\n\n  this._handle = new binding.CipherBase(false);\n  this._handle.init(cipher, toBuf(password));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Decipher, LazyTransform);\n\nDecipher.prototype._transform = Cipher.prototype._transform;\nDecipher.prototype._flush = Cipher.prototype._flush;\nDecipher.prototype.update = Cipher.prototype.update;\nDecipher.prototype.final = Cipher.prototype.final;\nDecipher.prototype.finaltol = Cipher.prototype.final;\nDecipher.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\nDecipher.prototype.getAuthTag = Cipher.prototype.getAuthTag;\nDecipher.prototype.setAuthTag = Cipher.prototype.setAuthTag;\nDecipher.prototype.setAAD = Cipher.prototype.setAAD;\n\n\nexports.createDecipheriv = exports.Decipheriv = Decipheriv;\nfunction Decipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Decipheriv))\n    return new Decipheriv(cipher, key, iv, options);\n\n  this._handle = new binding.CipherBase(false);\n  this._handle.initiv(cipher, toBuf(key), toBuf(iv));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Decipheriv, LazyTransform);\n\nDecipheriv.prototype._transform = Cipher.prototype._transform;\nDecipheriv.prototype._flush = Cipher.prototype._flush;\nDecipheriv.prototype.update = Cipher.prototype.update;\nDecipheriv.prototype.final = Cipher.prototype.final;\nDecipheriv.prototype.finaltol = Cipher.prototype.final;\nDecipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\nDecipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;\nDecipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;\nDecipheriv.prototype.setAAD = Cipher.prototype.setAAD;\n\n\nexports.createSign = exports.Sign = Sign;\nfunction Sign(algorithm, options) {\n  if (!(this instanceof Sign))\n    return new Sign(algorithm, options);\n  this._handle = new binding.Sign();\n  this._handle.init(algorithm);\n\n  stream.Writable.call(this, options);\n}\n\nutil.inherits(Sign, stream.Writable);\n\nSign.prototype._write = function _write(chunk, encoding, callback) {\n  this._handle.update(chunk, encoding);\n  callback();\n};\n\nSign.prototype.update = Hash.prototype.update;\n\nSign.prototype.sign = function sign(options, encoding) {\n  if (!options)\n    throw new Error('No key provided to sign');\n\n  var key = options.key || options;\n  var passphrase = options.passphrase || null;\n\n  // Options specific to RSA\n  var rsaPadding = constants.RSA_PKCS1_PADDING;\n  if (options.hasOwnProperty('padding')) {\n    if (options.padding === options.padding >> 0) {\n      rsaPadding = options.padding;\n    } else {\n      throw new TypeError('padding must be an integer');\n    }\n  }\n\n  var pssSaltLength = constants.RSA_PSS_SALTLEN_AUTO;\n  if (options.hasOwnProperty('saltLength')) {\n    if (options.saltLength === options.saltLength >> 0) {\n      pssSaltLength = options.saltLength;\n    } else {\n      throw new TypeError('saltLength must be an integer');\n    }\n  }\n\n  var ret = this._handle.sign(toBuf(key), passphrase, rsaPadding,\n                              pssSaltLength);\n\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    ret = ret.toString(encoding);\n\n  return ret;\n};\n\n\nexports.createVerify = exports.Verify = Verify;\nfunction Verify(algorithm, options) {\n  if (!(this instanceof Verify))\n    return new Verify(algorithm, options);\n\n  this._handle = new binding.Verify();\n  this._handle.init(algorithm);\n\n  stream.Writable.call(this, options);\n}\n\nutil.inherits(Verify, stream.Writable);\n\nVerify.prototype._write = Sign.prototype._write;\nVerify.prototype.update = Sign.prototype.update;\n\nVerify.prototype.verify = function verify(options, signature, sigEncoding) {\n  var key = options.key || options;\n  sigEncoding = sigEncoding || exports.DEFAULT_ENCODING;\n\n  // Options specific to RSA\n  var rsaPadding = constants.RSA_PKCS1_PADDING;\n  if (options.hasOwnProperty('padding')) {\n    if (options.padding === options.padding >> 0) {\n      rsaPadding = options.padding;\n    } else {\n      throw new TypeError('padding must be an integer');\n    }\n  }\n\n  var pssSaltLength = constants.RSA_PSS_SALTLEN_AUTO;\n  if (options.hasOwnProperty('saltLength')) {\n    if (options.saltLength === options.saltLength >> 0) {\n      pssSaltLength = options.saltLength;\n    } else {\n      throw new TypeError('saltLength must be an integer');\n    }\n  }\n\n  return this._handle.verify(toBuf(key), toBuf(signature, sigEncoding),\n                             rsaPadding, pssSaltLength);\n};\n\nfunction rsaPublic(method, defaultPadding) {\n  return function(options, buffer) {\n    var key = options.key || options;\n    var padding = options.padding || defaultPadding;\n    var passphrase = options.passphrase || null;\n    return method(toBuf(key), buffer, padding, passphrase);\n  };\n}\n\nfunction rsaPrivate(method, defaultPadding) {\n  return function(options, buffer) {\n    var key = options.key || options;\n    var passphrase = options.passphrase || null;\n    var padding = options.padding || defaultPadding;\n    return method(toBuf(key), buffer, padding, passphrase);\n  };\n}\n\nexports.publicEncrypt = rsaPublic(binding.publicEncrypt,\n                                  constants.RSA_PKCS1_OAEP_PADDING);\nexports.publicDecrypt = rsaPublic(binding.publicDecrypt,\n                                  constants.RSA_PKCS1_PADDING);\nexports.privateEncrypt = rsaPrivate(binding.privateEncrypt,\n                                    constants.RSA_PKCS1_PADDING);\nexports.privateDecrypt = rsaPrivate(binding.privateDecrypt,\n                                    constants.RSA_PKCS1_OAEP_PADDING);\n\n\nexports.createDiffieHellman = exports.DiffieHellman = DiffieHellman;\n\nfunction DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {\n  if (!(this instanceof DiffieHellman))\n    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);\n\n  if (typeof sizeOrKey !== 'number' &&\n      typeof sizeOrKey !== 'string' &&\n      !ArrayBuffer.isView(sizeOrKey)) {\n    throw new TypeError('First argument should be number, string, ' +\n                        'Buffer, TypedArray, or DataView');\n  }\n\n  if (keyEncoding) {\n    if (typeof keyEncoding !== 'string' ||\n        (!Buffer.isEncoding(keyEncoding) && keyEncoding !== 'buffer')) {\n      genEncoding = generator;\n      generator = keyEncoding;\n      keyEncoding = false;\n    }\n  }\n\n  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;\n  genEncoding = genEncoding || exports.DEFAULT_ENCODING;\n\n  if (typeof sizeOrKey !== 'number')\n    sizeOrKey = toBuf(sizeOrKey, keyEncoding);\n\n  if (!generator)\n    generator = DH_GENERATOR;\n  else if (typeof generator !== 'number')\n    generator = toBuf(generator, genEncoding);\n\n  this._handle = new binding.DiffieHellman(sizeOrKey, generator);\n  Object.defineProperty(this, 'verifyError', {\n    enumerable: true,\n    value: this._handle.verifyError,\n    writable: false\n  });\n}\n\n\nexports.DiffieHellmanGroup =\n    exports.createDiffieHellmanGroup =\n    exports.getDiffieHellman = DiffieHellmanGroup;\n\nfunction DiffieHellmanGroup(name) {\n  if (!(this instanceof DiffieHellmanGroup))\n    return new DiffieHellmanGroup(name);\n  this._handle = new binding.DiffieHellmanGroup(name);\n  Object.defineProperty(this, 'verifyError', {\n    enumerable: true,\n    value: this._handle.verifyError,\n    writable: false\n  });\n}\n\n\nDiffieHellmanGroup.prototype.generateKeys =\n    DiffieHellman.prototype.generateKeys =\n    dhGenerateKeys;\n\nfunction dhGenerateKeys(encoding) {\n  var keys = this._handle.generateKeys();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    keys = keys.toString(encoding);\n  return keys;\n}\n\n\nDiffieHellmanGroup.prototype.computeSecret =\n    DiffieHellman.prototype.computeSecret =\n    dhComputeSecret;\n\nfunction dhComputeSecret(key, inEnc, outEnc) {\n  inEnc = inEnc || exports.DEFAULT_ENCODING;\n  outEnc = outEnc || exports.DEFAULT_ENCODING;\n  var ret = this._handle.computeSecret(toBuf(key, inEnc));\n  if (outEnc && outEnc !== 'buffer')\n    ret = ret.toString(outEnc);\n  return ret;\n}\n\n\nDiffieHellmanGroup.prototype.getPrime =\n    DiffieHellman.prototype.getPrime =\n    dhGetPrime;\n\nfunction dhGetPrime(encoding) {\n  var prime = this._handle.getPrime();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    prime = prime.toString(encoding);\n  return prime;\n}\n\n\nDiffieHellmanGroup.prototype.getGenerator =\n    DiffieHellman.prototype.getGenerator =\n    dhGetGenerator;\n\nfunction dhGetGenerator(encoding) {\n  var generator = this._handle.getGenerator();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    generator = generator.toString(encoding);\n  return generator;\n}\n\n\nDiffieHellmanGroup.prototype.getPublicKey =\n    DiffieHellman.prototype.getPublicKey =\n    dhGetPublicKey;\n\nfunction dhGetPublicKey(encoding) {\n  var key = this._handle.getPublicKey();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    key = key.toString(encoding);\n  return key;\n}\n\n\nDiffieHellmanGroup.prototype.getPrivateKey =\n    DiffieHellman.prototype.getPrivateKey =\n    dhGetPrivateKey;\n\nfunction dhGetPrivateKey(encoding) {\n  var key = this._handle.getPrivateKey();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    key = key.toString(encoding);\n  return key;\n}\n\n\nDiffieHellman.prototype.setPublicKey = function setPublicKey(key, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  this._handle.setPublicKey(toBuf(key, encoding));\n  return this;\n};\n\n\nDiffieHellman.prototype.setPrivateKey = function setPrivateKey(key, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  this._handle.setPrivateKey(toBuf(key, encoding));\n  return this;\n};\n\n\nfunction ECDH(curve) {\n  if (typeof curve !== 'string')\n    throw new TypeError('\"curve\" argument should be a string');\n\n  this._handle = new binding.ECDH(curve);\n}\n\nexports.createECDH = function createECDH(curve) {\n  return new ECDH(curve);\n};\n\nECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;\nECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;\nECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;\nECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;\n\nECDH.prototype.generateKeys = function generateKeys(encoding, format) {\n  this._handle.generateKeys();\n\n  return this.getPublicKey(encoding, format);\n};\n\nECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {\n  var f;\n  if (format) {\n    if (typeof format === 'number')\n      f = format;\n    if (format === 'compressed')\n      f = constants.POINT_CONVERSION_COMPRESSED;\n    else if (format === 'hybrid')\n      f = constants.POINT_CONVERSION_HYBRID;\n    // Default\n    else if (format === 'uncompressed')\n      f = constants.POINT_CONVERSION_UNCOMPRESSED;\n    else\n      throw new TypeError('Bad format: ' + format);\n  } else {\n    f = constants.POINT_CONVERSION_UNCOMPRESSED;\n  }\n  var key = this._handle.getPublicKey(f);\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    key = key.toString(encoding);\n  return key;\n};\n\n\nexports.pbkdf2 = function(password,\n                          salt,\n                          iterations,\n                          keylen,\n                          digest,\n                          callback) {\n  if (typeof digest === 'function') {\n    callback = digest;\n    digest = undefined;\n  }\n\n  if (typeof callback !== 'function')\n    throw new Error('No callback provided to pbkdf2');\n\n  return pbkdf2(password, salt, iterations, keylen, digest, callback);\n};\n\n\nexports.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {\n  return pbkdf2(password, salt, iterations, keylen, digest);\n};\n\n\nfunction pbkdf2(password, salt, iterations, keylen, digest, callback) {\n\n  if (digest === undefined) {\n    throw new TypeError(\n        'The \"digest\" argument is required and must not be undefined');\n  }\n\n  password = toBuf(password);\n  salt = toBuf(salt);\n\n  if (exports.DEFAULT_ENCODING === 'buffer')\n    return binding.PBKDF2(password, salt, iterations, keylen, digest, callback);\n\n  // at this point, we need to handle encodings.\n  var encoding = exports.DEFAULT_ENCODING;\n  if (callback) {\n    function next(er, ret) {\n      if (ret)\n        ret = ret.toString(encoding);\n      callback(er, ret);\n    }\n    binding.PBKDF2(password, salt, iterations, keylen, digest, next);\n  } else {\n    var ret = binding.PBKDF2(password, salt, iterations, keylen, digest);\n    return ret.toString(encoding);\n  }\n}\n\n\nexports.Certificate = Certificate;\n\nfunction Certificate() {\n  if (!(this instanceof Certificate))\n    return new Certificate();\n}\n\n\nCertificate.prototype.verifySpkac = function verifySpkac(object) {\n  return binding.certVerifySpkac(object);\n};\n\n\nCertificate.prototype.exportPublicKey =\n  function exportPublicKey(object, encoding) {\n    return binding.certExportPublicKey(toBuf(object, encoding));\n  };\n\n\nCertificate.prototype.exportChallenge =\n  function exportChallenge(object, encoding) {\n    return binding.certExportChallenge(toBuf(object, encoding));\n  };\n\n\nexports.setEngine = function setEngine(id, flags) {\n  if (typeof id !== 'string')\n    throw new TypeError('\"id\" argument should be a string');\n\n  if (flags && typeof flags !== 'number')\n    throw new TypeError('\"flags\" argument should be a number, if present');\n  flags = flags >>> 0;\n\n  // Use provided engine for everything by default\n  if (flags === 0)\n    flags = constants.ENGINE_METHOD_ALL;\n\n  return binding.setEngine(id, flags);\n};\n\nconst kMaxUint32 = Math.pow(2, 32) - 1;\n\nfunction randomFillSync(buf, offset = 0, size) {\n  if (!isUint8Array(buf)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n  }\n\n  assertOffset(offset, buf.length);\n\n  if (size === undefined) size = buf.length - offset;\n\n  assertSize(size, offset, buf.length);\n\n  return binding.randomFill(buf, offset, size);\n}\nexports.randomFillSync = randomFillSync;\n\nfunction randomFill(buf, offset, size, cb) {\n  if (!isUint8Array(buf)) {\n    throw new TypeError('\"buf\" argument must be a Buffer or Uint8Array');\n  }\n\n  if (typeof offset === 'function') {\n    cb = offset;\n    offset = 0;\n    size = buf.length;\n  } else if (typeof size === 'function') {\n    cb = size;\n    size = buf.length - offset;\n  } else if (typeof cb !== 'function') {\n    throw new TypeError('\"cb\" argument must be a function');\n  }\n\n  assertOffset(offset, buf.length);\n  assertSize(size, offset, buf.length);\n\n  return binding.randomFill(buf, offset, size, cb);\n}\nexports.randomFill = randomFill;\n\nfunction assertOffset(offset, length) {\n  if (typeof offset !== 'number' || offset !== offset) {\n    throw new TypeError('offset must be a number');\n  }\n\n  if (offset > kMaxUint32 || offset < 0) {\n    throw new TypeError('offset must be a uint32');\n  }\n\n  if (offset > kBufferMaxLength || offset > length) {\n    throw new RangeError('offset out of range');\n  }\n}\n\nfunction assertSize(size, offset, length) {\n  if (typeof size !== 'number' || size !== size) {\n    throw new TypeError('size must be a number');\n  }\n\n  if (size > kMaxUint32 || size < 0) {\n    throw new TypeError('size must be a uint32');\n  }\n\n  if (size + offset > length || size > kBufferMaxLength) {\n    throw new RangeError('buffer too small');\n  }\n}\n\nexports.randomBytes = exports.pseudoRandomBytes = randomBytes;\n\nexports.rng = exports.prng = randomBytes;\n\nexports.getCiphers = internalUtil.cachedResult(\n  () => internalUtil.filterDuplicateStrings(getCiphers())\n);\n\nexports.getHashes = internalUtil.cachedResult(\n  () => internalUtil.filterDuplicateStrings(getHashes())\n);\n\nexports.getCurves = internalUtil.cachedResult(\n  () => internalUtil.filterDuplicateStrings(getCurves())\n);\n\nObject.defineProperty(exports, 'fips', {\n  get: getFipsCrypto,\n  set: setFipsCrypto\n});\n\nexports.timingSafeEqual = timingSafeEqual;\n\n// Legacy API\nObject.defineProperty(exports, 'createCredentials', {\n  configurable: true,\n  enumerable: true,\n  get: internalUtil.deprecate(function() {\n    return require('tls').createSecureContext;\n  }, 'crypto.createCredentials is deprecated. ' +\n     'Use tls.createSecureContext instead.', 'DEP0010')\n});\n\nObject.defineProperty(exports, 'Credentials', {\n  configurable: true,\n  enumerable: true,\n  get: internalUtil.deprecate(function() {\n    return require('tls').SecureContext;\n  }, 'crypto.Credentials is deprecated. ' +\n     'Use tls.SecureContext instead.', 'DEP0011')\n});\n",
  "cluster": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = ('NODE_UNIQUE_ID' in process.env) ?\n                  require('internal/cluster/child') :\n                  require('internal/cluster/master');\n",
  "dgram": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst assert = require('assert');\nconst errors = require('internal/errors');\nconst Buffer = require('buffer').Buffer;\nconst util = require('util');\nconst EventEmitter = require('events');\nconst setInitTriggerId = require('async_hooks').setInitTriggerId;\nconst UV_UDP_REUSEADDR = process.binding('constants').os.UV_UDP_REUSEADDR;\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst nextTick = require('internal/process/next_tick').nextTick;\n\nconst UDP = process.binding('udp_wrap').UDP;\nconst SendWrap = process.binding('udp_wrap').SendWrap;\nconst { isUint8Array } = process.binding('util');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\n// lazily loaded\nvar cluster = null;\nvar dns = null;\n\nconst errnoException = util._errnoException;\nconst exceptionWithHostPort = util._exceptionWithHostPort;\n\nfunction lookup(address, family, callback) {\n  if (!dns)\n    dns = require('dns');\n\n  return dns.lookup(address, family, callback);\n}\n\n\nfunction lookup4(address, callback) {\n  return lookup(address || '127.0.0.1', 4, callback);\n}\n\n\nfunction lookup6(address, callback) {\n  return lookup(address || '::1', 6, callback);\n}\n\n\nfunction newHandle(type) {\n  if (type === 'udp4') {\n    const handle = new UDP();\n    handle.lookup = lookup4;\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n    handle.lookup = lookup6;\n    handle.bind = handle.bind6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new errors.Error('ERR_SOCKET_BAD_TYPE');\n}\n\n\nfunction _createSocketHandle(address, port, addressType, fd, flags) {\n  // Opening an existing fd is not supported for UDP handles.\n  assert(typeof fd !== 'number' || fd < 0);\n\n  var handle = newHandle(addressType);\n\n  if (port || address) {\n    var err = handle.bind(address, port || 0, flags);\n    if (err) {\n      handle.close();\n      return err;\n    }\n  }\n\n  return handle;\n}\n\n\nfunction Socket(type, listener) {\n  EventEmitter.call(this);\n\n  if (type !== null && typeof type === 'object') {\n    var options = type;\n    type = options.type;\n  }\n\n  var handle = newHandle(type);\n  handle.owner = this;\n\n  this._handle = handle;\n  this._receiving = false;\n  this._bindState = BIND_STATE_UNBOUND;\n  this[async_id_symbol] = this._handle.getAsyncId();\n  this.type = type;\n  this.fd = null; // compatibility hack\n\n  // If true - UV_UDP_REUSEADDR flag will be set\n  this._reuseAddr = options && options.reuseAddr;\n\n  if (typeof listener === 'function')\n    this.on('message', listener);\n}\nutil.inherits(Socket, EventEmitter);\n\n\nfunction createSocket(type, listener) {\n  return new Socket(type, listener);\n}\n\n\nfunction startListening(socket) {\n  socket._handle.onmessage = onMessage;\n  // Todo: handle errors\n  socket._handle.recvStart();\n  socket._receiving = true;\n  socket._bindState = BIND_STATE_BOUND;\n  socket.fd = -42; // compatibility hack\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self, newHandle) {\n\n  // Set up the handle that we got from master.\n  newHandle.lookup = self._handle.lookup;\n  newHandle.bind = self._handle.bind;\n  newHandle.send = self._handle.send;\n  newHandle.owner = self;\n\n  // Replace the existing handle by the handle we got from master.\n  self._handle.close();\n  self._handle = newHandle;\n}\n\nSocket.prototype.bind = function(port_, address_ /*, callback*/) {\n  let port = port_;\n\n  this._healthCheck();\n\n  if (this._bindState !== BIND_STATE_UNBOUND)\n    throw new errors.Error('ERR_SOCKET_ALREADY_BOUND');\n\n  this._bindState = BIND_STATE_BINDING;\n\n  if (arguments.length && typeof arguments[arguments.length - 1] === 'function')\n    this.once('listening', arguments[arguments.length - 1]);\n\n  if (port instanceof UDP) {\n    replaceHandle(this, port);\n    startListening(this);\n    return this;\n  }\n\n  var address;\n  var exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // defaulting address for bind to all interfaces\n  if (!address && this._handle.lookup === lookup4) {\n    address = '0.0.0.0';\n  } else if (!address && this._handle.lookup === lookup6) {\n    address = '::';\n  }\n\n  // resolve address first\n  this._handle.lookup(address, (err, ip) => {\n    if (err) {\n      this._bindState = BIND_STATE_UNBOUND;\n      this.emit('error', err);\n      return;\n    }\n\n    if (!cluster)\n      cluster = require('cluster');\n\n    var flags = 0;\n    if (this._reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n\n    if (cluster.isWorker && !exclusive) {\n      const onHandle = (err, handle) => {\n        if (err) {\n          var ex = exceptionWithHostPort(err, 'bind', ip, port);\n          this.emit('error', ex);\n          this._bindState = BIND_STATE_UNBOUND;\n          return;\n        }\n\n        if (!this._handle)\n          // handle has been closed in the mean time.\n          return handle.close();\n\n        replaceHandle(this, handle);\n        startListening(this);\n      };\n      cluster._getServer(this, {\n        address: ip,\n        port: port,\n        addressType: this.type,\n        fd: -1,\n        flags: flags\n      }, onHandle);\n    } else {\n      if (!this._handle)\n        return; // handle has been closed in the mean time\n\n      const err = this._handle.bind(ip, port || 0, flags);\n      if (err) {\n        var ex = exceptionWithHostPort(err, 'bind', ip, port);\n        this.emit('error', ex);\n        this._bindState = BIND_STATE_UNBOUND;\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\n\n// thin wrapper around `send`, here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer,\n                                   offset,\n                                   length,\n                                   port,\n                                   address,\n                                   callback) {\n  if (typeof offset !== 'number') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'offset', 'number');\n  }\n\n  if (typeof length !== 'number') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'length', 'number');\n  }\n\n  if (typeof port !== 'number') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'port', 'number');\n  }\n\n  if (typeof address !== 'string') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'address', 'string');\n  }\n\n  this.send(buffer, offset, length, port, address, callback);\n};\n\n\nfunction sliceBuffer(buffer, offset, length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isUint8Array(buffer)) {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                               'buffer',\n                               ['Buffer', 'Uint8Array', 'string']);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n\n  return buffer.slice(offset, offset + length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (var i = 0, l = list.length; i < l; i++) {\n    var buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isUint8Array(buf))\n      return null;\n    else\n      newlist[i] = buf;\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self, toEnqueue) {\n  // If the send queue hasn't been initialized yet, do it, and install an\n  // event handler that flushes the send queue after binding is done.\n  if (!self._queue) {\n    self._queue = [];\n    self.once('error', onListenError);\n    self.once('listening', onListenSuccess);\n  }\n  self._queue.push(toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener('error', onListenError);\n  clearQueue.call(this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening', onListenSuccess);\n  this._queue = undefined;\n  this.emit('error', new errors.Error('ERR_SOCKET_CANNOT_SEND'));\n}\n\n\nfunction clearQueue() {\n  const queue = this._queue;\n  this._queue = undefined;\n\n  // Flush the send queue.\n  for (var i = 0; i < queue.length; i++)\n    queue[i]();\n}\n\n\n// valid combinations\n// send(buffer, offset, length, port, address, callback)\n// send(buffer, offset, length, port, address)\n// send(buffer, offset, length, port, callback)\n// send(buffer, offset, length, port)\n// send(bufferOrList, port, address, callback)\n// send(bufferOrList, port, address)\n// send(bufferOrList, port, callback)\n// send(bufferOrList, port)\nSocket.prototype.send = function(buffer,\n                                 offset,\n                                 length,\n                                 port,\n                                 address,\n                                 callback) {\n  let list;\n\n  if (address || (port && typeof port !== 'function')) {\n    buffer = sliceBuffer(buffer, offset, length);\n  } else {\n    callback = port;\n    port = offset;\n    address = length;\n  }\n\n  if (!Array.isArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isUint8Array(buffer)) {\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                                 'buffer',\n                                 ['Buffer', 'Uint8Array', 'string']);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                               'buffer list arguments',\n                               ['Buffer', 'string']);\n  }\n\n  port = port >>> 0;\n  if (port === 0 || port > 65535)\n    throw new errors.RangeError('ERR_SOCKET_BAD_PORT');\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address && typeof address !== 'string') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                               'address',\n                               ['string', 'falsy']);\n  }\n\n  this._healthCheck();\n\n  if (this._bindState === BIND_STATE_UNBOUND)\n    this.bind({port: 0, exclusive: true}, null);\n\n  if (list.length === 0)\n    list.push(Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet, push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (this._bindState !== BIND_STATE_BOUND) {\n    enqueue(this, this.send.bind(this, list, port, address, callback));\n    return;\n  }\n\n  const afterDns = (ex, ip) => {\n    doSend(ex, this, ip, list, address, port, callback);\n  };\n\n  this._handle.lookup(address, afterDns);\n};\n\n\nfunction doSend(ex, self, ip, list, address, port, callback) {\n  if (ex) {\n    if (typeof callback === 'function') {\n      callback(ex);\n      return;\n    }\n\n    self.emit('error', ex);\n    return;\n  } else if (!self._handle) {\n    return;\n  }\n\n  var req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n  // node::SendWrap isn't instantiated and attached to the JS instance of\n  // SendWrap above until send() is called. So don't set the init trigger id\n  // until now.\n  setInitTriggerId(self[async_id_symbol]);\n  var err = self._handle.send(req,\n                              list,\n                              list.length,\n                              port,\n                              ip,\n                              !!callback);\n  if (err && callback) {\n    // don't emit as error, dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err, 'send', address, port);\n    nextTick(self[async_id_symbol], callback, ex);\n  }\n}\n\nfunction afterSend(err, sent) {\n  if (err) {\n    err = exceptionWithHostPort(err, 'send', this.address, this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err, sent);\n}\n\nSocket.prototype.close = function(callback) {\n  if (typeof callback === 'function')\n    this.on('close', callback);\n\n  if (this._queue) {\n    this._queue.push(this.close.bind(this));\n    return this;\n  }\n\n  this._healthCheck();\n  this._stopReceiving();\n  this._handle.close();\n  this._handle = null;\n  nextTick(this[async_id_symbol], socketCloseNT, this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  this._healthCheck();\n\n  var out = {};\n  var err = this._handle.getsockname(out);\n  if (err) {\n    throw errnoException(err, 'getsockname');\n  }\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  var err = this._handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(arg) {\n  if (typeof arg !== 'number') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                               'arg',\n                               'number');\n  }\n\n  var err = this._handle.setTTL(arg);\n  if (err) {\n    throw errnoException(err, 'setTTL');\n  }\n\n  return arg;\n};\n\n\nSocket.prototype.setMulticastTTL = function(arg) {\n  if (typeof arg !== 'number') {\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                               'arg',\n                               'number');\n  }\n\n  var err = this._handle.setMulticastTTL(arg);\n  if (err) {\n    throw errnoException(err, 'setMulticastTTL');\n  }\n\n  return arg;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  var err = this._handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.addMembership = function(multicastAddress,\n                                          interfaceAddress) {\n  this._healthCheck();\n\n  if (!multicastAddress) {\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'multicastAddress');\n  }\n\n  var err = this._handle.addMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress,\n                                           interfaceAddress) {\n  this._healthCheck();\n\n  if (!multicastAddress) {\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'multicastAddress');\n  }\n\n  var err = this._handle.dropMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw errnoException(err, 'dropMembership');\n  }\n};\n\n\nSocket.prototype._healthCheck = function() {\n  if (!this._handle) {\n    // Error message from dgram_legacy.js.\n    throw new errors.Error('ERR_SOCKET_DGRAM_NOT_RUNNING');\n  }\n};\n\n\nSocket.prototype._stopReceiving = function() {\n  if (!this._receiving)\n    return;\n\n  this._handle.recvStop();\n  this._receiving = false;\n  this.fd = null; // compatibility hack\n};\n\n\nfunction onMessage(nread, handle, buf, rinfo) {\n  var self = handle.owner;\n  if (nread < 0) {\n    return self.emit('error', errnoException(nread, 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message', buf, rinfo);\n}\n\n\nSocket.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nmodule.exports = {\n  _createSocketHandle,\n  createSocket,\n  Socket\n};\n",
  "dns": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\n\nconst cares = process.binding('cares_wrap');\nconst uv = process.binding('uv');\nconst internalNet = require('internal/net');\nconst { customPromisifyArgs } = require('internal/util');\n\nconst GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;\nconst GetNameInfoReqWrap = cares.GetNameInfoReqWrap;\nconst QueryReqWrap = cares.QueryReqWrap;\n\nconst isIP = cares.isIP;\nconst isLegalPort = internalNet.isLegalPort;\n\n\nfunction errnoException(err, syscall, hostname) {\n  // FIXME(bnoordhuis) Remove this backwards compatibility nonsense and pass\n  // the true error to the user. ENOTFOUND is not even a proper POSIX error!\n  if (err === uv.UV_EAI_MEMORY ||\n      err === uv.UV_EAI_NODATA ||\n      err === uv.UV_EAI_NONAME) {\n    err = 'ENOTFOUND';\n  }\n  var ex = null;\n  if (typeof err === 'string') {  // c-ares error code.\n    const errHost = hostname ? ' ' + hostname : '';\n    ex = new Error(`${syscall} ${err}${errHost}`);\n    ex.code = err;\n    ex.errno = err;\n    ex.syscall = syscall;\n  } else {\n    ex = util._errnoException(err, syscall);\n  }\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n  return ex;\n}\n\n\n// c-ares invokes a callback either synchronously or asynchronously,\n// but the dns API should always invoke a callback asynchronously.\n//\n// This function makes sure that the callback is invoked asynchronously.\n// It returns a function that invokes the callback within nextTick().\n//\n// To avoid invoking unnecessary nextTick(), `immediately` property of\n// returned function should be set to true after c-ares returned.\n//\n// Usage:\n//\n// function someAPI(callback) {\n//   callback = makeAsync(callback);\n//   channel.someAPI(..., callback);\n//   callback.immediately = true;\n// }\nfunction makeAsync(callback) {\n  return function asyncCallback(...args) {\n    if (asyncCallback.immediately) {\n      // The API already returned, we can invoke the callback immediately.\n      callback.apply(null, args);\n    } else {\n      args.unshift(callback);\n      process.nextTick.apply(null, args);\n    }\n  };\n}\n\n\nfunction onlookup(err, addresses) {\n  if (err) {\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\n  }\n  if (this.family) {\n    this.callback(null, addresses[0], this.family);\n  } else {\n    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);\n  }\n}\n\n\nfunction onlookupall(err, addresses) {\n  var results = [];\n  if (err) {\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\n  }\n\n  for (var i = 0; i < addresses.length; i++) {\n    results.push({\n      address: addresses[i],\n      family: this.family || (addresses[i].indexOf(':') >= 0 ? 6 : 4)\n    });\n  }\n\n  this.callback(null, results);\n}\n\n\n// Easy DNS A/AAAA look up\n// lookup(hostname, [options,] callback)\nfunction lookup(hostname, options, callback) {\n  var hints = 0;\n  var family = -1;\n  var all = false;\n\n  // Parse arguments\n  if (hostname && typeof hostname !== 'string') {\n    throw new TypeError('Invalid arguments: ' +\n                        'hostname must be a string or falsey');\n  } else if (typeof options === 'function') {\n    callback = options;\n    family = 0;\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('Invalid arguments: callback must be passed');\n  } else if (options !== null && typeof options === 'object') {\n    hints = options.hints >>> 0;\n    family = options.family >>> 0;\n    all = options.all === true;\n\n    if (hints !== 0 &&\n        hints !== cares.AI_ADDRCONFIG &&\n        hints !== cares.AI_V4MAPPED &&\n        hints !== (cares.AI_ADDRCONFIG | cares.AI_V4MAPPED)) {\n      throw new TypeError('Invalid argument: hints must use valid flags');\n    }\n  } else {\n    family = options >>> 0;\n  }\n\n  if (family !== 0 && family !== 4 && family !== 6)\n    throw new TypeError('Invalid argument: family must be 4 or 6');\n\n  callback = makeAsync(callback);\n\n  if (!hostname) {\n    if (all) {\n      callback(null, []);\n    } else {\n      callback(null, null, family === 6 ? 6 : 4);\n    }\n    return {};\n  }\n\n  var matchedFamily = isIP(hostname);\n  if (matchedFamily) {\n    if (all) {\n      callback(null, [{address: hostname, family: matchedFamily}]);\n    } else {\n      callback(null, hostname, matchedFamily);\n    }\n    return {};\n  }\n\n  var req = new GetAddrInfoReqWrap();\n  req.callback = callback;\n  req.family = family;\n  req.hostname = hostname;\n  req.oncomplete = all ? onlookupall : onlookup;\n\n  var err = cares.getaddrinfo(req, hostname, family, hints);\n  if (err) {\n    callback(errnoException(err, 'getaddrinfo', hostname));\n    return {};\n  }\n\n  callback.immediately = true;\n  return req;\n}\n\nObject.defineProperty(lookup, customPromisifyArgs,\n                      { value: ['address', 'family'], enumerable: false });\n\n\nfunction onlookupservice(err, host, service) {\n  if (err)\n    return this.callback(errnoException(err, 'getnameinfo', this.host));\n\n  this.callback(null, host, service);\n}\n\n\n// lookupService(address, port, callback)\nfunction lookupService(host, port, callback) {\n  if (arguments.length !== 3)\n    throw new Error('Invalid arguments');\n\n  if (isIP(host) === 0)\n    throw new TypeError('\"host\" argument needs to be a valid IP address');\n\n  if (!isLegalPort(port))\n    throw new TypeError(`\"port\" should be >= 0 and < 65536, got \"${port}\"`);\n\n  if (typeof callback !== 'function')\n    throw new TypeError('\"callback\" argument must be a function');\n\n  port = +port;\n  callback = makeAsync(callback);\n\n  var req = new GetNameInfoReqWrap();\n  req.callback = callback;\n  req.host = host;\n  req.port = port;\n  req.oncomplete = onlookupservice;\n\n  var err = cares.getnameinfo(req, host, port);\n  if (err) throw errnoException(err, 'getnameinfo', host);\n\n  callback.immediately = true;\n  return req;\n}\n\nObject.defineProperty(lookupService, customPromisifyArgs,\n                      { value: ['hostname', 'service'], enumerable: false });\n\n\nfunction onresolve(err, result, ttls) {\n  if (ttls && this.ttl)\n    result = result.map((address, index) => ({ address, ttl: ttls[index] }));\n\n  if (err)\n    this.callback(errnoException(err, this.bindingName, this.hostname));\n  else\n    this.callback(null, result);\n}\n\n\nfunction resolver(bindingName) {\n  var binding = cares[bindingName];\n\n  return function query(name, /* options, */ callback) {\n    var options;\n    if (arguments.length > 2) {\n      options = callback;\n      callback = arguments[2];\n    }\n\n    if (typeof name !== 'string') {\n      throw new Error('\"name\" argument must be a string');\n    } else if (typeof callback !== 'function') {\n      throw new Error('\"callback\" argument must be a function');\n    }\n\n    callback = makeAsync(callback);\n    var req = new QueryReqWrap();\n    req.bindingName = bindingName;\n    req.callback = callback;\n    req.hostname = name;\n    req.oncomplete = onresolve;\n    req.ttl = !!(options && options.ttl);\n    var err = binding(req, name);\n    if (err) throw errnoException(err, bindingName);\n    callback.immediately = true;\n    return req;\n  };\n}\n\n\nvar resolveMap = Object.create(null);\nresolveMap.A = resolver('queryA');\nresolveMap.AAAA = resolver('queryAaaa');\nresolveMap.CNAME = resolver('queryCname');\nresolveMap.MX = resolver('queryMx');\nresolveMap.NS = resolver('queryNs');\nresolveMap.TXT = resolver('queryTxt');\nresolveMap.SRV = resolver('querySrv');\nresolveMap.PTR = resolver('queryPtr');\nresolveMap.NAPTR = resolver('queryNaptr');\nresolveMap.SOA = resolver('querySoa');\n\n\nfunction resolve(hostname, type_, callback_) {\n  var resolver, callback;\n  if (typeof type_ === 'string') {\n    resolver = resolveMap[type_];\n    callback = callback_;\n  } else if (typeof type_ === 'function') {\n    resolver = resolveMap.A;\n    callback = type_;\n  } else {\n    throw new Error('\"type\" argument must be a string');\n  }\n\n  if (typeof resolver === 'function') {\n    return resolver(hostname, callback);\n  } else {\n    throw new Error(`Unknown type \"${type_}\"`);\n  }\n}\n\n\nfunction getServers() {\n  return cares.getServers();\n}\n\n\nfunction setServers(servers) {\n  // cache the original servers because in the event of an error setting the\n  // servers cares won't have any servers available for resolution\n  const orig = cares.getServers();\n  const newSet = [];\n\n  servers.forEach((serv) => {\n    var ipVersion = isIP(serv);\n    if (ipVersion !== 0)\n      return newSet.push([ipVersion, serv]);\n\n    const match = serv.match(/\\[(.*)\\](?::\\d+)?/);\n    // we have an IPv6 in brackets\n    if (match) {\n      ipVersion = isIP(match[1]);\n      if (ipVersion !== 0)\n        return newSet.push([ipVersion, match[1]]);\n    }\n\n    const s = serv.split(/:\\d+$/)[0];\n    ipVersion = isIP(s);\n\n    if (ipVersion !== 0)\n      return newSet.push([ipVersion, s]);\n\n    throw new Error(`IP address is not properly formatted: ${serv}`);\n  });\n\n  const errorNumber = cares.setServers(newSet);\n\n  if (errorNumber !== 0) {\n    // reset the servers to the old servers, because ares probably unset them\n    cares.setServers(orig.join(','));\n\n    var err = cares.strerror(errorNumber);\n    throw new Error(`c-ares failed to set servers: \"${err}\" [${servers}]`);\n  }\n}\n\nmodule.exports = {\n  lookup,\n  lookupService,\n  getServers,\n  setServers,\n  resolve,\n  resolve4: resolveMap.A,\n  resolve6: resolveMap.AAAA,\n  resolveCname: resolveMap.CNAME,\n  resolveMx: resolveMap.MX,\n  resolveNs: resolveMap.NS,\n  resolveTxt: resolveMap.TXT,\n  resolveSrv: resolveMap.SRV,\n  resolvePtr: resolveMap.PTR,\n  resolveNaptr: resolveMap.NAPTR,\n  resolveSoa: resolveMap.SOA,\n  reverse: resolver('getHostByAddr'),\n\n  // uv_getaddrinfo flags\n  ADDRCONFIG: cares.AI_ADDRCONFIG,\n  V4MAPPED: cares.AI_V4MAPPED,\n\n  // ERROR CODES\n  NODATA: 'ENODATA',\n  FORMERR: 'EFORMERR',\n  SERVFAIL: 'ESERVFAIL',\n  NOTFOUND: 'ENOTFOUND',\n  NOTIMP: 'ENOTIMP',\n  REFUSED: 'EREFUSED',\n  BADQUERY: 'EBADQUERY',\n  BADNAME: 'EBADNAME',\n  BADFAMILY: 'EBADFAMILY',\n  BADRESP: 'EBADRESP',\n  CONNREFUSED: 'ECONNREFUSED',\n  TIMEOUT: 'ETIMEOUT',\n  EOF: 'EOF',\n  FILE: 'EFILE',\n  NOMEM: 'ENOMEM',\n  DESTRUCTION: 'EDESTRUCTION',\n  BADSTR: 'EBADSTR',\n  BADFLAGS: 'EBADFLAGS',\n  NONAME: 'ENONAME',\n  BADHINTS: 'EBADHINTS',\n  NOTINITIALIZED: 'ENOTINITIALIZED',\n  LOADIPHLPAPI: 'ELOADIPHLPAPI',\n  ADDRGETNETWORKPARAMS: 'EADDRGETNETWORKPARAMS',\n  CANCELLED: 'ECANCELLED'\n};\n",
  "domain": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// WARNING: THIS MODULE IS PENDING DEPRECATION.\n//\n// No new pull requests targeting this module will be accepted\n// unless they address existing, critical bugs.\n\nconst util = require('util');\nconst EventEmitter = require('events');\nconst inherits = util.inherits;\n\n// communicate with events module, but don't require that\n// module to have to load this one, since this module has\n// a few side effects.\nEventEmitter.usingDomains = true;\n\n// overwrite process.domain with a getter/setter that will allow for more\n// effective optimizations\nvar _domain = [null];\nObject.defineProperty(process, 'domain', {\n  enumerable: true,\n  get: function() {\n    return _domain[0];\n  },\n  set: function(arg) {\n    return _domain[0] = arg;\n  }\n});\n\n// It's possible to enter one domain while already inside\n// another one. The stack is each entered domain.\nconst stack = [];\nexports._stack = stack;\n\n// let the process know we're using domains\nconst _domain_flag = process._setupDomainUse(_domain, stack);\n\nexports.Domain = Domain;\n\nexports.create = exports.createDomain = function() {\n  return new Domain();\n};\n\n// the active domain is always the one that we're currently in.\nexports.active = null;\n\n\ninherits(Domain, EventEmitter);\n\nfunction Domain() {\n  EventEmitter.call(this);\n\n  this.members = [];\n}\n\nDomain.prototype.members = undefined;\nDomain.prototype._disposed = undefined;\n\n\n// Called by process._fatalException in case an error was thrown.\nDomain.prototype._errorHandler = function _errorHandler(er) {\n  var caught = false;\n\n  // ignore errors on disposed domains.\n  //\n  // XXX This is a bit stupid.  We should probably get rid of\n  // domain.dispose() altogether.  It's almost always a terrible\n  // idea.  --isaacs\n  if (this._disposed)\n    return true;\n\n  if (!util.isPrimitive(er)) {\n    er.domain = this;\n    er.domainThrown = true;\n  }\n\n  // The top-level domain-handler is handled separately.\n  //\n  // The reason is that if V8 was passed a command line option\n  // asking it to abort on an uncaught exception (currently\n  // \"--abort-on-uncaught-exception\"), we want an uncaught exception\n  // in the top-level domain error handler to make the\n  // process abort. Using try/catch here would always make V8 think\n  // that these exceptions are caught, and thus would prevent it from\n  // aborting in these cases.\n  if (stack.length === 1) {\n    // If there's no error handler, do not emit an 'error' event\n    // as this would throw an error, make the process exit, and thus\n    // prevent the process 'uncaughtException' event from being emitted\n    // if a listener is set.\n    if (EventEmitter.listenerCount(this, 'error') > 0) {\n      try {\n        // Set the _emittingTopLevelDomainError so that we know that, even\n        // if technically the top-level domain is still active, it would\n        // be ok to abort on an uncaught exception at this point\n        process._emittingTopLevelDomainError = true;\n        caught = this.emit('error', er);\n      } finally {\n        process._emittingTopLevelDomainError = false;\n      }\n    }\n  } else {\n    // wrap this in a try/catch so we don't get infinite throwing\n    try {\n      // One of three things will happen here.\n      //\n      // 1. There is a handler, caught = true\n      // 2. There is no handler, caught = false\n      // 3. It throws, caught = false\n      //\n      // If caught is false after this, then there's no need to exit()\n      // the domain, because we're going to crash the process anyway.\n      caught = this.emit('error', er);\n    } catch (er2) {\n      // The domain error handler threw!  oh no!\n      // See if another domain can catch THIS error,\n      // or else crash on the original one.\n      // If the user already exited it, then don't double-exit.\n      if (this === exports.active) {\n        stack.pop();\n      }\n      if (stack.length) {\n        exports.active = process.domain = stack[stack.length - 1];\n        caught = process._fatalException(er2);\n      } else {\n        caught = false;\n      }\n    }\n  }\n\n  // Exit all domains on the stack.  Uncaught exceptions end the\n  // current tick and no domains should be left on the stack\n  // between ticks.\n  stack.length = 0;\n  exports.active = process.domain = null;\n\n  return caught;\n};\n\n\nDomain.prototype.enter = function() {\n  if (this._disposed) return;\n\n  // note that this might be a no-op, but we still need\n  // to push it onto the stack so that we can pop it later.\n  exports.active = process.domain = this;\n  stack.push(this);\n  _domain_flag[0] = stack.length;\n};\n\n\nDomain.prototype.exit = function() {\n  // skip disposed domains, as usual, but also don't do anything if this\n  // domain is not on the stack.\n  var index = stack.lastIndexOf(this);\n  if (this._disposed || index === -1) return;\n\n  // exit all domains until this one.\n  stack.splice(index);\n  _domain_flag[0] = stack.length;\n\n  exports.active = stack[stack.length - 1];\n  process.domain = exports.active;\n};\n\n\n// note: this works for timers as well.\nDomain.prototype.add = function(ee) {\n  // If the domain is disposed or already added, then nothing left to do.\n  if (this._disposed || ee.domain === this)\n    return;\n\n  // has a domain already - remove it first.\n  if (ee.domain)\n    ee.domain.remove(ee);\n\n  // check for circular Domain->Domain links.\n  // This causes bad insanity!\n  //\n  // For example:\n  // var d = domain.create();\n  // var e = domain.create();\n  // d.add(e);\n  // e.add(d);\n  // e.emit('error', er); // RangeError, stack overflow!\n  if (this.domain && (ee instanceof Domain)) {\n    for (var d = this.domain; d; d = d.domain) {\n      if (ee === d) return;\n    }\n  }\n\n  ee.domain = this;\n  this.members.push(ee);\n};\n\n\nDomain.prototype.remove = function(ee) {\n  ee.domain = null;\n  var index = this.members.indexOf(ee);\n  if (index !== -1)\n    this.members.splice(index, 1);\n};\n\n\nDomain.prototype.run = function(fn) {\n  if (this._disposed)\n    return;\n\n  var ret;\n\n  this.enter();\n  if (arguments.length >= 2) {\n    var len = arguments.length;\n    var args = new Array(len - 1);\n\n    for (var i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    ret = fn.apply(this, args);\n  } else {\n    ret = fn.call(this);\n  }\n  this.exit();\n\n  return ret;\n};\n\n\nfunction intercepted(_this, self, cb, fnargs) {\n  if (self._disposed)\n    return;\n\n  if (fnargs[0] && fnargs[0] instanceof Error) {\n    var er = fnargs[0];\n    util._extend(er, {\n      domainBound: cb,\n      domainThrown: false,\n      domain: self\n    });\n    self.emit('error', er);\n    return;\n  }\n\n  var args = [];\n  var i, ret;\n\n  self.enter();\n  if (fnargs.length > 1) {\n    for (i = 1; i < fnargs.length; i++)\n      args.push(fnargs[i]);\n    ret = cb.apply(_this, args);\n  } else {\n    ret = cb.call(_this);\n  }\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.intercept = function(cb) {\n  var self = this;\n\n  function runIntercepted() {\n    return intercepted(this, self, cb, arguments);\n  }\n\n  return runIntercepted;\n};\n\n\nfunction bound(_this, self, cb, fnargs) {\n  if (self._disposed)\n    return;\n\n  var ret;\n\n  self.enter();\n  if (fnargs.length > 0)\n    ret = cb.apply(_this, fnargs);\n  else\n    ret = cb.call(_this);\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.bind = function(cb) {\n  var self = this;\n\n  function runBound() {\n    return bound(this, self, cb, arguments);\n  }\n\n  runBound.domain = this;\n\n  return runBound;\n};\n\n\nDomain.prototype.dispose = util.deprecate(function() {\n  if (this._disposed) return;\n\n  // if we're the active domain, then get out now.\n  this.exit();\n\n  // remove from parent domain, if there is one.\n  if (this.domain) this.domain.remove(this);\n\n  // kill the references so that they can be properly gc'ed.\n  this.members.length = 0;\n\n  // mark this domain as 'no longer relevant'\n  // so that it can't be entered or activated.\n  this._disposed = true;\n}, 'Domain.dispose is deprecated. Recover from failed I/O actions explicitly ' +\n    'via error event handlers set on the domain instead.', 'DEP0012');\n",
  "events": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar domain;\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    // force global console to be compiled.\n    // see https://github.com/nodejs/node/issues/4467\n    console;\n    // check whether the input is a positive number (whose value is zero or\n    // greater and not a NaN).\n    if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n      throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    domain = domain || require('domain');\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Unhandled \"error\" event');\n      if (typeof er === 'object' && er !== null) {\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n      }\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      const err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  if (domain && this !== process) {\n    domain.enter();\n    needDomainExit = true;\n  }\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        const w = new Error('Possible EventEmitter memory leak detected. ' +\n                            `${existing.length} ${String(type)} listeners ` +\n                            'added. Use emitter.setMaxListeners() to ' +\n                            'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        process.emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  this.target.removeListener(this.type, this.wrapFn);\n  if (!this.fired) {\n    this.fired = true;\n    this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target, type, listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  const ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n",
  "fs": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst constants = process.binding('constants').fs;\nconst { S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK } = constants;\nconst util = require('util');\nconst pathModule = require('path');\nconst { isUint8Array } = process.binding('util');\n\nconst binding = process.binding('fs');\nconst fs = exports;\nconst Buffer = require('buffer').Buffer;\nconst Stream = require('stream').Stream;\nconst EventEmitter = require('events');\nconst FSReqWrap = binding.FSReqWrap;\nconst FSEvent = process.binding('fs_event_wrap').FSEvent;\nconst internalFS = require('internal/fs');\nconst internalURL = require('internal/url');\nconst internalUtil = require('internal/util');\nconst assertEncoding = internalFS.assertEncoding;\nconst stringToFlags = internalFS.stringToFlags;\nconst getPathFromURL = internalURL.getPathFromURL;\n\nObject.defineProperty(exports, 'constants', {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n\nconst Readable = Stream.Readable;\nconst Writable = Stream.Writable;\n\nconst kMinPoolSpace = 128;\nconst kMaxLength = require('buffer').kMaxLength;\n\nconst isWindows = process.platform === 'win32';\n\nconst DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\nconst errnoException = util._errnoException;\n\nfunction getOptions(options, defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = util._extend({}, defaultOptions);\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new TypeError('\"options\" must be a string or an object, got ' +\n                        typeof options + ' instead.');\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n  return options;\n}\n\nfunction copyObject(source) {\n  var target = {};\n  for (var key in source)\n    target[key] = source[key];\n  return target;\n}\n\nfunction rethrow() {\n  // TODO(thefourtheye) Throw error instead of warning in major version > 7\n  process.emitWarning(\n    'Calling an asynchronous function without callback is deprecated.',\n    'DeprecationWarning', 'DEP0013', rethrow\n  );\n\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  if (DEBUG) {\n    var backtrace = new Error();\n    return function(err) {\n      if (err) {\n        backtrace.stack = err.name + ': ' + err.message +\n                          backtrace.stack.substr(backtrace.name.length);\n        throw backtrace;\n      }\n    };\n  }\n\n  return function(err) {\n    if (err) {\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n    }\n  };\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function() {\n    return cb.apply(null, arguments);\n  };\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function(err) {\n    if (err) return cb(err);\n    cb(err, statsFromValues());\n  };\n}\n\nfunction nullCheck(path, callback) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    var er = new Error('Path must be a string without null bytes');\n    er.code = 'ENOENT';\n    if (typeof callback !== 'function')\n      throw er;\n    process.nextTick(callback, er);\n    return false;\n  }\n  return true;\n}\n\nfunction isFd(path) {\n  return (path >>> 0) === path;\n}\n\n// Constructor for file stats.\nfunction Stats(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n  this.atime = new Date(atim_msec + 0.5);\n  this.mtime = new Date(mtim_msec + 0.5);\n  this.ctime = new Date(ctim_msec + 0.5);\n  this.birthtime = new Date(birthtim_msec + 0.5);\n}\nfs.Stats = Stats;\n\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & S_IFMT) === property);\n};\n\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst statValues = binding.getStatValues();\n\nfunction statsFromValues() {\n  return new Stats(statValues[0], statValues[1], statValues[2], statValues[3],\n                   statValues[4], statValues[5],\n                   statValues[6] < 0 ? undefined : statValues[6], statValues[7],\n                   statValues[8], statValues[9] < 0 ? undefined : statValues[9],\n                   statValues[10], statValues[11], statValues[12],\n                   statValues[13]);\n}\n\n// Don't allow mode to accidentally be overwritten.\nObject.defineProperties(fs, {\n  F_OK: {enumerable: true, value: constants.F_OK || 0},\n  R_OK: {enumerable: true, value: constants.R_OK || 0},\n  W_OK: {enumerable: true, value: constants.W_OK || 0},\n  X_OK: {enumerable: true, value: constants.X_OK || 0},\n});\n\nfunction handleError(val, callback) {\n  if (val instanceof Error) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback, val);\n      return true;\n    } else throw val;\n  }\n  return false;\n}\n\nfs.access = function(path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = fs.F_OK;\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(path, callback))\n    return;\n\n  mode = mode | 0;\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.access(pathModule._makeLong(path), mode, req);\n};\n\nfs.accessSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n\n  if (mode === undefined)\n    mode = fs.F_OK;\n  else\n    mode = mode | 0;\n\n  binding.access(pathModule._makeLong(path), mode);\n};\n\nfs.exists = function(path, callback) {\n  if (handleError((path = getPathFromURL(path)), cb))\n    return;\n  if (!nullCheck(path, cb)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = cb;\n  binding.stat(pathModule._makeLong(path), req);\n  function cb(err) {\n    if (callback) callback(err ? false : true);\n  }\n};\n\nfs.existsSync = function(path) {\n  try {\n    handleError((path = getPathFromURL(path)));\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nfs.readFile = function(path, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { flag: 'r' });\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback))\n    return;\n\n  var context = new ReadFileContext(callback, options.encoding);\n  context.isUserFd = isFd(path); // file descriptor ownership\n  var req = new FSReqWrap();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n\n  if (context.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null, path);\n    });\n    return;\n  }\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(options.flag || 'r'),\n               0o666,\n               req);\n};\n\nconst kReadFileBufferLength = 8 * 1024;\n\nfunction ReadFileContext(callback, encoding) {\n  this.fd = undefined;\n  this.isUserFd = undefined;\n  this.size = undefined;\n  this.callback = callback;\n  this.buffers = null;\n  this.buffer = null;\n  this.pos = 0;\n  this.encoding = encoding;\n  this.err = null;\n}\n\nReadFileContext.prototype.read = function() {\n  var buffer;\n  var offset;\n  var length;\n\n  if (this.size === 0) {\n    buffer = this.buffer = Buffer.allocUnsafeSlow(kReadFileBufferLength);\n    offset = 0;\n    length = kReadFileBufferLength;\n  } else {\n    buffer = this.buffer;\n    offset = this.pos;\n    length = this.size - this.pos;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterRead;\n  req.context = this;\n\n  binding.read(this.fd, buffer, offset, length, -1, req);\n};\n\nReadFileContext.prototype.close = function(err) {\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterClose;\n  req.context = this;\n  this.err = err;\n\n  if (this.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null);\n    });\n    return;\n  }\n\n  binding.close(this.fd, req);\n};\n\nfunction readFileAfterOpen(err, fd) {\n  var context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd, req);\n}\n\nfunction readFileAfterStat(err) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if ((statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = context.size = statValues[8/*size*/];\n  else\n    size = context.size = 0;\n\n  if (size === 0) {\n    context.buffers = [];\n    context.read();\n    return;\n  }\n\n  if (size > kMaxLength) {\n    err = new RangeError('File size is greater than possible Buffer: ' +\n                         `0x${kMaxLength.toString(16)} bytes`);\n    return context.close(err);\n  }\n\n  context.buffer = Buffer.allocUnsafeSlow(size);\n  context.read();\n}\n\nfunction readFileAfterRead(err, bytesRead) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  if (bytesRead === 0)\n    return context.close();\n\n  context.pos += bytesRead;\n\n  if (context.size !== 0) {\n    if (context.pos === context.size)\n      context.close();\n    else\n      context.read();\n  } else {\n    // unknown size, just read until we don't get bytes.\n    context.buffers.push(context.buffer.slice(0, bytesRead));\n    context.read();\n  }\n}\n\nfunction readFileAfterClose(err) {\n  var context = this.context;\n  var buffer = null;\n  var callback = context.callback;\n\n  if (context.err || err)\n    return callback(context.err || err);\n\n  if (context.size === 0)\n    buffer = Buffer.concat(context.buffers, context.pos);\n  else if (context.pos < context.size)\n    buffer = context.buffer.slice(0, context.pos);\n  else\n    buffer = context.buffer;\n\n  if (context.encoding) {\n    return tryToString(buffer, context.encoding, callback);\n  }\n\n  callback(null, buffer);\n}\n\nfunction tryToString(buf, encoding, callback) {\n  try {\n    buf = buf.toString(encoding);\n  } catch (err) {\n    return callback(err);\n  }\n  callback(null, buf);\n}\n\nfunction tryStatSync(fd, isUserFd) {\n  var threw = true;\n  try {\n    binding.fstat(fd);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return !threw;\n}\n\nfunction tryCreateBuffer(size, fd, isUserFd) {\n  var threw = true;\n  var buffer;\n  try {\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd, isUserFd, buffer, pos, len) {\n  var threw = true;\n  var bytesRead;\n  try {\n    bytesRead = fs.readSync(fd, buffer, pos, len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\nfs.readFileSync = function(path, options) {\n  options = getOptions(options, { flag: 'r' });\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if (tryStatSync(fd, isUserFd) && (statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = statValues[8/*size*/];\n  else\n    size = 0;\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size, fd, isUserFd);\n  }\n\n  var bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // the kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);\n      if (bytesRead !== 0) {\n        buffers.push(buffer.slice(0, bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n};\n\n\n// Yes, the follow could be easily DRYed up but I provide the explicit\n// list to make the arguments clear.\n\nfs.close = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.close(fd, req);\n};\n\nfs.closeSync = function(fd) {\n  return binding.close(fd);\n};\n\nfunction modeNum(m, def) {\n  if (typeof m === 'number')\n    return m;\n  if (typeof m === 'string')\n    return parseInt(m, 8);\n  if (def)\n    return modeNum(def);\n  return undefined;\n}\n\nfs.open = function(path, flags, mode, callback_) {\n  var callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 0o666);\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               req);\n};\n\nfs.openSync = function(path, flags, mode) {\n  mode = modeNum(mode, 0o666);\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n};\n\nfs.read = function(fd, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    return process.nextTick(function() {\n      callback && callback(null, 0, buffer);\n    });\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  binding.read(fd, buffer, offset, length, position, req);\n};\n\nObject.defineProperty(fs.read, internalUtil.customPromisifyArgs,\n                      { value: ['bytesRead', 'buffer'], enumerable: false });\n\nfs.readSync = function(fd, buffer, offset, length, position) {\n  if (length === 0) {\n    return 0;\n  }\n\n  return binding.read(fd, buffer, offset, length, position);\n};\n\n// usage:\n//  fs.write(fd, buffer[, offset[, length[, position]]], callback);\n// OR\n//  fs.write(fd, string[, position[, encoding]], callback);\nfs.write = function(fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  if (isUint8Array(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (typeof offset !== 'number') {\n      offset = 0;\n    }\n    if (typeof length !== 'number') {\n      length = buffer.length - offset;\n    }\n    if (typeof position !== 'number') {\n      position = null;\n    }\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n  return binding.writeString(fd, buffer, offset, length, req);\n};\n\nObject.defineProperty(fs.write, internalUtil.customPromisifyArgs,\n                      { value: ['bytesWritten', 'buffer'], enumerable: false });\n\n// usage:\n//  fs.writeSync(fd, buffer[, offset[, length[, position]]]);\n// OR\n//  fs.writeSync(fd, string[, position[, encoding]]);\nfs.writeSync = function(fd, buffer, offset, length, position) {\n  if (isUint8Array(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (typeof offset !== 'number')\n      offset = 0;\n    if (typeof length !== 'number')\n      length = buffer.length - offset;\n    return binding.writeBuffer(fd, buffer, offset, length, position);\n  }\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (offset === undefined)\n    offset = null;\n  return binding.writeString(fd, buffer, offset, length, position);\n};\n\nfs.rename = function(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (handleError((oldPath = getPathFromURL(oldPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 req);\n};\n\nfs.renameSync = function(oldPath, newPath) {\n  handleError((oldPath = getPathFromURL(oldPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n};\n\nfs.truncate = function(path, len, callback) {\n  if (typeof path === 'number') {\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    var req = new FSReqWrap();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n};\n\nfs.truncateSync = function(path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  var ret;\n\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n};\n\nfs.ftruncate = function(fd, len, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.ftruncate(fd, len, req);\n};\n\nfs.ftruncateSync = function(fd, len) {\n  if (len === undefined) {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n};\n\nfs.rmdir = function(path, callback) {\n  callback = maybeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rmdir(pathModule._makeLong(path), req);\n};\n\nfs.rmdirSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n};\n\nfs.fdatasync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n};\n\nfs.fdatasyncSync = function(fd) {\n  return binding.fdatasync(fd);\n};\n\nfs.fsync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n};\n\nfs.fsyncSync = function(fd) {\n  return binding.fsync(fd);\n};\n\nfs.mkdir = function(path, mode, callback) {\n  if (typeof mode === 'function') callback = mode;\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 0o777),\n                req);\n};\n\nfs.mkdirSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 0o777));\n};\n\nfs.readdir = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readdir(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readdirSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path), options.encoding);\n};\n\nfs.fstat = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeStatsCallback(callback);\n  binding.fstat(fd, req);\n};\n\nfs.lstat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.lstat(pathModule._makeLong(path), req);\n};\n\nfs.stat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.stat(pathModule._makeLong(path), req);\n};\n\nfs.fstatSync = function(fd) {\n  binding.fstat(fd);\n  return statsFromValues();\n};\n\nfs.lstatSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.lstat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.statSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.stat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.readlink = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readlink(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readlinkSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path), options.encoding);\n};\n\nfunction preprocessSymlinkDestination(path, type, linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  } else if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath, '..', path);\n    return pathModule._makeLong(path);\n  } else {\n    // Windows symlinks don't tolerate forward slashes.\n    return ('' + path).replace(/\\//g, '\\\\');\n  }\n}\n\nfs.symlink = function(target, path, type_, callback_) {\n  var type = (typeof type_ === 'string' ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (handleError((target = getPathFromURL(target)), callback))\n    return;\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(target, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\n                  pathModule._makeLong(path),\n                  type,\n                  req);\n};\n\nfs.symlinkSync = function(target, path, type) {\n  type = (typeof type === 'string' ? type : null);\n  handleError((target = getPathFromURL(target)));\n  handleError((path = getPathFromURL(path)));\n  nullCheck(target);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n                         pathModule._makeLong(path),\n                         type);\n};\n\nfs.link = function(existingPath, newPath, callback) {\n  callback = makeCallback(callback);\n\n  if (handleError((existingPath = getPathFromURL(existingPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(existingPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.link(pathModule._makeLong(existingPath),\n               pathModule._makeLong(newPath),\n               req);\n};\n\nfs.linkSync = function(existingPath, newPath) {\n  handleError((existingPath = getPathFromURL(existingPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(existingPath);\n  nullCheck(newPath);\n  return binding.link(pathModule._makeLong(existingPath),\n                      pathModule._makeLong(newPath));\n};\n\nfs.unlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.unlink(pathModule._makeLong(path), req);\n};\n\nfs.unlinkSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n};\n\nfs.fchmod = function(fd, mode, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchmod(fd, modeNum(mode), req);\n};\n\nfs.fchmodSync = function(fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchmod = function(path, mode, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function(err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2);\n        });\n      });\n    });\n  };\n\n  fs.lchmodSync = function(path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2, ret;\n    try {\n      ret = fs.fchmodSync(fd, mode);\n    } catch (er) {\n      err = er;\n    }\n    try {\n      fs.closeSync(fd);\n    } catch (er) {\n      err2 = er;\n    }\n    if (err || err2) throw (err || err2);\n    return ret;\n  };\n}\n\n\nfs.chmod = function(path, mode, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                req);\n};\n\nfs.chmodSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchown = function(path, uid, gid, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fs.fchown(fd, uid, gid, callback);\n    });\n  };\n\n  fs.lchownSync = function(path, uid, gid) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n    return fs.fchownSync(fd, uid, gid);\n  };\n}\n\nfs.fchown = function(fd, uid, gid, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchown(fd, uid, gid, req);\n};\n\nfs.fchownSync = function(fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n};\n\nfs.chown = function(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\n};\n\nfs.chownSync = function(path, uid, gid) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n};\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (Number.isFinite(time)) {\n    if (time < 0) {\n      return Date.now() / 1000;\n    }\n    return time;\n  }\n  if (util.isDate(time)) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}\n\n// exported for unit tests, not for public consumption\nfs._toUnixTimestamp = toUnixTimestamp;\n\nfs.utimes = function(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 req);\n};\n\nfs.utimesSync = function(path, atime, mtime) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n};\n\nfs.futimes = function(fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.futimes(fd, atime, mtime, req);\n};\n\nfs.futimesSync = function(fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n};\n\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback) {\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd, function() {\n          callback(writeErr);\n        });\n      }\n    } else {\n      if (written === length) {\n        if (isUserFd) {\n          callback(null);\n        } else {\n          fs.close(fd, callback);\n        }\n      } else {\n        offset += written;\n        length -= written;\n        if (position !== null) {\n          position += written;\n        }\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\n      }\n    }\n  });\n}\n\nfs.writeFile = function(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (isFd(path)) {\n    writeFd(path, true);\n    return;\n  }\n\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      writeFd(fd, false);\n    }\n  });\n\n  function writeFd(fd, isUserFd) {\n    var buffer = isUint8Array(data) ?\n        data : Buffer.from('' + data, options.encoding || 'utf8');\n    var position = /a/.test(flag) ? null : 0;\n\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\n  }\n};\n\nfs.writeFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n\n  if (!isUint8Array(data)) {\n    data = Buffer.from('' + data, options.encoding || 'utf8');\n  }\n  var offset = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (length > 0) {\n      var written = fs.writeSync(fd, data, offset, length, position);\n      offset += written;\n      length -= written;\n      if (position !== null) {\n        position += written;\n      }\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n};\n\nfs.appendFile = function(path, data, options, callback) {\n  callback = maybeCallback(arguments[arguments.length - 1]);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path, data, options, callback);\n};\n\nfs.appendFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path, data, options);\n};\n\nfunction FSWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new FSEvent();\n  this._handle.owner = this;\n\n  this._handle.onchange = function(status, eventType, filename) {\n    if (status < 0) {\n      self._handle.close();\n      const error = !filename ?\n          errnoException(status, 'Error watching file for changes:') :\n          errnoException(status,\n                         `Error watching file ${filename} for changes:`);\n      error.filename = filename;\n      self.emit('error', error);\n    } else {\n      self.emit('change', eventType, filename);\n    }\n  };\n}\nutil.inherits(FSWatcher, EventEmitter);\n\nFSWatcher.prototype.start = function(filename,\n                                     persistent,\n                                     recursive,\n                                     encoding) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  var err = this._handle.start(pathModule._makeLong(filename),\n                               persistent,\n                               recursive,\n                               encoding);\n  if (err) {\n    this._handle.close();\n    const error = errnoException(err, `watch ${filename}`);\n    error.filename = filename;\n    throw error;\n  }\n};\n\nFSWatcher.prototype.close = function() {\n  this._handle.close();\n};\n\nfs.watch = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options, {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n\n  const watcher = new FSWatcher();\n  watcher.start(filename,\n                options.persistent,\n                options.recursive,\n                options.encoding);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n};\n\n\n// Stat Change Watchers\n\nfunction emitStop(self) {\n  self.emit('stop');\n}\n\nfunction statsFromPrevValues() {\n  return new Stats(statValues[14], statValues[15], statValues[16],\n                   statValues[17], statValues[18], statValues[19],\n                   statValues[20] < 0 ? undefined : statValues[20],\n                   statValues[21], statValues[22],\n                   statValues[23] < 0 ? undefined : statValues[23],\n                   statValues[24], statValues[25], statValues[26],\n                   statValues[27]);\n}\nfunction StatWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new binding.StatWatcher();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility\n  var oldStatus = -1;\n\n  this._handle.onchange = function(newStatus) {\n    if (oldStatus === -1 &&\n        newStatus === -1 &&\n        statValues[2/*new nlink*/] === statValues[16/*old nlink*/]) return;\n\n    oldStatus = newStatus;\n    self.emit('change', statsFromValues(), statsFromPrevValues());\n  };\n\n  this._handle.onstop = function() {\n    process.nextTick(emitStop, self);\n  };\n}\nutil.inherits(StatWatcher, EventEmitter);\n\n\nStatWatcher.prototype.start = function(filename, persistent, interval) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\n};\n\n\nStatWatcher.prototype.stop = function() {\n  this._handle.stop();\n};\n\n\nconst statWatchers = new Map();\n\nfs.watchFile = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n\n  var defaults = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if (options !== null && typeof options === 'object') {\n    options = util._extend(defaults, options);\n  } else {\n    listener = options;\n    options = defaults;\n  }\n\n  if (typeof listener !== 'function') {\n    throw new Error('\"watchFile()\" requires a listener function');\n  }\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n    statWatchers.set(filename, stat);\n  }\n\n  stat.addListener('change', listener);\n  return stat;\n};\n\nfs.unwatchFile = function(filename, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n};\n\n\nvar splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\'), including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return splitRootRe.exec(str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (var i = 0; i < str.length; ++i) {\n      if (str.charCodeAt(i) !== 47/*'/'*/)\n        return str.slice(0, i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result, options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  } else {\n    return asBuffer.toString(options.encoding);\n  }\n}\n\n// Finds the next portion of a (partial) path, up to the next path delimiter\nvar nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p, i) {\n    for (; i < p.length; ++i) {\n      const ch = p.charCodeAt(i);\n      if (ch === 92/*'\\'*/ || ch === 47/*'/'*/)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p, i) { return p.indexOf('/', i); };\n}\n\nconst emptyObj = Object.create(null);\nfs.realpathSync = function realpathSync(p, options) {\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    handleError((p = getPathFromURL(p)));\n    if (typeof p !== 'string')\n      p += '';\n  }\n  nullCheck(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[internalFS.realpathCacheKey];\n  const maybeCachedResult = cache && cache.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n  const original = p;\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    binding.lstat(pathModule._makeLong(base));\n    knownHard[base] = true;\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base] || (cache && cache.get(base) === base)) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        break;\n      }\n      continue;\n    }\n\n    var resolvedLink;\n    var maybeCachedResolved = cache && cache.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      var baseLong = pathModule._makeLong(base);\n      binding.lstat(baseLong);\n\n      if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n        knownHard[base] = true;\n        if (cache) cache.set(base, base);\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      var id;\n      if (!isWindows) {\n        var dev = statValues[0/*dev*/].toString(32);\n        var ino = statValues[7/*ino*/].toString(32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        binding.stat(baseLong);\n        linkTarget = binding.readlink(baseLong);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n\n      if (cache) cache.set(base, resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      binding.lstat(pathModule._makeLong(base));\n      knownHard[base] = true;\n    }\n  }\n\n  if (cache) cache.set(original, p);\n  return encodeRealpathResult(p, options);\n};\n\n\nfs.realpath = function realpath(p, options, callback) {\n  callback = maybeCallback(typeof options === 'function' ? options : callback);\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    if (handleError((p = getPathFromURL(p)), callback))\n      return;\n    if (typeof p !== 'string')\n      p += '';\n  }\n  if (!nullCheck(p, callback))\n    return;\n  p = pathModule.resolve(p);\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base, function(err) {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null, encodeRealpathResult(p, options));\n    }\n\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base]) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        return callback(null, encodeRealpathResult(p, options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err) {\n    if (err) return callback(err);\n\n    // Use stats array directly to avoid creating an fs.Stats instance just for\n    // our internal use.\n\n    // if not a symlink, skip to the next path part\n    if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    let id;\n    if (!isWindows) {\n      var dev = statValues[0/*ino*/].toString(32);\n      var ino = statValues[7/*ino*/].toString(32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return callback(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return callback(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n};\n\nfs.mkdtemp = function(prefix, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  if (!nullCheck(prefix, callback)) {\n    return;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.mkdtemp(prefix + 'XXXXXX', options.encoding, req);\n};\n\n\nfs.mkdtempSync = function(prefix, options) {\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  options = getOptions(options, {});\n  nullCheck(prefix);\n  return binding.mkdtemp(prefix + 'XXXXXX', options.encoding);\n};\n\n\nvar pool;\n\nfunction allocNewPool(poolSize) {\n  pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  // a little bit bigger buffer and water marks by default\n  options = copyObject(getOptions(options, {}));\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  Readable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = undefined;\n  this.bytesRead = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if (typeof this.end !== 'number') {\n      throw new TypeError('\"end\" option must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('\"start\" option must be <= \"end\" option');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\nfs.FileReadStream = fs.ReadStream; // support the legacy name\n\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._read(n);\n    });\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.pos !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  if (this.pos !== undefined)\n    this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0) {\n        self.bytesRead += bytesRead;\n        b = thisPool.slice(start, start + bytesRead);\n      }\n\n      self.push(b);\n    }\n  }\n};\n\n\nReadStream.prototype._destroy = function(err, cb) {\n  this.close(function(err2) {\n    cb(err || err2);\n  });\n};\n\n\nReadStream.prototype.close = function(cb) {\n  if (cb)\n    this.once('close', cb);\n\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', this.close.bind(this, null));\n      return;\n    }\n    return process.nextTick(() => this.emit('close'));\n  }\n\n  this.closed = true;\n\n  fs.close(this.fd, (er) => {\n    if (er)\n      this.emit('error', er);\n    else\n      this.emit('close');\n  });\n\n  this.fd = null;\n};\n\n\nfs.createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n};\n\nutil.inherits(WriteStream, Writable);\nfs.WriteStream = WriteStream;\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  options = copyObject(getOptions(options, {}));\n\n  Writable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('\"start\" must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', function() {\n    if (this.autoClose) {\n      this.close();\n    }\n  });\n}\n\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\n\n\nWriteStream.prototype.open = function() {\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (this.autoClose) {\n        this.destroy();\n      }\n      this.emit('error', er);\n      return;\n    }\n\n    this.fd = fd;\n    this.emit('open', fd);\n  }.bind(this));\n};\n\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!(data instanceof Buffer))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n\n  var self = this;\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += data.length;\n};\n\n\nfunction writev(fd, chunks, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\n    callback(err, written || 0, chunks);\n  }\n\n  const req = new FSReqWrap();\n  req.oncomplete = wrapper;\n  binding.writeBuffers(fd, chunks, position, req);\n}\n\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n\n  const self = this;\n  const len = data.length;\n  const chunks = new Array(len);\n  var size = 0;\n\n  for (var i = 0; i < len; i++) {\n    var chunk = data[i].chunk;\n\n    chunks[i] = chunk;\n    size += chunk.length;\n  }\n\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += size;\n};\n\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n// SyncWriteStream is internal. DO NOT USE.\n// This undocumented API was never intended to be made public.\nvar SyncWriteStream = internalFS.SyncWriteStream;\nObject.defineProperty(fs, 'SyncWriteStream', {\n  configurable: true,\n  get: internalUtil.deprecate(() => SyncWriteStream,\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061'),\n  set: internalUtil.deprecate((val) => { SyncWriteStream = val; },\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061')\n});\n",
  "http": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst agent = require('_http_agent');\nconst client = require('_http_client');\nconst common = require('_http_common');\nconst incoming = require('_http_incoming');\nconst outgoing = require('_http_outgoing');\nconst server = require('_http_server');\n\nconst Server = server.Server;\nconst ClientRequest = client.ClientRequest;\n\nfunction createServer(requestListener) {\n  return new Server(requestListener);\n}\n\nfunction request(options, cb) {\n  return new ClientRequest(options, cb);\n}\n\nfunction get(options, cb) {\n  var req = request(options, cb);\n  req.end();\n  return req;\n}\n\nmodule.exports = {\n  _connectionListener: server._connectionListener,\n  METHODS: common.methods.slice().sort(),\n  STATUS_CODES: server.STATUS_CODES,\n  Agent: agent.Agent,\n  ClientRequest,\n  globalAgent: agent.globalAgent,\n  IncomingMessage: incoming.IncomingMessage,\n  OutgoingMessage: outgoing.OutgoingMessage,\n  Server,\n  ServerResponse: server.ServerResponse,\n  createServer,\n  get,\n  request\n};\n",
  "_http_agent": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst net = require('net');\nconst util = require('util');\nconst EventEmitter = require('events');\nconst debug = util.debuglog('http');\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst nextTick = require('internal/process/next_tick').nextTick;\n\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly, this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  EventEmitter.call(this);\n\n  var self = this;\n\n  self.defaultPort = 80;\n  self.protocol = 'http:';\n\n  self.options = util._extend({}, options);\n\n  // don't confuse net and make it think that we're connecting to a pipe\n  self.options.path = null;\n  self.requests = {};\n  self.sockets = {};\n  self.freeSockets = {};\n  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;\n  self.keepAlive = self.options.keepAlive || false;\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\n  self.maxFreeSockets = self.options.maxFreeSockets || 256;\n\n  self.on('free', function(socket, options) {\n    var name = self.getName(options);\n    debug('agent.on(free)', name);\n\n    if (socket.writable &&\n        self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n      if (self.requests[name].length === 0) {\n        // don't leak\n        delete self.requests[name];\n      }\n    } else {\n      // If there are no pending requests, then put it in\n      // the freeSockets pool, but only if we're allowed to do so.\n      var req = socket._httpMessage;\n      if (req &&\n          req.shouldKeepAlive &&\n          socket.writable &&\n          self.keepAlive) {\n        var freeSockets = self.freeSockets[name];\n        var freeLen = freeSockets ? freeSockets.length : 0;\n        var count = freeLen;\n        if (self.sockets[name])\n          count += self.sockets[name].length;\n\n        if (count > self.maxSockets || freeLen >= self.maxFreeSockets) {\n          socket.destroy();\n        } else {\n          freeSockets = freeSockets || [];\n          self.freeSockets[name] = freeSockets;\n          socket.setKeepAlive(true, self.keepAliveMsecs);\n          socket.unref();\n          socket[async_id_symbol] = -1;\n          socket._httpMessage = null;\n          self.removeSocket(socket, options);\n          freeSockets.push(socket);\n        }\n      } else {\n        socket.destroy();\n      }\n    }\n  });\n}\n\nutil.inherits(Agent, EventEmitter);\n\nAgent.defaultMaxSockets = Infinity;\n\nAgent.prototype.createConnection = net.createConnection;\n\n// Get the key for a given set of request options\nAgent.prototype.getName = function getName(options) {\n  var name = options.host || 'localhost';\n\n  name += ':';\n  if (options.port)\n    name += options.port;\n\n  name += ':';\n  if (options.localAddress)\n    name += options.localAddress;\n\n  // Pacify parallel/test-http-agent-getname by only appending\n  // the ':' when options.family is set.\n  if (options.family === 4 || options.family === 6)\n    name += ':' + options.family;\n\n  return name;\n};\n\nAgent.prototype.addRequest = function addRequest(req, options, port/*legacy*/,\n                                                 localAddress/*legacy*/) {\n  // Legacy API: addRequest(req, host, port, localAddress)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port,\n      localAddress\n    };\n  }\n\n  options = util._extend({}, options);\n  util._extend(options, this.options);\n\n  if (!options.servername) {\n    options.servername = options.host;\n    const hostHeader = req.getHeader('host');\n    if (hostHeader) {\n      options.servername = hostHeader.replace(/:.*$/, '');\n    }\n  }\n\n  var name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n\n  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;\n  var sockLen = freeLen + this.sockets[name].length;\n\n  if (freeLen) {\n    // we have a free socket, so use that.\n    var socket = this.freeSockets[name].shift();\n    // Assign the handle a new asyncId and run any init() hooks.\n    socket._handle.asyncReset();\n    debug('have free socket');\n\n    // don't leak\n    if (!this.freeSockets[name].length)\n      delete this.freeSockets[name];\n\n    socket.ref();\n    req.onSocket(socket);\n    this.sockets[name].push(socket);\n  } else if (sockLen < this.maxSockets) {\n    debug('call onSocket', sockLen, freeLen);\n    // If we are under maxSockets create a new one.\n    this.createSocket(req, options, function(err, newSocket) {\n      if (err) {\n        nextTick(newSocket._handle.getAsyncId(), function() {\n          req.emit('error', err);\n        });\n        return;\n      }\n      req.onSocket(newSocket);\n    });\n  } else {\n    debug('wait for socket');\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n    this.requests[name].push(req);\n  }\n};\n\nAgent.prototype.createSocket = function createSocket(req, options, cb) {\n  var self = this;\n  options = util._extend({}, options);\n  util._extend(options, self.options);\n\n  if (!options.servername) {\n    options.servername = options.host;\n    const hostHeader = req.getHeader('host');\n    if (hostHeader) {\n      options.servername = hostHeader.replace(/:.*$/, '');\n    }\n  }\n\n  var name = self.getName(options);\n  options._agentKey = name;\n\n  debug('createConnection', name, options);\n  options.encoding = null;\n  var called = false;\n  const newSocket = self.createConnection(options, oncreate);\n  if (newSocket)\n    oncreate(null, newSocket);\n  function oncreate(err, s) {\n    if (called)\n      return;\n    called = true;\n    if (err)\n      return cb(err);\n    if (!self.sockets[name]) {\n      self.sockets[name] = [];\n    }\n    self.sockets[name].push(s);\n    debug('sockets', name, self.sockets[name].length);\n    installListeners(self, s, options);\n    cb(null, s);\n  }\n};\n\nfunction installListeners(agent, s, options) {\n  function onFree() {\n    debug('CLIENT socket onFree');\n    agent.emit('free', s, options);\n  }\n  s.on('free', onFree);\n\n  function onClose(err) {\n    debug('CLIENT socket onClose');\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool, just close it.\n    // All socket errors end in a close event anyway.\n    agent.removeSocket(s, options);\n  }\n  s.on('close', onClose);\n\n  function onRemove() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    debug('CLIENT socket onRemove');\n    agent.removeSocket(s, options);\n    s.removeListener('close', onClose);\n    s.removeListener('free', onFree);\n    s.removeListener('agentRemove', onRemove);\n  }\n  s.on('agentRemove', onRemove);\n}\n\nAgent.prototype.removeSocket = function removeSocket(s, options) {\n  var name = this.getName(options);\n  debug('removeSocket', name, 'writable:', s.writable);\n  var sets = [this.sockets];\n\n  // If the socket was destroyed, remove it from the free buffers too.\n  if (!s.writable)\n    sets.push(this.freeSockets);\n\n  for (var sk = 0; sk < sets.length; sk++) {\n    var sockets = sets[sk];\n\n    if (sockets[name]) {\n      var index = sockets[name].indexOf(s);\n      if (index !== -1) {\n        sockets[name].splice(index, 1);\n        // Don't leak\n        if (sockets[name].length === 0)\n          delete sockets[name];\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    debug('removeSocket, have a request, make a socket');\n    var req = this.requests[name][0];\n    // If we have pending requests and a socket gets closed make a new one\n    this.createSocket(req, options, function(err, newSocket) {\n      if (err) {\n        nextTick(newSocket._handle.getAsyncId(), function() {\n          req.emit('error', err);\n        });\n        return;\n      }\n      newSocket.emit('free');\n    });\n  }\n};\n\nAgent.prototype.destroy = function destroy() {\n  var sets = [this.freeSockets, this.sockets];\n  for (var s = 0; s < sets.length; s++) {\n    var set = sets[s];\n    var keys = Object.keys(set);\n    for (var v = 0; v < keys.length; v++) {\n      var setName = set[keys[v]];\n      for (var n = 0; n < setName.length; n++) {\n        setName[n].destroy();\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};\n",
  "_http_client": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst net = require('net');\nconst url = require('url');\nconst HTTPParser = process.binding('http_parser').HTTPParser;\nconst assert = require('assert').ok;\nconst common = require('_http_common');\nconst httpSocketSetup = common.httpSocketSetup;\nconst parsers = common.parsers;\nconst freeParser = common.freeParser;\nconst debug = common.debug;\nconst OutgoingMessage = require('_http_outgoing').OutgoingMessage;\nconst Agent = require('_http_agent');\nconst Buffer = require('buffer').Buffer;\nconst { urlToOptions, searchParamsSymbol } = require('internal/url');\nconst outHeadersKey = require('internal/http').outHeadersKey;\nconst nextTick = require('internal/process/next_tick').nextTick;\n\n// The actual list of disallowed characters in regexp form is more like:\n//    /[^A-Za-z0-9\\-._~!$&'()*+,;=/:@]/\n// with an additional rule for ignoring percentage-escaped characters, but\n// that's a) hard to capture in a regular expression that performs well, and\n// b) possibly too restrictive for real-world usage. So instead we restrict the\n// filter to just control characters and spaces.\n//\n// This function is used in the case of small paths, where manual character code\n// checks can greatly outperform the equivalent regexp (tested in V8 5.4).\nfunction isInvalidPath(s) {\n  var i = 0;\n  if (s.charCodeAt(0) <= 32) return true;\n  if (++i >= s.length) return false;\n  if (s.charCodeAt(1) <= 32) return true;\n  if (++i >= s.length) return false;\n  if (s.charCodeAt(2) <= 32) return true;\n  if (++i >= s.length) return false;\n  if (s.charCodeAt(3) <= 32) return true;\n  if (++i >= s.length) return false;\n  if (s.charCodeAt(4) <= 32) return true;\n  if (++i >= s.length) return false;\n  if (s.charCodeAt(5) <= 32) return true;\n  ++i;\n  for (; i < s.length; ++i)\n    if (s.charCodeAt(i) <= 32) return true;\n  return false;\n}\n\nfunction validateHost(host, name) {\n  if (host != null && typeof host !== 'string') {\n    throw new TypeError(\n      `\"options.${name}\" must either be a string, undefined or null`);\n  }\n  return host;\n}\n\nfunction ClientRequest(options, cb) {\n  OutgoingMessage.call(this);\n\n  if (typeof options === 'string') {\n    options = url.parse(options);\n    if (!options.hostname) {\n      throw new Error('Unable to determine the domain name');\n    }\n  } else if (options && options[searchParamsSymbol] &&\n             options[searchParamsSymbol][searchParamsSymbol]) {\n    // url.URL instance\n    options = urlToOptions(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  var agent = options.agent;\n  var defaultAgent = options._defaultAgent || Agent.globalAgent;\n  if (agent === false) {\n    agent = new defaultAgent.constructor();\n  } else if (agent === null || agent === undefined) {\n    if (typeof options.createConnection !== 'function') {\n      agent = defaultAgent;\n    }\n    // Explicitly pass through this statement as agent will not be used\n    // when createConnection is provided.\n  } else if (typeof agent.addRequest !== 'function') {\n    throw new TypeError(\n      'Agent option must be an Agent-like object, undefined, or false.'\n    );\n  }\n  this.agent = agent;\n\n  var protocol = options.protocol || defaultAgent.protocol;\n  var expectedProtocol = defaultAgent.protocol;\n  if (this.agent && this.agent.protocol)\n    expectedProtocol = this.agent.protocol;\n\n  var path;\n  if (options.path) {\n    path = '' + options.path;\n    var invalidPath;\n    if (path.length <= 39) { // Determined experimentally in V8 5.4\n      invalidPath = isInvalidPath(path);\n    } else {\n      invalidPath = /[\\u0000-\\u0020]/.test(path);\n    }\n    if (invalidPath)\n      throw new TypeError('Request path contains unescaped characters');\n  }\n\n  if (protocol !== expectedProtocol) {\n    throw new Error('Protocol \"' + protocol + '\" not supported. ' +\n                    'Expected \"' + expectedProtocol + '\"');\n  }\n\n  var defaultPort = options.defaultPort ||\n                    this.agent && this.agent.defaultPort;\n\n  var port = options.port = options.port || defaultPort || 80;\n  var host = options.host = validateHost(options.hostname, 'hostname') ||\n                            validateHost(options.host, 'host') || 'localhost';\n\n  var setHost = (options.setHost === undefined);\n\n  this.socketPath = options.socketPath;\n  this.timeout = options.timeout;\n\n  var method = options.method;\n  var methodIsString = (typeof method === 'string');\n  if (method != null && !methodIsString) {\n    throw new TypeError('Method must be a string');\n  }\n\n  if (methodIsString && method) {\n    if (!common._checkIsHttpToken(method)) {\n      throw new TypeError('Method must be a valid HTTP token');\n    }\n    method = this.method = method.toUpperCase();\n  } else {\n    method = this.method = 'GET';\n  }\n\n  this.path = options.path || '/';\n  if (cb) {\n    this.once('response', cb);\n  }\n\n  var headersArray = Array.isArray(options.headers);\n  if (!headersArray) {\n    if (options.headers) {\n      var keys = Object.keys(options.headers);\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        this.setHeader(key, options.headers[key]);\n      }\n    }\n    if (host && !this.getHeader('host') && setHost) {\n      var hostHeader = host;\n\n      // For the Host header, ensure that IPv6 addresses are enclosed\n      // in square brackets, as defined by URI formatting\n      // https://tools.ietf.org/html/rfc3986#section-3.2.2\n      var posColon = hostHeader.indexOf(':');\n      if (posColon !== -1 &&\n          hostHeader.indexOf(':', posColon + 1) !== -1 &&\n          hostHeader.charCodeAt(0) !== 91/*'['*/) {\n        hostHeader = `[${hostHeader}]`;\n      }\n\n      if (port && +port !== defaultPort) {\n        hostHeader += ':' + port;\n      }\n      this.setHeader('Host', hostHeader);\n    }\n  }\n\n  if (options.auth && !this.getHeader('Authorization')) {\n    this.setHeader('Authorization', 'Basic ' +\n                   Buffer.from(options.auth).toString('base64'));\n  }\n\n  if (method === 'GET' ||\n      method === 'HEAD' ||\n      method === 'DELETE' ||\n      method === 'OPTIONS' ||\n      method === 'CONNECT') {\n    this.useChunkedEncodingByDefault = false;\n  } else {\n    this.useChunkedEncodingByDefault = true;\n  }\n\n  if (headersArray) {\n    this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n',\n                      options.headers);\n  } else if (this.getHeader('expect')) {\n    if (this._header) {\n      throw new Error('Can\\'t render headers after they are sent to the ' +\n                      'client');\n    }\n\n    this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n',\n                      this[outHeadersKey]);\n  }\n\n  this._ended = false;\n  this.res = null;\n  this.aborted = undefined;\n  this.timeoutCb = null;\n  this.upgradeOrConnect = false;\n  this.parser = null;\n  this.maxHeadersCount = null;\n\n  var called = false;\n\n  var oncreate = (err, socket) => {\n    if (called)\n      return;\n    called = true;\n    if (err) {\n      process.nextTick(() => this.emit('error', err));\n      return;\n    }\n    this.onSocket(socket);\n    this._deferToConnect(null, null, () => this._flush());\n  };\n\n  var newSocket;\n  if (this.socketPath) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n    var optionsPath = {\n      path: this.socketPath,\n      timeout: this.timeout\n    };\n    newSocket = this.agent.createConnection(optionsPath, oncreate);\n    if (newSocket && !called) {\n      called = true;\n      this.onSocket(newSocket);\n    } else {\n      return;\n    }\n  } else if (this.agent) {\n    // If there is an agent we should default to Connection:keep-alive,\n    // but only if the Agent will actually reuse the connection!\n    // If it's not a keepAlive agent, and the maxSockets==Infinity, then\n    // there's never a case where this socket will actually be reused\n    if (!this.agent.keepAlive && !Number.isFinite(this.agent.maxSockets)) {\n      this._last = true;\n      this.shouldKeepAlive = false;\n    } else {\n      this._last = false;\n      this.shouldKeepAlive = true;\n    }\n    this.agent.addRequest(this, options);\n  } else {\n    // No agent, default to Connection:close.\n    this._last = true;\n    this.shouldKeepAlive = false;\n    if (typeof options.createConnection === 'function') {\n      newSocket = options.createConnection(options, oncreate);\n      if (newSocket && !called) {\n        called = true;\n        this.onSocket(newSocket);\n      } else {\n        return;\n      }\n    } else {\n      debug('CLIENT use net.createConnection', options);\n      this.onSocket(net.createConnection(options));\n    }\n  }\n\n  this._deferToConnect(null, null, () => this._flush());\n}\n\nutil.inherits(ClientRequest, OutgoingMessage);\n\n\nClientRequest.prototype._finish = function _finish() {\n  ;\n  ;\n  ;\n  OutgoingMessage.prototype._finish.call(this);\n};\n\nClientRequest.prototype._implicitHeader = function _implicitHeader() {\n  if (this._header) {\n    throw new Error('Can\\'t render headers after they are sent to the client');\n  }\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n',\n                    this[outHeadersKey]);\n};\n\nClientRequest.prototype.abort = function abort() {\n  if (!this.aborted) {\n    process.nextTick(emitAbortNT.bind(this));\n  }\n  // Mark as aborting so we can avoid sending queued request data\n  // This is used as a truthy flag elsewhere. The use of Date.now is for\n  // debugging purposes only.\n  this.aborted = Date.now();\n\n  // If we're aborting, we don't care about any more response data.\n  if (this.res)\n    this.res._dump();\n  else\n    this.once('response', function(res) {\n      res._dump();\n    });\n\n  // In the event that we don't have a socket, we will pop out of\n  // the request queue through handling in onSocket.\n  if (this.socket) {\n    // in-progress\n    this.socket.destroy();\n  }\n};\n\n\nfunction emitAbortNT() {\n  this.emit('abort');\n}\n\n\nfunction createHangUpError() {\n  var error = new Error('socket hang up');\n  error.code = 'ECONNRESET';\n  return error;\n}\n\n\nfunction socketCloseListener() {\n  var socket = this;\n  var req = socket._httpMessage;\n  debug('HTTP socket close');\n\n  // Pull through final chunk, if anything is buffered.\n  // the ondata function will handle it properly, and this\n  // is a no-op if no final chunk remains.\n  socket.read();\n\n  // NOTE: It's important to get parser here, because it could be freed by\n  // the `socketOnData`.\n  var parser = socket.parser;\n  req.emit('close');\n  if (req.res && req.res.readable) {\n    // Socket closed before we emitted 'end' below.\n    req.res.emit('aborted');\n    var res = req.res;\n    res.on('end', function() {\n      res.emit('close');\n    });\n    res.push(null);\n  } else if (!req.res && !req.socket._hadError) {\n    // This socket error fired before we started to\n    // receive a response. The error needs to\n    // fire on the request.\n    req.emit('error', createHangUpError());\n    req.socket._hadError = true;\n  }\n\n  // Too bad.  That output wasn't getting written.\n  // This is pretty terrible that it doesn't raise an error.\n  // Fixed better in v0.10\n  if (req.output)\n    req.output.length = 0;\n  if (req.outputEncodings)\n    req.outputEncodings.length = 0;\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n}\n\nfunction socketErrorListener(err) {\n  var socket = this;\n  var req = socket._httpMessage;\n  debug('SOCKET ERROR:', err.message, err.stack);\n\n  if (req) {\n    req.emit('error', err);\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req.socket._hadError = true;\n  }\n\n  // Handle any pending data\n  socket.read();\n\n  var parser = socket.parser;\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n\n  // Ensure that no further data will come out of the socket\n  socket.removeListener('data', socketOnData);\n  socket.removeListener('end', socketOnEnd);\n  socket.destroy();\n}\n\nfunction freeSocketErrorListener(err) {\n  var socket = this;\n  debug('SOCKET ERROR on FREE socket:', err.message, err.stack);\n  socket.destroy();\n  socket.emit('agentRemove');\n}\n\nfunction socketOnEnd() {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.emit('error', createHangUpError());\n    req.socket._hadError = true;\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req, socket);\n  }\n  socket.destroy();\n}\n\nfunction socketOnData(d) {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  assert(parser && parser.socket === socket);\n\n  var ret = parser.execute(d);\n  if (ret instanceof Error) {\n    debug('parse error');\n    freeParser(parser, req, socket);\n    socket.destroy();\n    req.emit('error', ret);\n    req.socket._hadError = true;\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    var bytesParsed = ret;\n    var res = parser.incoming;\n    req.res = res;\n\n    socket.removeListener('data', socketOnData);\n    socket.removeListener('end', socketOnEnd);\n    parser.finish();\n\n    var bodyHead = d.slice(bytesParsed, d.length);\n\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (req.listenerCount(eventName) > 0) {\n      req.upgradeOrConnect = true;\n\n      // detach the socket\n      socket.emit('agentRemove');\n      socket.removeListener('close', socketCloseListener);\n      socket.removeListener('error', socketErrorListener);\n\n      // TODO(isaacs): Need a way to reset a stream to fresh state\n      // IE, not flowing, and not explicitly paused.\n      socket._readableState.flowing = null;\n\n      req.emit(eventName, res, socket, bodyHead);\n      req.emit('close');\n    } else {\n      // Got Upgrade header or CONNECT method, but have no handler.\n      socket.destroy();\n    }\n    freeParser(parser, req, socket);\n  } else if (parser.incoming && parser.incoming.complete &&\n             // When the status code is 100 (Continue), the server will\n             // send a final response after this client sends a request\n             // body. So, we must not free the parser.\n             parser.incoming.statusCode !== 100) {\n    socket.removeListener('data', socketOnData);\n    socket.removeListener('end', socketOnEnd);\n    freeParser(parser, req, socket);\n  }\n}\n\n\n// client\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\n  var socket = this.socket;\n  var req = socket._httpMessage;\n\n\n  // propagate \"domain\" setting...\n  if (req.domain && !res.domain) {\n    debug('setting \"res.domain\"');\n    res.domain = req.domain;\n  }\n\n  debug('AGENT incoming response!');\n\n  if (req.res) {\n    // We already have a response object, this means the server\n    // sent a double response.\n    socket.destroy();\n    return;\n  }\n  req.res = res;\n\n  // Responses to CONNECT request is handled as Upgrade.\n  if (req.method === 'CONNECT') {\n    res.upgrade = true;\n    return 2; // skip body, and the rest\n  }\n\n  // Responses to HEAD requests are crazy.\n  // HEAD responses aren't allowed to have an entity-body\n  // but *can* have a content-length which actually corresponds\n  // to the content-length of the entity-body had the request\n  // been a GET.\n  var isHeadResponse = req.method === 'HEAD';\n  debug('AGENT isHeadResponse', isHeadResponse);\n\n  if (res.statusCode === 100) {\n    // restart the parser, as this is a continue message.\n    req.res = null; // Clear res so that we don't hit double-responses.\n    req.emit('continue');\n    return true;\n  }\n\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    // Server MUST respond with Connection:keep-alive for us to enable it.\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\n    // keep the connection open.\n    req.shouldKeepAlive = false;\n  }\n\n\n  ;\n  ;\n  ;\n  req.res = res;\n  res.req = req;\n\n  // add our listener first, so that we guarantee socket cleanup\n  res.on('end', responseOnEnd);\n  req.on('prefinish', requestOnPrefinish);\n  var handled = req.emit('response', res);\n\n  // If the user did not listen for the 'response' event, then they\n  // can't possibly read the data, so we ._dump() it into the void\n  // so that the socket doesn't hang there in a paused state.\n  if (!handled)\n    res._dump();\n\n  return isHeadResponse;\n}\n\n// client\nfunction responseKeepAlive(res, req) {\n  var socket = req.socket;\n\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug('AGENT socket.destroySoon()');\n      socket.destroySoon();\n    }\n    assert(!socket.writable);\n  } else {\n    debug('AGENT socket keep-alive');\n    if (req.timeoutCb) {\n      socket.setTimeout(0, req.timeoutCb);\n      req.timeoutCb = null;\n    }\n    socket.removeListener('close', socketCloseListener);\n    socket.removeListener('error', socketErrorListener);\n    socket.once('error', freeSocketErrorListener);\n    // There are cases where _handle === null. Avoid those. Passing null to\n    // nextTick() will call initTriggerId() to retrieve the id.\n    const asyncId = socket._handle ? socket._handle.getAsyncId() : null;\n    // Mark this socket as available, AFTER user-added end\n    // handlers have a chance to run.\n    nextTick(asyncId, emitFreeNT, socket);\n  }\n}\n\nfunction responseOnEnd() {\n  const res = this;\n  const req = this.req;\n\n  req._ended = true;\n  if (!req.shouldKeepAlive || req.finished)\n    responseKeepAlive(res, req);\n}\n\nfunction requestOnPrefinish() {\n  const req = this;\n  const res = this.res;\n\n  if (!req.shouldKeepAlive)\n    return;\n\n  if (req._ended)\n    responseKeepAlive(res, req);\n}\n\nfunction emitFreeNT(socket) {\n  socket.emit('free');\n}\n\nfunction tickOnSocket(req, socket) {\n  var parser = parsers.alloc();\n  req.socket = socket;\n  req.connection = socket;\n  parser.reinitialize(HTTPParser.RESPONSE);\n  parser.socket = socket;\n  parser.incoming = null;\n  parser.outgoing = req;\n  req.parser = parser;\n\n  socket.parser = parser;\n  socket._httpMessage = req;\n\n  // Setup \"drain\" propagation.\n  httpSocketSetup(socket);\n\n  // Propagate headers limit from request object to parser\n  if (typeof req.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\n  } else {\n    // Set default value because parser may be reused from FreeList\n    parser.maxHeaderPairs = 2000;\n  }\n\n  parser.onIncoming = parserOnIncomingClient;\n  socket.removeListener('error', freeSocketErrorListener);\n  socket.on('error', socketErrorListener);\n  socket.on('data', socketOnData);\n  socket.on('end', socketOnEnd);\n  socket.on('close', socketCloseListener);\n\n  if (req.timeout) {\n    const emitRequestTimeout = () => req.emit('timeout');\n    socket.once('timeout', emitRequestTimeout);\n    req.once('response', (res) => {\n      res.once('end', () => {\n        socket.removeListener('timeout', emitRequestTimeout);\n      });\n    });\n  }\n  req.emit('socket', socket);\n}\n\nClientRequest.prototype.onSocket = function onSocket(socket) {\n  process.nextTick(onSocketNT, this, socket);\n};\n\nfunction onSocketNT(req, socket) {\n  if (req.aborted) {\n    // If we were aborted while waiting for a socket, skip the whole thing.\n    if (req.socketPath || !req.agent) {\n      socket.destroy();\n    } else {\n      socket.emit('free');\n    }\n  } else {\n    tickOnSocket(req, socket);\n  }\n}\n\nClientRequest.prototype._deferToConnect = _deferToConnect;\nfunction _deferToConnect(method, arguments_, cb) {\n  // This function is for calls that need to happen once the socket is\n  // connected and writable. It's an important promisy thing for all the socket\n  // calls that happen either now (when a socket is assigned) or\n  // in the future (when a socket gets assigned out of the pool and is\n  // eventually writable).\n\n  const callSocketMethod = () => {\n    if (method)\n      this.socket[method].apply(this.socket, arguments_);\n\n    if (typeof cb === 'function')\n      cb();\n  };\n\n  const onSocket = () => {\n    if (this.socket.writable) {\n      callSocketMethod();\n    } else {\n      this.socket.once('connect', callSocketMethod);\n    }\n  };\n\n  if (!this.socket) {\n    this.once('socket', onSocket);\n  } else {\n    onSocket();\n  }\n}\n\nClientRequest.prototype.setTimeout = function setTimeout(msecs, callback) {\n  if (callback) this.once('timeout', callback);\n\n  const emitTimeout = () => this.emit('timeout');\n\n  if (this.socket && this.socket.writable) {\n    if (this.timeoutCb)\n      this.socket.setTimeout(0, this.timeoutCb);\n    this.timeoutCb = emitTimeout;\n    this.socket.setTimeout(msecs, emitTimeout);\n    return this;\n  }\n\n  // Set timeoutCb so that it'll get cleaned up on request end\n  this.timeoutCb = emitTimeout;\n  if (this.socket) {\n    var sock = this.socket;\n    this.socket.once('connect', function() {\n      sock.setTimeout(msecs, emitTimeout);\n    });\n    return this;\n  }\n\n  this.once('socket', function(sock) {\n    sock.setTimeout(msecs, emitTimeout);\n  });\n\n  return this;\n};\n\nClientRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  this._deferToConnect('setNoDelay', [noDelay]);\n};\n\nClientRequest.prototype.setSocketKeepAlive =\n    function setSocketKeepAlive(enable, initialDelay) {\n      this._deferToConnect('setKeepAlive', [enable, initialDelay]);\n    };\n\nClientRequest.prototype.clearTimeout = function clearTimeout(cb) {\n  this.setTimeout(0, cb);\n};\n\nmodule.exports = {\n  ClientRequest\n};\n",
  "_http_common": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst binding = process.binding('http_parser');\nconst methods = binding.methods;\nconst HTTPParser = binding.HTTPParser;\n\nconst FreeList = require('internal/freelist');\nconst ondrain = require('internal/http').ondrain;\nconst incoming = require('_http_incoming');\nconst emitDestroy = require('async_hooks').emitDestroy;\nconst IncomingMessage = incoming.IncomingMessage;\nconst readStart = incoming.readStart;\nconst readStop = incoming.readStop;\n\nconst debug = require('util').debuglog('http');\n\nconst kOnHeaders = HTTPParser.kOnHeaders | 0;\nconst kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\nconst kOnBody = HTTPParser.kOnBody | 0;\nconst kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\n\n// Only called in the slow case where slow means\n// that the request headers were either fragmented\n// across multiple TCP packets or too large to be\n// processed in a single run. This method is also\n// called to process trailing HTTP headers.\nfunction parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n}\n\n// `headers` and `url` are set only if .onHeaders() has not been called for\n// this request.\n// `url` is not set for response parsers but that's not applicable here since\n// all our parsers are request parsers.\nfunction parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\n                                 url, statusCode, statusMessage, upgrade,\n                                 shouldKeepAlive) {\n  var parser = this;\n\n  if (!headers) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (!url) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  parser.incoming = new IncomingMessage(parser.socket);\n  parser.incoming.httpVersionMajor = versionMajor;\n  parser.incoming.httpVersionMinor = versionMinor;\n  parser.incoming.httpVersion = versionMajor + '.' + versionMinor;\n  parser.incoming.url = url;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = Math.min(n, parser.maxHeaderPairs);\n\n  parser.incoming._addHeaderLines(headers, n);\n\n  if (typeof method === 'number') {\n    // server only\n    parser.incoming.method = methods[method];\n  } else {\n    // client only\n    parser.incoming.statusCode = statusCode;\n    parser.incoming.statusMessage = statusMessage;\n  }\n\n  if (upgrade && parser.outgoing !== null && !parser.outgoing.upgrading) {\n    // The client made non-upgrade request, and server is just advertising\n    // supported protocols.\n    //\n    // See RFC7230 Section 6.7\n    upgrade = false;\n  }\n\n  parser.incoming.upgrade = upgrade;\n\n  var skipBody = 0; // response to HEAD or CONNECT\n\n  if (!upgrade) {\n    // For upgraded connections and CONNECT method request, we'll emit this\n    // after parser.execute so that we can capture the first part of the new\n    // protocol.\n    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);\n  }\n\n  if (typeof skipBody !== 'number')\n    return skipBody ? 1 : 0;\n  else\n    return skipBody;\n}\n\n// XXX This is a mess.\n// TODO: http.Parser should be a Writable emits request/response events.\nfunction parserOnBody(b, start, len) {\n  var parser = this;\n  var stream = parser.incoming;\n\n  // if the stream has already been removed, then drop it.\n  if (!stream)\n    return;\n\n  var socket = stream.socket;\n\n  // pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(socket);\n  }\n}\n\nfunction parserOnMessageComplete() {\n  var parser = this;\n  var stream = parser.incoming;\n\n  if (stream) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    var headers = parser._headers;\n    if (headers) {\n      parser.incoming._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // force to read the next incoming message\n  readStart(parser.socket);\n}\n\n\nvar parsers = new FreeList('parsers', 1000, function() {\n  var parser = new HTTPParser(HTTPParser.REQUEST);\n\n  parser._headers = [];\n  parser._url = '';\n  parser._consumed = false;\n\n  parser.socket = null;\n  parser.incoming = null;\n  parser.outgoing = null;\n\n  // Only called in the slow case where slow means\n  // that the request headers were either fragmented\n  // across multiple TCP packets or too large to be\n  // processed in a single run. This method is also\n  // called to process trailing HTTP headers.\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n  parser[kOnExecute] = null;\n\n  return parser;\n});\n\n\n// Free the parser and also break any links that it\n// might have to any other things.\n// TODO: All parser data should be attached to a\n// single object, so that it can be easily cleaned\n// up by doing `parser.data = {}`, which should\n// be done in FreeList.free.  `parsers.free(parser)`\n// should be all that is needed.\nfunction freeParser(parser, req, socket) {\n  if (parser) {\n    parser._headers = [];\n    parser.onIncoming = null;\n    if (parser._consumed)\n      parser.unconsume();\n    parser._consumed = false;\n    if (parser.socket)\n      parser.socket.parser = null;\n    parser.socket = null;\n    parser.incoming = null;\n    parser.outgoing = null;\n    parser[kOnExecute] = null;\n    if (parsers.free(parser) === false) {\n      parser.close();\n    } else {\n      // Since the Parser destructor isn't going to run the destroy() callbacks\n      // it needs to be triggered manually.\n      emitDestroy(parser.getAsyncId());\n    }\n  }\n  if (req) {\n    req.parser = null;\n  }\n  if (socket) {\n    socket.parser = null;\n  }\n}\n\n\nfunction httpSocketSetup(socket) {\n  socket.removeListener('drain', ondrain);\n  socket.on('drain', ondrain);\n}\n\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n *\n * Allowed characters in an HTTP token:\n * ^_`a-z  94-122\n * A-Z     65-90\n * -       45\n * 0-9     48-57\n * !       33\n * #$%&'   35-39\n * *+      42-43\n * .       46\n * |       124\n * ~       126\n *\n * This implementation of checkIsHttpToken() loops over the string instead of\n * using a regular expression since the former is up to 180% faster with v8 4.9\n * depending on the string length (the shorter the string, the larger the\n * performance difference)\n *\n * Additionally, checkIsHttpToken() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\nvar validTokens = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, // 112 - 127\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 128 ...\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  // ... 255\n];\nfunction checkIsHttpToken(val) {\n  if (!validTokens[val.charCodeAt(0)])\n    return false;\n  if (val.length < 2)\n    return true;\n  if (!validTokens[val.charCodeAt(1)])\n    return false;\n  if (val.length < 3)\n    return true;\n  if (!validTokens[val.charCodeAt(2)])\n    return false;\n  if (val.length < 4)\n    return true;\n  if (!validTokens[val.charCodeAt(3)])\n    return false;\n  for (var i = 4; i < val.length; ++i) {\n    if (!validTokens[val.charCodeAt(i)])\n      return false;\n  }\n  return true;\n}\n\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\nvar validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1  // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n  val += '';\n  if (val.length < 1)\n    return false;\n  if (!validHdrChars[val.charCodeAt(0)])\n    return true;\n  if (val.length < 2)\n    return false;\n  if (!validHdrChars[val.charCodeAt(1)])\n    return true;\n  if (val.length < 3)\n    return false;\n  if (!validHdrChars[val.charCodeAt(2)])\n    return true;\n  if (val.length < 4)\n    return false;\n  if (!validHdrChars[val.charCodeAt(3)])\n    return true;\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)])\n      return true;\n  }\n  return false;\n}\n\nmodule.exports = {\n  _checkInvalidHeaderChar: checkInvalidHeaderChar,\n  _checkIsHttpToken: checkIsHttpToken,\n  chunkExpression: /(?:^|\\W)chunked(?:$|\\W)/i,\n  continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i,\n  CRLF: '\\r\\n',\n  debug,\n  freeParser,\n  httpSocketSetup,\n  methods,\n  parsers\n};\n",
  "_http_incoming": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst Stream = require('stream');\n\nfunction readStart(socket) {\n  if (socket && !socket._paused && socket.readable)\n    socket.resume();\n}\n\nfunction readStop(socket) {\n  if (socket)\n    socket.pause();\n}\n\n/* Abstract base class for ServerRequest and ClientResponse. */\nfunction IncomingMessage(socket) {\n  Stream.Readable.call(this);\n\n  // Set this to `true` so that stream.Readable won't attempt to read more\n  // data on `IncomingMessage#push` (see `maybeReadMore` in\n  // `_stream_readable.js`). This is important for proper tracking of\n  // `IncomingMessage#_consuming` which is used to dump requests that users\n  // haven't attempted to read.\n  this._readableState.readingMore = true;\n\n  this.socket = socket;\n  this.connection = socket;\n\n  this.httpVersionMajor = null;\n  this.httpVersionMinor = null;\n  this.httpVersion = null;\n  this.complete = false;\n  this.headers = {};\n  this.rawHeaders = [];\n  this.trailers = {};\n  this.rawTrailers = [];\n\n  this.readable = true;\n\n  this.upgrade = null;\n\n  // request (server) only\n  this.url = '';\n  this.method = null;\n\n  // response (client) only\n  this.statusCode = null;\n  this.statusMessage = null;\n  this.client = socket;\n\n  // flag for backwards compatibility grossness.\n  this._consuming = false;\n\n  // flag for when we decide that this message cannot possibly be\n  // read by the user, so there's no point continuing to handle it.\n  this._dumped = false;\n}\nutil.inherits(IncomingMessage, Stream.Readable);\n\n\nIncomingMessage.prototype.setTimeout = function setTimeout(msecs, callback) {\n  if (callback)\n    this.on('timeout', callback);\n  this.socket.setTimeout(msecs);\n  return this;\n};\n\n\nIncomingMessage.prototype.read = function read(n) {\n  if (!this._consuming)\n    this._readableState.readingMore = false;\n  this._consuming = true;\n  this.read = Stream.Readable.prototype.read;\n  return this.read(n);\n};\n\n\nIncomingMessage.prototype._read = function _read(n) {\n  // We actually do almost nothing here, because the parserOnBody\n  // function fills up our internal buffer directly.  However, we\n  // do need to unpause the underlying socket so that it flows.\n  if (this.socket.readable)\n    readStart(this.socket);\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nIncomingMessage.prototype.destroy = function destroy(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n};\n\n\nIncomingMessage.prototype._addHeaderLines = _addHeaderLines;\nfunction _addHeaderLines(headers, n) {\n  if (headers && headers.length) {\n    var dest;\n    if (this.complete) {\n      this.rawTrailers = headers;\n      dest = this.trailers;\n    } else {\n      this.rawHeaders = headers;\n      dest = this.headers;\n    }\n\n    for (var i = 0; i < n; i += 2) {\n      this._addHeaderLine(headers[i], headers[i + 1], dest);\n    }\n  }\n}\n\n\n// This function is used to help avoid the lowercasing of a field name if it\n// matches a 'traditional cased' version of a field name. It then returns the\n// lowercased name to both avoid calling toLowerCase() a second time and to\n// indicate whether the field was a 'no duplicates' field. If a field is not a\n// 'no duplicates' field, a `0` byte is prepended as a flag. The one exception\n// to this is the Set-Cookie header which is indicated by a `1` byte flag, since\n// it is an 'array' field and thus is treated differently in _addHeaderLines().\n// TODO: perhaps http_parser could be returning both raw and lowercased versions\n// of known header names to avoid us having to call toLowerCase() for those\n// headers.\n\n// 'array' header list is taken from:\n// https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp\nfunction matchKnownFields(field) {\n  var low = false;\n  while (true) {\n    switch (field) {\n      case 'Content-Type':\n      case 'content-type':\n        return 'content-type';\n      case 'Content-Length':\n      case 'content-length':\n        return 'content-length';\n      case 'User-Agent':\n      case 'user-agent':\n        return 'user-agent';\n      case 'Referer':\n      case 'referer':\n        return 'referer';\n      case 'Host':\n      case 'host':\n        return 'host';\n      case 'Authorization':\n      case 'authorization':\n        return 'authorization';\n      case 'Proxy-Authorization':\n      case 'proxy-authorization':\n        return 'proxy-authorization';\n      case 'If-Modified-Since':\n      case 'if-modified-since':\n        return 'if-modified-since';\n      case 'If-Unmodified-Since':\n      case 'if-unmodified-since':\n        return 'if-unmodified-since';\n      case 'From':\n      case 'from':\n        return 'from';\n      case 'Location':\n      case 'location':\n        return 'location';\n      case 'Max-Forwards':\n      case 'max-forwards':\n        return 'max-forwards';\n      case 'Retry-After':\n      case 'retry-after':\n        return 'retry-after';\n      case 'ETag':\n      case 'etag':\n        return 'etag';\n      case 'Last-Modified':\n      case 'last-modified':\n        return 'last-modified';\n      case 'Server':\n      case 'server':\n        return 'server';\n      case 'Age':\n      case 'age':\n        return 'age';\n      case 'Expires':\n      case 'expires':\n        return 'expires';\n      case 'Set-Cookie':\n      case 'set-cookie':\n        return '\\u0001';\n      case 'Cookie':\n      case 'cookie':\n        return '\\u0002cookie';\n      // The fields below are not used in _addHeaderLine(), but they are common\n      // headers where we can avoid toLowerCase() if the mixed or lower case\n      // versions match the first time through.\n      case 'Transfer-Encoding':\n      case 'transfer-encoding':\n        return '\\u0000transfer-encoding';\n      case 'Date':\n      case 'date':\n        return '\\u0000date';\n      case 'Connection':\n      case 'connection':\n        return '\\u0000connection';\n      case 'Cache-Control':\n      case 'cache-control':\n        return '\\u0000cache-control';\n      case 'Vary':\n      case 'vary':\n        return '\\u0000vary';\n      case 'Content-Encoding':\n      case 'content-encoding':\n        return '\\u0000content-encoding';\n      case 'Origin':\n      case 'origin':\n        return '\\u0000origin';\n      case 'Upgrade':\n      case 'upgrade':\n        return '\\u0000upgrade';\n      case 'Expect':\n      case 'expect':\n        return '\\u0000expect';\n      case 'If-Match':\n      case 'if-match':\n        return '\\u0000if-match';\n      case 'If-None-Match':\n      case 'if-none-match':\n        return '\\u0000if-none-match';\n      case 'Accept':\n      case 'accept':\n        return '\\u0000accept';\n      case 'Accept-Encoding':\n      case 'accept-encoding':\n        return '\\u0000accept-encoding';\n      case 'Accept-Language':\n      case 'accept-language':\n        return '\\u0000accept-language';\n      case 'X-Forwarded-For':\n      case 'x-forwarded-for':\n        return '\\u0000x-forwarded-for';\n      case 'X-Forwarded-Host':\n      case 'x-forwarded-host':\n        return '\\u0000x-forwarded-host';\n      case 'X-Forwarded-Proto':\n      case 'x-forwarded-proto':\n        return '\\u0000x-forwarded-proto';\n      default:\n        if (low)\n          return '\\u0000' + field;\n        field = field.toLowerCase();\n        low = true;\n    }\n  }\n}\n// Add the given (field, value) pair to the message\n//\n// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n// same header with a ', ' if the header in question supports specification of\n// multiple values this way. The one exception to this is the Cookie header,\n// which has multiple values joined with a '; ' instead. If a header's values\n// cannot be joined in either of these ways, we declare the first instance the\n// winner and drop the second. Extended header fields (those beginning with\n// 'x-') are always joined.\nIncomingMessage.prototype._addHeaderLine = _addHeaderLine;\nfunction _addHeaderLine(field, value, dest) {\n  field = matchKnownFields(field);\n  var flag = field.charCodeAt(0);\n  if (flag === 0 || flag === 2) {\n    field = field.slice(1);\n    // Make a delimited list\n    if (typeof dest[field] === 'string') {\n      dest[field] += (flag === 0 ? ', ' : '; ') + value;\n    } else {\n      dest[field] = value;\n    }\n  } else if (flag === 1) {\n    // Array header -- only Set-Cookie at the moment\n    if (dest['set-cookie'] !== undefined) {\n      dest['set-cookie'].push(value);\n    } else {\n      dest['set-cookie'] = [value];\n    }\n  } else {\n    // Drop duplicates\n    if (dest[field] === undefined)\n      dest[field] = value;\n  }\n}\n\n\n// Call this instead of resume() if we want to just\n// dump all the data to /dev/null\nIncomingMessage.prototype._dump = function _dump() {\n  if (!this._dumped) {\n    this._dumped = true;\n    this.resume();\n  }\n};\n\nmodule.exports = {\n  IncomingMessage,\n  readStart,\n  readStop\n};\n",
  "_http_outgoing": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst assert = require('assert').ok;\nconst Stream = require('stream');\nconst timers = require('timers');\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst Buffer = require('buffer').Buffer;\nconst common = require('_http_common');\nconst checkIsHttpToken = common._checkIsHttpToken;\nconst checkInvalidHeaderChar = common._checkInvalidHeaderChar;\nconst outHeadersKey = require('internal/http').outHeadersKey;\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst nextTick = require('internal/process/next_tick').nextTick;\n\nconst CRLF = common.CRLF;\nconst debug = common.debug;\n\nvar RE_FIELDS =\n  /^(?:Connection|Transfer-Encoding|Content-Length|Date|Expect|Trailer|Upgrade)$/i;\nvar RE_CONN_VALUES = /(?:^|\\W)close|upgrade(?:$|\\W)/ig;\nvar RE_TE_CHUNKED = common.chunkExpression;\n\n// isCookieField performs a case-insensitive comparison of a provided string\n// against the word \"cookie.\" This method (at least as of V8 5.4) is faster than\n// the equivalent case-insensitive regexp, even if isCookieField does not get\n// inlined.\nfunction isCookieField(s) {\n  if (s.length !== 6) return false;\n  var ch = s.charCodeAt(0);\n  if (ch !== 99 && ch !== 67) return false;\n  ch = s.charCodeAt(1);\n  if (ch !== 111 && ch !== 79) return false;\n  ch = s.charCodeAt(2);\n  if (ch !== 111 && ch !== 79) return false;\n  ch = s.charCodeAt(3);\n  if (ch !== 107 && ch !== 75) return false;\n  ch = s.charCodeAt(4);\n  if (ch !== 105 && ch !== 73) return false;\n  ch = s.charCodeAt(5);\n  if (ch !== 101 && ch !== 69) return false;\n  return true;\n}\n\nvar dateCache;\nfunction utcDate() {\n  if (!dateCache) {\n    var d = new Date();\n    dateCache = d.toUTCString();\n    timers.enroll(utcDate, 1000 - d.getMilliseconds());\n    timers._unrefActive(utcDate);\n  }\n  return dateCache;\n}\nutcDate._onTimeout = function _onTimeout() {\n  dateCache = undefined;\n};\n\n\nfunction noopPendingOutput(amount) {}\n\n\nfunction OutgoingMessage() {\n  Stream.call(this);\n\n  // Queue that holds all currently pending data, until the response will be\n  // assigned to the socket (until it will its turn in the HTTP pipeline).\n  this.output = [];\n  this.outputEncodings = [];\n  this.outputCallbacks = [];\n\n  // `outputSize` is an approximate measure of how much data is queued on this\n  // response. `_onPendingData` will be invoked to update similar global\n  // per-connection counter. That counter will be used to pause/unpause the\n  // TCP socket and HTTP Parser and thus handle the backpressure.\n  this.outputSize = 0;\n\n  this.writable = true;\n\n  this._last = false;\n  this.upgrading = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n  this._removedConnection = false;\n  this._removedContLen = false;\n  this._removedTE = false;\n\n  this._contentLength = null;\n  this._hasBody = true;\n  this._trailer = '';\n\n  this.finished = false;\n  this._headerSent = false;\n\n  this.socket = null;\n  this.connection = null;\n  this._header = null;\n  this[outHeadersKey] = null;\n\n  this._onPendingData = noopPendingOutput;\n}\nutil.inherits(OutgoingMessage, Stream);\n\n\nObject.defineProperty(OutgoingMessage.prototype, '_headers', {\n  get: function() {\n    return this.getHeaders();\n  },\n  set: function(val) {\n    if (val == null) {\n      this[outHeadersKey] = null;\n    } else if (typeof val === 'object') {\n      const headers = this[outHeadersKey] = {};\n      const keys = Object.keys(val);\n      for (var i = 0; i < keys.length; ++i) {\n        const name = keys[i];\n        headers[name.toLowerCase()] = [name, val[name]];\n      }\n    }\n  }\n});\n\nObject.defineProperty(OutgoingMessage.prototype, '_headerNames', {\n  get: function() {\n    const headers = this[outHeadersKey];\n    if (headers) {\n      const out = Object.create(null);\n      const keys = Object.keys(headers);\n      for (var i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const val = headers[key][0];\n        out[key] = val;\n      }\n      return out;\n    } else {\n      return headers;\n    }\n  },\n  set: function(val) {\n    if (typeof val === 'object' && val !== null) {\n      const headers = this[outHeadersKey];\n      if (!headers)\n        return;\n      const keys = Object.keys(val);\n      for (var i = 0; i < keys.length; ++i) {\n        const header = headers[keys[i]];\n        if (header)\n          header[0] = val[keys[i]];\n      }\n    }\n  }\n});\n\n\nOutgoingMessage.prototype._renderHeaders = function _renderHeaders() {\n  if (this._header) {\n    throw new Error('Can\\'t render headers after they are sent to the client');\n  }\n\n  var headersMap = this[outHeadersKey];\n  if (!headersMap) return {};\n\n  var headers = {};\n  var keys = Object.keys(headersMap);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    headers[headersMap[key][0]] = headersMap[key][1];\n  }\n  return headers;\n};\n\n\nexports.OutgoingMessage = OutgoingMessage;\n\n\nOutgoingMessage.prototype.setTimeout = function setTimeout(msecs, callback) {\n\n  if (callback) {\n    this.on('timeout', callback);\n  }\n\n  if (!this.socket) {\n    this.once('socket', function(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else {\n    this.socket.setTimeout(msecs);\n  }\n  return this;\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nOutgoingMessage.prototype.destroy = function destroy(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n  else\n    this.once('socket', function(socket) {\n      socket.destroy(error);\n    });\n};\n\n\n// This abstract either writing directly to the socket or buffering it.\nOutgoingMessage.prototype._send = function _send(data, encoding, callback) {\n  // This is a shameful hack to get the headers and first body chunk onto\n  // the same packet. Future versions of Node are going to take care of\n  // this at a lower level and in a more general way.\n  if (!this._headerSent) {\n    if (typeof data === 'string' &&\n        (encoding === 'utf8' || encoding === 'latin1' || !encoding)) {\n      data = this._header + data;\n    } else {\n      var header = this._header;\n      if (this.output.length === 0) {\n        this.output = [header];\n        this.outputEncodings = ['latin1'];\n        this.outputCallbacks = [null];\n      } else {\n        this.output.unshift(header);\n        this.outputEncodings.unshift('latin1');\n        this.outputCallbacks.unshift(null);\n      }\n      this.outputSize += header.length;\n      this._onPendingData(header.length);\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data, encoding, callback);\n};\n\n\nOutgoingMessage.prototype._writeRaw = _writeRaw;\nfunction _writeRaw(data, encoding, callback) {\n  const conn = this.connection;\n  if (conn && conn.destroyed) {\n    // The socket was destroyed. If we're still trying to write to it,\n    // then we haven't gotten the 'close' event yet.\n    return false;\n  }\n\n  if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (conn && conn._httpMessage === this && conn.writable && !conn.destroyed) {\n    // There might be pending data in the this.output buffer.\n    if (this.output.length) {\n      this._flushOutput(conn);\n    } else if (!data.length) {\n      if (typeof callback === 'function') {\n        nextTick(this.socket[async_id_symbol], callback);\n      }\n      return true;\n    }\n    // Directly write to socket.\n    return conn.write(data, encoding, callback);\n  }\n  // Buffer, as long as we're not destroyed.\n  this.output.push(data);\n  this.outputEncodings.push(encoding);\n  this.outputCallbacks.push(callback);\n  this.outputSize += data.length;\n  this._onPendingData(data.length);\n  return false;\n}\n\n\nOutgoingMessage.prototype._storeHeader = _storeHeader;\nfunction _storeHeader(firstLine, headers) {\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\r\\n'\n  // in the case of response it is: 'HTTP/1.1 200 OK\\r\\n'\n  var state = {\n    connection: false,\n    connUpgrade: false,\n    contLen: false,\n    te: false,\n    date: false,\n    expect: false,\n    trailer: false,\n    upgrade: false,\n    header: firstLine\n  };\n\n  var field;\n  var key;\n  var value;\n  var i;\n  var j;\n  if (headers === this[outHeadersKey]) {\n    for (key in headers) {\n      var entry = headers[key];\n      field = entry[0];\n      value = entry[1];\n\n      if (value instanceof Array) {\n        if (value.length < 2 || !isCookieField(field)) {\n          for (j = 0; j < value.length; j++)\n            storeHeader(this, state, field, value[j], false);\n          continue;\n        }\n        value = value.join('; ');\n      }\n      storeHeader(this, state, field, value, false);\n    }\n  } else if (headers instanceof Array) {\n    for (i = 0; i < headers.length; i++) {\n      field = headers[i][0];\n      value = headers[i][1];\n\n      if (value instanceof Array) {\n        for (j = 0; j < value.length; j++) {\n          storeHeader(this, state, field, value[j], true);\n        }\n      } else {\n        storeHeader(this, state, field, value, true);\n      }\n    }\n  } else if (headers) {\n    var keys = Object.keys(headers);\n    for (i = 0; i < keys.length; i++) {\n      field = keys[i];\n      value = headers[field];\n\n      if (value instanceof Array) {\n        if (value.length < 2 || !isCookieField(field)) {\n          for (j = 0; j < value.length; j++)\n            storeHeader(this, state, field, value[j], true);\n          continue;\n        }\n        value = value.join('; ');\n      }\n      storeHeader(this, state, field, value, true);\n    }\n  }\n\n  // Are we upgrading the connection?\n  if (state.connUpgrade && state.upgrade)\n    this.upgrading = true;\n\n  // Date header\n  if (this.sendDate && !state.date) {\n    state.header += 'Date: ' + utcDate() + CRLF;\n  }\n\n  // Force the connection to close when the response is a 204 No Content or\n  // a 304 Not Modified and the user has set a \"Transfer-Encoding: chunked\"\n  // header.\n  //\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\n  // node.js used to send out a zero chunk anyway to accommodate clients\n  // that don't have special handling for those responses.\n  //\n  // It was pointed out that this might confuse reverse proxies to the point\n  // of creating security liabilities, so suppress the zero chunk and force\n  // the connection to close.\n  var statusCode = this.statusCode;\n  if ((statusCode === 204 || statusCode === 304) && this.chunkedEncoding) {\n    debug(statusCode + ' response should not use chunked encoding,' +\n          ' closing connection.');\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n\n  // keep-alive logic\n  if (this._removedConnection) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n  } else if (!state.connection) {\n    var shouldSendKeepAlive = this.shouldKeepAlive &&\n        (state.contLen || this.useChunkedEncodingByDefault || this.agent);\n    if (shouldSendKeepAlive) {\n      state.header += 'Connection: keep-alive\\r\\n';\n    } else {\n      this._last = true;\n      state.header += 'Connection: close\\r\\n';\n    }\n  }\n\n  if (!state.contLen && !state.te) {\n    if (!this._hasBody) {\n      // Make sure we don't end the 0\\r\\n\\r\\n at the end of the message.\n      this.chunkedEncoding = false;\n    } else if (!this.useChunkedEncodingByDefault) {\n      this._last = true;\n    } else {\n      if (!state.trailer &&\n          !this._removedContLen &&\n          typeof this._contentLength === 'number') {\n        state.header += 'Content-Length: ' + this._contentLength + CRLF;\n      } else if (!this._removedTE) {\n        state.header += 'Transfer-Encoding: chunked\\r\\n';\n        this.chunkedEncoding = true;\n      } else {\n        // We should only be able to get here if both Content-Length and\n        // Transfer-Encoding are removed by the user.\n        // See: test/parallel/test-http-remove-header-stays-removed.js\n        debug('Both Content-Length and Transfer-Encoding are removed');\n      }\n    }\n  }\n\n  this._header = state.header + CRLF;\n  this._headerSent = false;\n\n  // wait until the first body chunk, or close(), is sent to flush,\n  // UNLESS we're sending Expect: 100-continue.\n  if (state.expect) this._send('');\n}\n\nfunction storeHeader(self, state, key, value, validate) {\n  if (validate) {\n    if (typeof key !== 'string' || !key || !checkIsHttpToken(key)) {\n      throw new TypeError(\n        'Header name must be a valid HTTP Token [\"' + key + '\"]');\n    }\n    if (value === undefined) {\n      throw new Error('Header \"%s\" value must not be undefined', key);\n    } else if (checkInvalidHeaderChar(value)) {\n      debug('Header \"%s\" contains invalid characters', key);\n      throw new TypeError('The header content contains invalid characters');\n    }\n  }\n  state.header += key + ': ' + escapeHeaderValue(value) + CRLF;\n  matchHeader(self, state, key, value);\n}\n\nfunction matchConnValue(self, state, value) {\n  var sawClose = false;\n  var m = RE_CONN_VALUES.exec(value);\n  while (m) {\n    if (m[0].length === 5)\n      sawClose = true;\n    else\n      state.connUpgrade = true;\n    m = RE_CONN_VALUES.exec(value);\n  }\n  if (sawClose)\n    self._last = true;\n  else\n    self.shouldKeepAlive = true;\n}\n\nfunction matchHeader(self, state, field, value) {\n  var m = RE_FIELDS.exec(field);\n  if (!m)\n    return;\n  var len = m[0].length;\n  if (len === 10) {\n    state.connection = true;\n    matchConnValue(self, state, value);\n  } else if (len === 17) {\n    state.te = true;\n    if (RE_TE_CHUNKED.test(value)) self.chunkedEncoding = true;\n  } else if (len === 14) {\n    state.contLen = true;\n  } else if (len === 4) {\n    state.date = true;\n  } else if (len === 6) {\n    state.expect = true;\n  } else if (len === 7) {\n    var ch = m[0].charCodeAt(0);\n    if (ch === 85 || ch === 117)\n      state.upgrade = true;\n    else\n      state.trailer = true;\n  }\n}\n\nfunction validateHeader(msg, name, value) {\n  if (typeof name !== 'string' || !name || !checkIsHttpToken(name))\n    throw new TypeError(\n      'Header name must be a valid HTTP Token [\"' + name + '\"]');\n  if (value === undefined)\n    throw new Error('\"value\" required in setHeader(\"' + name + '\", value)');\n  if (msg._header)\n    throw new Error('Can\\'t set headers after they are sent.');\n  if (checkInvalidHeaderChar(value)) {\n    debug('Header \"%s\" contains invalid characters', name);\n    throw new TypeError('The header content contains invalid characters');\n  }\n}\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  validateHeader(this, name, value);\n\n  if (!this[outHeadersKey])\n    this[outHeadersKey] = {};\n\n  const key = name.toLowerCase();\n  this[outHeadersKey][key] = [name, value];\n\n  switch (key.length) {\n    case 10:\n      if (key === 'connection')\n        this._removedConnection = false;\n      break;\n    case 14:\n      if (key === 'content-length')\n        this._removedContLen = false;\n      break;\n    case 17:\n      if (key === 'transfer-encoding')\n        this._removedTE = false;\n      break;\n  }\n};\n\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  if (typeof name !== 'string') {\n    throw new TypeError('\"name\" argument must be a string');\n  }\n\n  if (!this[outHeadersKey]) return;\n\n  var entry = this[outHeadersKey][name.toLowerCase()];\n  if (!entry)\n    return;\n  return entry[1];\n};\n\n\n// Returns an array of the names of the current outgoing headers.\nOutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {\n  return (this[outHeadersKey] ? Object.keys(this[outHeadersKey]) : []);\n};\n\n\n// Returns a shallow copy of the current outgoing headers.\nOutgoingMessage.prototype.getHeaders = function getHeaders() {\n  const headers = this[outHeadersKey];\n  const ret = Object.create(null);\n  if (headers) {\n    const keys = Object.keys(headers);\n    for (var i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const val = headers[key][1];\n      ret[key] = val;\n    }\n  }\n  return ret;\n};\n\n\nOutgoingMessage.prototype.hasHeader = function hasHeader(name) {\n  if (typeof name !== 'string') {\n    throw new TypeError('\"name\" argument must be a string');\n  }\n\n  return !!(this[outHeadersKey] && this[outHeadersKey][name.toLowerCase()]);\n};\n\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  if (typeof name !== 'string') {\n    throw new TypeError('\"name\" argument must be a string');\n  }\n\n  if (this._header) {\n    throw new Error('Can\\'t remove headers after they are sent');\n  }\n\n  var key = name.toLowerCase();\n\n  switch (key.length) {\n    case 10:\n      if (key === 'connection')\n        this._removedConnection = true;\n      break;\n    case 14:\n      if (key === 'content-length')\n        this._removedContLen = true;\n      break;\n    case 17:\n      if (key === 'transfer-encoding')\n        this._removedTE = true;\n      break;\n    case 4:\n      if (key === 'date')\n        this.sendDate = false;\n      break;\n  }\n\n  if (this[outHeadersKey]) {\n    delete this[outHeadersKey][key];\n  }\n};\n\n\nOutgoingMessage.prototype._implicitHeader = function _implicitHeader() {\n  throw new Error('_implicitHeader() method is not implemented');\n};\n\nObject.defineProperty(OutgoingMessage.prototype, 'headersSent', {\n  configurable: true,\n  enumerable: true,\n  get: function() { return !!this._header; }\n});\n\n\nconst crlf_buf = Buffer.from('\\r\\n');\nOutgoingMessage.prototype.write = function write(chunk, encoding, callback) {\n  return write_(this, chunk, encoding, callback, false);\n};\n\nfunction write_(msg, chunk, encoding, callback, fromEnd) {\n  if (msg.finished) {\n    var err = new Error('write after end');\n    nextTick(msg.socket[async_id_symbol],\n             writeAfterEndNT.bind(msg),\n             err,\n             callback);\n\n    return true;\n  }\n\n  if (!msg._header) {\n    msg._implicitHeader();\n  }\n\n  if (!msg._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring write() calls.');\n    return true;\n  }\n\n  if (!fromEnd && typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\n    throw new TypeError('First argument must be a string or Buffer');\n  }\n\n\n  // If we get an empty string or buffer, then just do nothing, and\n  // signal the user to keep writing.\n  if (chunk.length === 0) return true;\n\n  var len, ret;\n  if (msg.chunkedEncoding) {\n    if (typeof chunk === 'string')\n      len = Buffer.byteLength(chunk, encoding);\n    else\n      len = chunk.length;\n\n    if (msg.connection && !msg.connection.corked) {\n      msg.connection.cork();\n      process.nextTick(connectionCorkNT, msg.connection);\n    }\n\n    msg._send(len.toString(16), 'latin1', null);\n    msg._send(crlf_buf, null, null);\n    msg._send(chunk, encoding, null);\n    ret = msg._send(crlf_buf, null, callback);\n  } else {\n    ret = msg._send(chunk, encoding, callback);\n  }\n\n  debug('write ret = ' + ret);\n  return ret;\n}\n\n\nfunction writeAfterEndNT(err, callback) {\n  this.emit('error', err);\n  if (callback) callback(err);\n}\n\n\nfunction connectionCorkNT(conn) {\n  conn.uncork();\n}\n\n\nfunction escapeHeaderValue(value) {\n  // Protect against response splitting. The regex test is there to\n  // minimize the performance impact in the common case.\n  return /[\\r\\n]/.test(value) ? value.replace(/[\\r\\n]+[ \\t]*/g, '') : value;\n}\n\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(headers) {\n  this._trailer = '';\n  var keys = Object.keys(headers);\n  var isArray = Array.isArray(headers);\n  var field, value;\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n    if (typeof field !== 'string' || !field || !checkIsHttpToken(field)) {\n      throw new TypeError(\n        'Trailer name must be a valid HTTP Token [\"' + field + '\"]');\n    }\n    if (checkInvalidHeaderChar(value)) {\n      debug('Trailer \"%s\" contains invalid characters', field);\n      throw new TypeError('The trailer content contains invalid characters');\n    }\n    this._trailer += field + ': ' + escapeHeaderValue(value) + CRLF;\n  }\n};\n\nfunction onFinish(outmsg) {\n  outmsg.emit('finish');\n}\n\nOutgoingMessage.prototype.end = function end(chunk, encoding, callback) {\n  if (typeof chunk === 'function') {\n    callback = chunk;\n    chunk = null;\n  } else if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (this.finished) {\n    return false;\n  }\n\n  var uncork;\n  if (chunk) {\n    if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\n      throw new TypeError('First argument must be a string or Buffer');\n    }\n    if (!this._header) {\n      if (typeof chunk === 'string')\n        this._contentLength = Buffer.byteLength(chunk, encoding);\n      else\n        this._contentLength = chunk.length;\n    }\n    if (this.connection) {\n      this.connection.cork();\n      uncork = true;\n    }\n    write_(this, chunk, encoding, null, true);\n  } else if (!this._header) {\n    this._contentLength = 0;\n    this._implicitHeader();\n  }\n\n  if (typeof callback === 'function')\n    this.once('finish', callback);\n\n  var finish = onFinish.bind(undefined, this);\n\n  var ret;\n  if (this._hasBody && this.chunkedEncoding) {\n    ret = this._send('0\\r\\n' + this._trailer + '\\r\\n', 'latin1', finish);\n  } else {\n    // Force a flush, HACK.\n    ret = this._send('', 'latin1', finish);\n  }\n\n  if (uncork)\n    this.connection.uncork();\n\n  this.finished = true;\n\n  // There is the first message on the outgoing queue, and we've sent\n  // everything to the socket.\n  debug('outgoing message end.');\n  if (this.output.length === 0 &&\n      this.connection &&\n      this.connection._httpMessage === this) {\n    this._finish();\n  }\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype._finish = function _finish() {\n  assert(this.connection);\n  this.emit('prefinish');\n};\n\n\n// This logic is probably a bit confusing. Let me explain a bit:\n//\n// In both HTTP servers and clients it is possible to queue up several\n// outgoing messages. This is easiest to imagine in the case of a client.\n// Take the following situation:\n//\n//    req1 = client.request('GET', '/');\n//    req2 = client.request('POST', '/');\n//\n// When the user does\n//\n//   req2.write('hello world\\n');\n//\n// it's possible that the first request has not been completely flushed to\n// the socket yet. Thus the outgoing messages need to be prepared to queue\n// up data internally before sending it on further to the socket's queue.\n//\n// This function, outgoingFlush(), is called by both the Server and Client\n// to attempt to flush any pending messages out to the socket.\nOutgoingMessage.prototype._flush = function _flush() {\n  var socket = this.socket;\n  var ret;\n\n  if (socket && socket.writable) {\n    // There might be remaining data in this.output; write it out\n    ret = this._flushOutput(socket);\n\n    if (this.finished) {\n      // This is a queue to the server or client to bring in the next this.\n      this._finish();\n    } else if (ret) {\n      // This is necessary to prevent https from breaking\n      this.emit('drain');\n    }\n  }\n};\n\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\n  var ret;\n  var outputLength = this.output.length;\n  if (outputLength <= 0)\n    return ret;\n\n  var output = this.output;\n  var outputEncodings = this.outputEncodings;\n  var outputCallbacks = this.outputCallbacks;\n  socket.cork();\n  for (var i = 0; i < outputLength; i++) {\n    ret = socket.write(output[i], outputEncodings[i], outputCallbacks[i]);\n  }\n  socket.uncork();\n\n  this.output = [];\n  this.outputEncodings = [];\n  this.outputCallbacks = [];\n  this._onPendingData(-this.outputSize);\n  this.outputSize = 0;\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype.flushHeaders = function flushHeaders() {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  // Force-flush the headers.\n  this._send('');\n};\n\nOutgoingMessage.prototype.flush = internalUtil.deprecate(function() {\n  this.flushHeaders();\n}, 'OutgoingMessage.flush is deprecated. Use flushHeaders instead.', 'DEP0001');\n\n\nmodule.exports = {\n  OutgoingMessage\n};\n",
  "_http_server": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst net = require('net');\nconst HTTPParser = process.binding('http_parser').HTTPParser;\nconst assert = require('assert').ok;\nconst common = require('_http_common');\nconst parsers = common.parsers;\nconst freeParser = common.freeParser;\nconst debug = common.debug;\nconst CRLF = common.CRLF;\nconst continueExpression = common.continueExpression;\nconst chunkExpression = common.chunkExpression;\nconst httpSocketSetup = common.httpSocketSetup;\nconst OutgoingMessage = require('_http_outgoing').OutgoingMessage;\nconst { outHeadersKey, ondrain } = require('internal/http');\n\nconst STATUS_CODES = {\n  100: 'Continue',\n  101: 'Switching Protocols',\n  102: 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n  200: 'OK',\n  201: 'Created',\n  202: 'Accepted',\n  203: 'Non-Authoritative Information',\n  204: 'No Content',\n  205: 'Reset Content',\n  206: 'Partial Content',\n  207: 'Multi-Status',               // RFC 4918\n  208: 'Already Reported',\n  226: 'IM Used',\n  300: 'Multiple Choices',\n  301: 'Moved Permanently',\n  302: 'Found',\n  303: 'See Other',\n  304: 'Not Modified',\n  305: 'Use Proxy',\n  307: 'Temporary Redirect',\n  308: 'Permanent Redirect',         // RFC 7238\n  400: 'Bad Request',\n  401: 'Unauthorized',\n  402: 'Payment Required',\n  403: 'Forbidden',\n  404: 'Not Found',\n  405: 'Method Not Allowed',\n  406: 'Not Acceptable',\n  407: 'Proxy Authentication Required',\n  408: 'Request Timeout',\n  409: 'Conflict',\n  410: 'Gone',\n  411: 'Length Required',\n  412: 'Precondition Failed',\n  413: 'Payload Too Large',\n  414: 'URI Too Long',\n  415: 'Unsupported Media Type',\n  416: 'Range Not Satisfiable',\n  417: 'Expectation Failed',\n  418: 'I\\'m a teapot',              // RFC 2324\n  421: 'Misdirected Request',\n  422: 'Unprocessable Entity',       // RFC 4918\n  423: 'Locked',                     // RFC 4918\n  424: 'Failed Dependency',          // RFC 4918\n  425: 'Unordered Collection',       // RFC 4918\n  426: 'Upgrade Required',           // RFC 2817\n  428: 'Precondition Required',      // RFC 6585\n  429: 'Too Many Requests',          // RFC 6585\n  431: 'Request Header Fields Too Large', // RFC 6585\n  451: 'Unavailable For Legal Reasons',\n  500: 'Internal Server Error',\n  501: 'Not Implemented',\n  502: 'Bad Gateway',\n  503: 'Service Unavailable',\n  504: 'Gateway Timeout',\n  505: 'HTTP Version Not Supported',\n  506: 'Variant Also Negotiates',    // RFC 2295\n  507: 'Insufficient Storage',       // RFC 4918\n  508: 'Loop Detected',\n  509: 'Bandwidth Limit Exceeded',\n  510: 'Not Extended',               // RFC 2774\n  511: 'Network Authentication Required' // RFC 6585\n};\n\nconst kOnExecute = HTTPParser.kOnExecute | 0;\n\n\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n\n  if (req.method === 'HEAD') this._hasBody = false;\n\n  this.sendDate = true;\n  this._sent100 = false;\n  this._expect_continue = false;\n\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);\n    this.shouldKeepAlive = false;\n  }\n}\nutil.inherits(ServerResponse, OutgoingMessage);\n\nServerResponse.prototype._finish = function _finish() {\n  ;\n  ;\n  ;\n  OutgoingMessage.prototype._finish.call(this);\n};\n\n\nServerResponse.prototype.statusCode = 200;\nServerResponse.prototype.statusMessage = undefined;\n\nfunction onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}\n\nServerResponse.prototype.assignSocket = function assignSocket(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on('close', onServerResponseClose);\n  this.socket = socket;\n  this.connection = socket;\n  this.emit('socket', socket);\n  this._flush();\n};\n\nServerResponse.prototype.detachSocket = function detachSocket(socket) {\n  assert(socket._httpMessage === this);\n  socket.removeListener('close', onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = this.connection = null;\n};\n\nServerResponse.prototype.writeContinue = function writeContinue(cb) {\n  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);\n  this._sent100 = true;\n};\n\nServerResponse.prototype._implicitHeader = function _implicitHeader() {\n  this.writeHead(this.statusCode);\n};\n\nServerResponse.prototype.writeHead = writeHead;\nfunction writeHead(statusCode, reason, obj) {\n  var originalStatusCode = statusCode;\n\n  statusCode |= 0;\n  if (statusCode < 100 || statusCode > 999)\n    throw new RangeError(`Invalid status code: ${originalStatusCode}`);\n\n  if (typeof reason === 'string') {\n    // writeHead(statusCode, reasonPhrase[, headers])\n    this.statusMessage = reason;\n  } else {\n    // writeHead(statusCode[, headers])\n    if (!this.statusMessage)\n      this.statusMessage = STATUS_CODES[statusCode] || 'unknown';\n    obj = reason;\n  }\n  this.statusCode = statusCode;\n\n  var headers;\n  if (this[outHeadersKey]) {\n    // Slow-case: when progressive API and header fields are passed.\n    var k;\n    if (obj) {\n      var keys = Object.keys(obj);\n      for (var i = 0; i < keys.length; i++) {\n        k = keys[i];\n        if (k) this.setHeader(k, obj[k]);\n      }\n    }\n    if (k === undefined) {\n      if (this._header) {\n        throw new Error('Can\\'t render headers after they are sent to the ' +\n                        'client');\n      }\n    }\n    // only progressive api is used\n    headers = this[outHeadersKey];\n  } else {\n    // only writeHead() called\n    headers = obj;\n  }\n\n  if (common._checkInvalidHeaderChar(this.statusMessage))\n    throw new Error('Invalid character in statusMessage.');\n\n  var statusLine = 'HTTP/1.1 ' + statusCode + ' ' + this.statusMessage + CRLF;\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (statusCode >= 100 && statusCode <= 199)) {\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response,\n    // consisting only of the Status-Line and optional headers, and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  this._storeHeader(statusLine, headers);\n}\n\n// Docs-only deprecated: DEP0063\nServerResponse.prototype.writeHeader = ServerResponse.prototype.writeHead;\n\n\nfunction Server(requestListener) {\n  if (!(this instanceof Server)) return new Server(requestListener);\n  net.Server.call(this, { allowHalfOpen: true });\n\n  if (requestListener) {\n    this.on('request', requestListener);\n  }\n\n  // Similar option to this. Too lazy to write my own docs.\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n  this.httpAllowHalfOpen = false;\n\n  this.on('connection', connectionListener);\n\n  this.timeout = 2 * 60 * 1000;\n  this.keepAliveTimeout = 5000;\n  this._pendingResponseData = 0;\n  this.maxHeadersCount = null;\n}\nutil.inherits(Server, net.Server);\n\n\nServer.prototype.setTimeout = function setTimeout(msecs, callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on('timeout', callback);\n  return this;\n};\n\n\nfunction connectionListener(socket) {\n  debug('SERVER new http connection');\n\n  httpSocketSetup(socket);\n\n  // If the user has added a listener to the server,\n  // request, or response, then it's their responsibility.\n  // otherwise, destroy on timeout by default\n  if (this.timeout)\n    socket.setTimeout(this.timeout);\n  socket.on('timeout', socketOnTimeout);\n\n  var parser = parsers.alloc();\n  parser.reinitialize(HTTPParser.REQUEST);\n  parser.socket = socket;\n  socket.parser = parser;\n  parser.incoming = null;\n\n  // Propagate headers limit from server instance to parser\n  if (typeof this.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = this.maxHeadersCount << 1;\n  } else {\n    // Set default value because parser may be reused from FreeList\n    parser.maxHeaderPairs = 2000;\n  }\n\n  var state = {\n    onData: null,\n    onEnd: null,\n    onClose: null,\n    onDrain: null,\n    outgoing: [],\n    incoming: [],\n    // `outgoingData` is an approximate amount of bytes queued through all\n    // inactive responses. If more data than the high watermark is queued - we\n    // need to pause TCP socket/HTTP parser, and wait until the data will be\n    // sent to the client.\n    outgoingData: 0,\n    keepAliveTimeoutSet: false\n  };\n  state.onData = socketOnData.bind(undefined, this, socket, parser, state);\n  state.onEnd = socketOnEnd.bind(undefined, this, socket, parser, state);\n  state.onClose = socketOnClose.bind(undefined, socket, state);\n  state.onDrain = socketOnDrain.bind(undefined, socket, state);\n  socket.on('data', state.onData);\n  socket.on('error', socketOnError);\n  socket.on('end', state.onEnd);\n  socket.on('close', state.onClose);\n  socket.on('drain', state.onDrain);\n  parser.onIncoming = parserOnIncoming.bind(undefined, this, socket, state);\n\n  // We are consuming socket, so it won't get any actual data\n  socket.on('resume', onSocketResume);\n  socket.on('pause', onSocketPause);\n\n  // Override on to unconsume on `data`, `readable` listeners\n  socket.on = socketOnWrap;\n\n  // We only consume the socket if it has never been consumed before.\n  var external = socket._handle._externalStream;\n  if (!socket._handle._consumed && external) {\n    parser._consumed = true;\n    socket._handle._consumed = true;\n    parser.consume(external);\n  }\n  parser[kOnExecute] =\n    onParserExecute.bind(undefined, this, socket, parser, state);\n\n  socket._paused = false;\n}\n\n\nfunction updateOutgoingData(socket, state, delta) {\n  state.outgoingData += delta;\n  if (socket._paused &&\n      state.outgoingData < socket._writableState.highWaterMark) {\n    return socketOnDrain(socket, state);\n  }\n}\n\nfunction socketOnDrain(socket, state) {\n  var needPause = state.outgoingData > socket._writableState.highWaterMark;\n\n  // If we previously paused, then start reading again.\n  if (socket._paused && !needPause) {\n    socket._paused = false;\n    if (socket.parser)\n      socket.parser.resume();\n    socket.resume();\n  }\n}\n\nfunction socketOnTimeout() {\n  var req = this.parser && this.parser.incoming;\n  var reqTimeout = req && !req.complete && req.emit('timeout', this);\n  var res = this._httpMessage;\n  var resTimeout = res && res.emit('timeout', this);\n  var serverTimeout = this.server.emit('timeout', this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n}\n\nfunction socketOnClose(socket, state) {\n  debug('server socket close');\n  // mark this parser as reusable\n  if (socket.parser) {\n    freeParser(socket.parser, null, socket);\n  }\n\n  abortIncoming(state.incoming);\n}\n\nfunction abortIncoming(incoming) {\n  while (incoming.length) {\n    var req = incoming.shift();\n    req.emit('aborted');\n    req.emit('close');\n  }\n  // abort socket._httpMessage ?\n}\n\nfunction socketOnEnd(server, socket, parser, state) {\n  var ret = parser.finish();\n\n  if (ret instanceof Error) {\n    debug('parse error');\n    socketOnError.call(socket, ret);\n    return;\n  }\n\n  if (!server.httpAllowHalfOpen) {\n    abortIncoming(state.incoming);\n    if (socket.writable) socket.end();\n  } else if (state.outgoing.length) {\n    state.outgoing[state.outgoing.length - 1]._last = true;\n  } else if (socket._httpMessage) {\n    socket._httpMessage._last = true;\n  } else {\n    if (socket.writable) socket.end();\n  }\n}\n\nfunction socketOnData(server, socket, parser, state, d) {\n  assert(!socket._paused);\n  debug('SERVER socketOnData %d', d.length);\n\n  if (state.keepAliveTimeoutSet) {\n    socket.setTimeout(0);\n    if (server.timeout) {\n      socket.setTimeout(server.timeout);\n    }\n    state.keepAliveTimeoutSet = false;\n  }\n\n  var ret = parser.execute(d);\n  onParserExecuteCommon(server, socket, parser, state, ret, d);\n}\n\nfunction onParserExecute(server, socket, parser, state, ret, d) {\n  socket._unrefTimer();\n  debug('SERVER socketOnParserExecute %d', ret);\n  onParserExecuteCommon(server, socket, parser, state, ret, undefined);\n}\n\nfunction socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error', socketOnError);\n  this.on('error', () => {});\n\n  if (!this.server.emit('clientError', e, this))\n    this.destroy(e);\n}\n\nfunction onParserExecuteCommon(server, socket, parser, state, ret, d) {\n  if (ret instanceof Error) {\n    debug('parse error');\n    socketOnError.call(socket, ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    var bytesParsed = ret;\n    var req = parser.incoming;\n    debug('SERVER upgrade or connect', req.method);\n\n    if (!d)\n      d = parser.getCurrentBuffer();\n\n    socket.removeListener('data', state.onData);\n    socket.removeListener('end', state.onEnd);\n    socket.removeListener('close', state.onClose);\n    socket.removeListener('drain', state.onDrain);\n    socket.removeListener('drain', ondrain);\n    unconsume(parser, socket);\n    parser.finish();\n    freeParser(parser, req, null);\n    parser = null;\n\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (server.listenerCount(eventName) > 0) {\n      debug('SERVER have listener for %s', eventName);\n      var bodyHead = d.slice(bytesParsed, d.length);\n\n      // TODO(isaacs): Need a way to reset a stream to fresh state\n      // IE, not flowing, and not explicitly paused.\n      socket._readableState.flowing = null;\n      server.emit(eventName, req, socket, bodyHead);\n    } else {\n      // Got upgrade header or CONNECT method, but have no handler.\n      socket.destroy();\n    }\n  }\n\n  if (socket._paused && socket.parser) {\n    // onIncoming paused the socket, we should pause the parser as well\n    debug('pause parser');\n    socket.parser.pause();\n  }\n}\n\nfunction resOnFinish(req, res, socket, state, server) {\n  // Usually the first incoming element should be our request.  it may\n  // be that in the case abortIncoming() was called that the incoming\n  // array will be empty.\n  assert(state.incoming.length === 0 || state.incoming[0] === req);\n\n  state.incoming.shift();\n\n  // if the user never called req.read(), and didn't pipe() or\n  // .resume() or .on('data'), then we call req._dump() so that the\n  // bytes will be pulled off the wire.\n  if (!req._consuming && !req._readableState.resumeScheduled)\n    req._dump();\n\n  res.detachSocket(socket);\n\n  if (res._last) {\n    socket.destroySoon();\n  } else if (state.outgoing.length === 0) {\n    if (server.keepAliveTimeout) {\n      socket.setTimeout(0);\n      socket.setTimeout(server.keepAliveTimeout);\n      state.keepAliveTimeoutSet = true;\n    }\n  } else {\n    // start sending the next message\n    var m = state.outgoing.shift();\n    if (m) {\n      m.assignSocket(socket);\n    }\n  }\n}\n\n// The following callback is issued after the headers have been read on a\n// new message. In this callback we setup the response object and pass it\n// to the user.\nfunction parserOnIncoming(server, socket, state, req, keepAlive) {\n  state.incoming.push(req);\n\n  // If the writable end isn't consuming, then stop reading\n  // so that we don't become overwhelmed by a flood of\n  // pipelined requests that may never be resolved.\n  if (!socket._paused) {\n    var ws = socket._writableState;\n    if (ws.needDrain || state.outgoingData >= ws.highWaterMark) {\n      socket._paused = true;\n      // We also need to pause the parser, but don't do that until after\n      // the call to execute, because we may still be processing the last\n      // chunk.\n      socket.pause();\n    }\n  }\n\n  var res = new ServerResponse(req);\n  res._onPendingData = updateOutgoingData.bind(undefined, socket, state);\n\n  res.shouldKeepAlive = keepAlive;\n  ;\n  ;\n  ;\n\n  if (socket._httpMessage) {\n    // There are already pending outgoing res, append.\n    state.outgoing.push(res);\n  } else {\n    res.assignSocket(socket);\n  }\n\n  // When we're finished writing the response, check if this is the last\n  // response, if so destroy the socket.\n  res.on('finish',\n         resOnFinish.bind(undefined, req, res, socket, state, server));\n\n  if (req.headers.expect !== undefined &&\n      (req.httpVersionMajor === 1 && req.httpVersionMinor === 1)) {\n    if (continueExpression.test(req.headers.expect)) {\n      res._expect_continue = true;\n\n      if (server.listenerCount('checkContinue') > 0) {\n        server.emit('checkContinue', req, res);\n      } else {\n        res.writeContinue();\n        server.emit('request', req, res);\n      }\n    } else {\n      if (server.listenerCount('checkExpectation') > 0) {\n        server.emit('checkExpectation', req, res);\n      } else {\n        res.writeHead(417);\n        res.end();\n      }\n    }\n  } else {\n    server.emit('request', req, res);\n  }\n  return false; // Not a HEAD response. (Not even a response!)\n}\n\nfunction onSocketResume() {\n  // It may seem that the socket is resumed, but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously, and may be called from\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n}\n\nfunction onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}\n\nfunction unconsume(parser, socket) {\n  if (socket._handle) {\n    if (parser._consumed)\n      parser.unconsume(socket._handle._externalStream);\n    parser._consumed = false;\n    socket.removeListener('pause', onSocketPause);\n    socket.removeListener('resume', onSocketResume);\n  }\n}\n\nfunction socketOnWrap(ev, fn) {\n  var res = net.Socket.prototype.on.call(this, ev, fn);\n  if (!this.parser) {\n    this.on = net.Socket.prototype.on;\n    return res;\n  }\n\n  if (ev === 'data' || ev === 'readable')\n    unconsume(this.parser, this);\n\n  return res;\n}\n\nmodule.exports = {\n  STATUS_CODES,\n  Server,\n  ServerResponse,\n  _connectionListener: connectionListener\n};\n",
  "https": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nrequire('internal/util').assertCrypto();\n\nconst tls = require('tls');\nconst url = require('url');\nconst http = require('http');\nconst util = require('util');\nconst inherits = util.inherits;\nconst debug = util.debuglog('https');\nconst { urlToOptions, searchParamsSymbol } = require('internal/url');\n\nfunction Server(opts, requestListener) {\n  if (!(this instanceof Server)) return new Server(opts, requestListener);\n\n  if (process.features.tls_npn && !opts.NPNProtocols) {\n    opts.NPNProtocols = ['http/1.1', 'http/1.0'];\n  }\n\n  if (process.features.tls_alpn && !opts.ALPNProtocols) {\n    // http/1.0 is not defined as Protocol IDs in IANA\n    // http://www.iana.org/assignments/tls-extensiontype-values\n    //       /tls-extensiontype-values.xhtml#alpn-protocol-ids\n    opts.ALPNProtocols = ['http/1.1'];\n  }\n\n  tls.Server.call(this, opts, http._connectionListener);\n\n  this.httpAllowHalfOpen = false;\n\n  if (requestListener) {\n    this.addListener('request', requestListener);\n  }\n\n  this.addListener('tlsClientError', function addListener(err, conn) {\n    if (!this.emit('clientError', err, conn))\n      conn.destroy(err);\n  });\n\n  this.timeout = 2 * 60 * 1000;\n  this.keepAliveTimeout = 5000;\n}\ninherits(Server, tls.Server);\nexports.Server = Server;\n\nServer.prototype.setTimeout = http.Server.prototype.setTimeout;\n\nexports.createServer = function createServer(opts, requestListener) {\n  return new Server(opts, requestListener);\n};\n\n\n// HTTPS agents.\n\nfunction createConnection(port, host, options) {\n  if (port !== null && typeof port === 'object') {\n    options = port;\n  } else if (host !== null && typeof host === 'object') {\n    options = host;\n  } else if (options === null || typeof options !== 'object') {\n    options = {};\n  }\n\n  if (typeof port === 'number') {\n    options.port = port;\n  }\n\n  if (typeof host === 'string') {\n    options.host = host;\n  }\n\n  debug('createConnection', options);\n\n  if (options._agentKey) {\n    const session = this._getSession(options._agentKey);\n    if (session) {\n      debug('reuse session for %j', options._agentKey);\n      options = util._extend({\n        session: session\n      }, options);\n    }\n  }\n\n  const socket = tls.connect(options, () => {\n    if (!options._agentKey)\n      return;\n\n    this._cacheSession(options._agentKey, socket.getSession());\n  });\n\n  // Evict session on error\n  socket.once('close', (err) => {\n    if (err)\n      this._evictSession(options._agentKey);\n  });\n\n  return socket;\n}\n\n\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  http.Agent.call(this, options);\n  this.defaultPort = 443;\n  this.protocol = 'https:';\n  this.maxCachedSessions = this.options.maxCachedSessions;\n  if (this.maxCachedSessions === undefined)\n    this.maxCachedSessions = 100;\n\n  this._sessionCache = {\n    map: {},\n    list: []\n  };\n}\ninherits(Agent, http.Agent);\nAgent.prototype.createConnection = createConnection;\n\nAgent.prototype.getName = function getName(options) {\n  var name = http.Agent.prototype.getName.call(this, options);\n\n  name += ':';\n  if (options.ca)\n    name += options.ca;\n\n  name += ':';\n  if (options.cert)\n    name += options.cert;\n\n  name += ':';\n  if (options.ciphers)\n    name += options.ciphers;\n\n  name += ':';\n  if (options.key)\n    name += options.key;\n\n  name += ':';\n  if (options.pfx)\n    name += options.pfx;\n\n  name += ':';\n  if (options.rejectUnauthorized !== undefined)\n    name += options.rejectUnauthorized;\n\n  name += ':';\n  if (options.servername && options.servername !== options.host)\n    name += options.servername;\n\n  name += ':';\n  if (options.secureProtocol)\n    name += options.secureProtocol;\n\n  return name;\n};\n\nAgent.prototype._getSession = function _getSession(key) {\n  return this._sessionCache.map[key];\n};\n\nAgent.prototype._cacheSession = function _cacheSession(key, session) {\n  // Cache is disabled\n  if (this.maxCachedSessions === 0)\n    return;\n\n  // Fast case - update existing entry\n  if (this._sessionCache.map[key]) {\n    this._sessionCache.map[key] = session;\n    return;\n  }\n\n  // Put new entry\n  if (this._sessionCache.list.length >= this.maxCachedSessions) {\n    const oldKey = this._sessionCache.list.shift();\n    debug('evicting %j', oldKey);\n    delete this._sessionCache.map[oldKey];\n  }\n\n  this._sessionCache.list.push(key);\n  this._sessionCache.map[key] = session;\n};\n\nAgent.prototype._evictSession = function _evictSession(key) {\n  const index = this._sessionCache.list.indexOf(key);\n  if (index === -1)\n    return;\n\n  this._sessionCache.list.splice(index, 1);\n  delete this._sessionCache.map[key];\n};\n\nconst globalAgent = new Agent();\n\nexports.globalAgent = globalAgent;\nexports.Agent = Agent;\n\nexports.request = function request(options, cb) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n    if (!options.hostname) {\n      throw new Error('Unable to determine the domain name');\n    }\n  } else if (options && options[searchParamsSymbol] &&\n             options[searchParamsSymbol][searchParamsSymbol]) {\n    // url.URL instance\n    options = urlToOptions(options);\n  } else {\n    options = util._extend({}, options);\n  }\n  options._defaultAgent = globalAgent;\n  return http.request(options, cb);\n};\n\nexports.get = function get(options, cb) {\n  var req = exports.request(options, cb);\n  req.end();\n  return req;\n};\n",
  "inspector": "'use strict';\n\nconst connect = process.binding('inspector').connect;\nconst EventEmitter = require('events');\nconst util = require('util');\n\nif (!connect)\n  throw new Error('Inspector is not available');\n\nconst connectionSymbol = Symbol('connectionProperty');\nconst messageCallbacksSymbol = Symbol('messageCallbacks');\nconst nextIdSymbol = Symbol('nextId');\nconst onMessageSymbol = Symbol('onMessage');\n\nclass Session extends EventEmitter {\n  constructor() {\n    super();\n    this[connectionSymbol] = null;\n    this[nextIdSymbol] = 1;\n    this[messageCallbacksSymbol] = new Map();\n  }\n\n  connect() {\n    if (this[connectionSymbol])\n      throw new Error('Already connected');\n    this[connectionSymbol] =\n        connect((message) => this[onMessageSymbol](message));\n  }\n\n  [onMessageSymbol](message) {\n    const parsed = JSON.parse(message);\n    if (parsed.id) {\n      const callback = this[messageCallbacksSymbol].get(parsed.id);\n      this[messageCallbacksSymbol].delete(parsed.id);\n      if (callback)\n        callback(parsed.error || null, parsed.result || null);\n    } else {\n      this.emit(parsed.method, parsed);\n      this.emit('inspectorNotification', parsed);\n    }\n  }\n\n  post(method, params, callback) {\n    if (typeof method !== 'string')\n      throw new TypeError(\n          `\"method\" must be a string, got ${typeof method} instead`);\n    if (!callback && util.isFunction(params)) {\n      callback = params;\n      params = null;\n    }\n    if (params && typeof params !== 'object')\n      throw new TypeError(\n          `\"params\" must be an object, got ${typeof params} instead`);\n    if (callback && typeof callback !== 'function')\n      throw new TypeError(\n          `\"callback\" must be a function, got ${typeof callback} instead`);\n\n    if (!this[connectionSymbol])\n      throw new Error('Session is not connected');\n    const id = this[nextIdSymbol]++;\n    const message = {id, method};\n    if (params) {\n      message['params'] = params;\n    }\n    if (callback) {\n      this[messageCallbacksSymbol].set(id, callback);\n    }\n    this[connectionSymbol].dispatch(JSON.stringify(message));\n  }\n\n  disconnect() {\n    if (!this[connectionSymbol])\n      return;\n    this[connectionSymbol].disconnect();\n    this[connectionSymbol] = null;\n    const remainingCallbacks = this[messageCallbacksSymbol].values();\n    for (const callback of remainingCallbacks) {\n      process.nextTick(callback, new Error('Session was closed'));\n    }\n    this[messageCallbacksSymbol].clear();\n    this[nextIdSymbol] = 1;\n  }\n}\n\nmodule.exports = {\n  Session\n};\n",
  "module": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst NativeModule = require('native_module');\nconst util = require('util');\nconst internalModule = require('internal/module');\nconst vm = require('vm');\nconst assert = require('assert').ok;\nconst fs = require('fs');\nconst internalFS = require('internal/fs');\nconst path = require('path');\nconst internalModuleReadFile = process.binding('fs').internalModuleReadFile;\nconst internalModuleStat = process.binding('fs').internalModuleStat;\nconst preserveSymlinks = !!process.binding('config').preserveSymlinks;\n\nfunction stat(filename) {\n  filename = path._makeLong(filename);\n  const cache = stat.cache;\n  if (cache !== null) {\n    const result = cache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (cache !== null) cache.set(filename, result);\n  return result;\n}\nstat.cache = null;\n\n\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nmodule.exports = Module;\n\nModule._cache = Object.create(null);\nModule._pathCache = Object.create(null);\nModule._extensions = Object.create(null);\nvar modulePaths = [];\nModule.globalPaths = [];\n\nModule.wrapper = NativeModule.wrapper;\nModule.wrap = NativeModule.wrap;\nModule._debug = util.debuglog('module');\n\n// We use this alias for the preprocessor that filters it out\nconst debug = Module._debug;\n\n\n// given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\n// check if the directory is a package.json dir\nconst packageMainCache = Object.create(null);\n\nfunction readPackage(requestPath) {\n  const entry = packageMainCache[requestPath];\n  if (entry)\n    return entry;\n\n  const jsonPath = path.resolve(requestPath, 'package.json');\n  const json = internalModuleReadFile(path._makeLong(jsonPath));\n\n  if (json === undefined) {\n    return false;\n  }\n\n  try {\n    var pkg = packageMainCache[requestPath] = JSON.parse(json).main;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n  return pkg;\n}\n\nfunction tryPackage(requestPath, exts, isMain) {\n  var pkg = readPackage(requestPath);\n\n  if (!pkg) return false;\n\n  var filename = path.resolve(requestPath, pkg);\n  return tryFile(filename, isMain) ||\n         tryExtensions(filename, exts, isMain) ||\n         tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new Map();\n\n// check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false,\n// keep symlinks intact, otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (preserveSymlinks && !isMain) {\n    return rc === 0 && path.resolve(requestPath);\n  }\n  return rc === 0 && toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// given a path check a the file exists with any of the set extensions\nfunction tryExtensions(p, exts, isMain) {\n  for (var i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\nvar warned = false;\nModule._findPath = function(request, paths, isMain) {\n  if (path.isAbsolute(request)) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  var cacheKey = request + '\\x00' +\n                (paths.length === 1 ? paths[0] : paths.join('\\x00'));\n  var entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  var exts;\n  var trailingSlash = request.length > 0 &&\n                      request.charCodeAt(request.length - 1) === 47/*/*/;\n\n  // For each path\n  for (var i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n    var basePath = path.resolve(curPath, request);\n    var filename;\n\n    var rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (preserveSymlinks && !isMain) {\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      } else if (rc === 1) {  // Directory.\n        if (exts === undefined)\n          exts = Object.keys(Module._extensions);\n        filename = tryPackage(basePath, exts, isMain);\n      }\n\n      if (!filename) {\n        // try it with each of the extensions\n        if (exts === undefined)\n          exts = Object.keys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      if (exts === undefined)\n        exts = Object.keys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain);\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at \"index\"\n      if (exts === undefined)\n        exts = Object.keys(Module._extensions);\n      filename = tryExtensions(path.resolve(basePath, 'index'), exts, isMain);\n    }\n\n    if (filename) {\n      // Warn once if '.' resolved outside the module dir\n      if (request === '.' && i > 0) {\n        if (!warned) {\n          warned = true;\n          process.emitWarning(\n            'warning: require(\\'.\\') resolved outside the package ' +\n            'directory. This functionality is deprecated and will be removed ' +\n            'soon.',\n            'DeprecationWarning', 'DEP0019');\n        }\n      }\n\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n  return false;\n};\n\n// 'node_modules' character codes reversed\nvar nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ];\nvar nmLen = nmChars.length;\nif (process.platform === 'win32') {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (from.charCodeAt(from.length - 1) === 92/*\\*/ &&\n        from.charCodeAt(from.length - 2) === 58/*:*/)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    var p = 0;\n    var last = from.length;\n    for (var i = from.length - 1; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === 92/*\\*/ || code === 47/*/*/ || code === 58/*:*/) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '\\\\node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work, but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules', '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    var p = 0;\n    var last = from.length;\n    for (var i = from.length - 1; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '/node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    paths.push('/node_modules');\n\n    return paths;\n  };\n}\n\n\n// 'index.' character codes\nvar indexChars = [ 105, 110, 100, 101, 120, 46 ];\nvar indexLen = indexChars.length;\nModule._resolveLookupPaths = function(request, parent, newReturn) {\n  if (NativeModule.nonInternalExists(request)) {\n    debug('looking for %j in []', request);\n    return (newReturn ? null : [request, []]);\n  }\n\n  // Check for relative path\n  if (request.length < 2 ||\n      request.charCodeAt(0) !== 46/*.*/ ||\n      (request.charCodeAt(1) !== 46/*.*/ &&\n       request.charCodeAt(1) !== 47/*/*/)) {\n    var paths = modulePaths;\n    if (parent) {\n      if (!parent.paths)\n        paths = parent.paths = [];\n      else\n        paths = parent.paths.concat(paths);\n    }\n\n    // Maintain backwards compat with certain broken uses of require('.')\n    // by putting the module's directory in front of the lookup paths.\n    if (request === '.') {\n      if (parent && parent.filename) {\n        paths.unshift(path.dirname(parent.filename));\n      } else {\n        paths.unshift(path.resolve(request));\n      }\n    }\n\n    debug('looking for %j in %j', request, paths);\n    return (newReturn ? (paths.length > 0 ? paths : null) : [request, paths]);\n  }\n\n  // with --eval, parent.id is not set and parent.filename is null\n  if (!parent || !parent.id || !parent.filename) {\n    // make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but with eval there is no filename\n    var mainPaths = ['.'].concat(Module._nodeModulePaths('.'), modulePaths);\n\n    debug('looking for %j in %j', request, mainPaths);\n    return (newReturn ? mainPaths : [request, mainPaths]);\n  }\n\n  // Is the parent an index module?\n  // We can assume the parent has a valid extension,\n  // as it already has been accepted as a module.\n  const base = path.basename(parent.filename);\n  var parentIdPath;\n  if (base.length > indexLen) {\n    var i = 0;\n    for (; i < indexLen; ++i) {\n      if (indexChars[i] !== base.charCodeAt(i))\n        break;\n    }\n    if (i === indexLen) {\n      // We matched 'index.', let's validate the rest\n      for (; i < base.length; ++i) {\n        const code = base.charCodeAt(i);\n        if (code !== 95/*_*/ &&\n            (code < 48/*0*/ || code > 57/*9*/) &&\n            (code < 65/*A*/ || code > 90/*Z*/) &&\n            (code < 97/*a*/ || code > 122/*z*/))\n          break;\n      }\n      if (i === base.length) {\n        // Is an index module\n        parentIdPath = parent.id;\n      } else {\n        // Not an index module\n        parentIdPath = path.dirname(parent.id);\n      }\n    } else {\n      // Not an index module\n      parentIdPath = path.dirname(parent.id);\n    }\n  } else {\n    // Not an index module\n    parentIdPath = path.dirname(parent.id);\n  }\n  var id = path.resolve(parentIdPath, request);\n\n  // make sure require('./path') and require('path') get distinct ids, even\n  // when called from the toplevel js file\n  if (parentIdPath === '.' && id.indexOf('/') === -1) {\n    id = './' + id;\n  }\n\n  debug('RELATIVE: requested: %s set ID to: %s from %s', request, id,\n        parent.id);\n\n  var parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j in %j', id, parentDir);\n  return (newReturn ? parentDir : [id, parentDir]);\n};\n\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call `NativeModule.require()` with the\n//    filename and return the result.\n// 3. Otherwise, create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request, parent, isMain) {\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s', request, parent.id);\n  }\n\n  var filename = Module._resolveFilename(request, parent, isMain);\n\n  var cachedModule = Module._cache[filename];\n  if (cachedModule) {\n    return cachedModule.exports;\n  }\n\n  if (NativeModule.nonInternalExists(filename)) {\n    debug('load native module %s', request);\n    return NativeModule.require(filename);\n  }\n\n  var module = new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n\n  tryModuleLoad(module, filename);\n\n  return module.exports;\n};\n\nfunction tryModuleLoad(module, filename) {\n  var threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n    }\n  }\n}\n\nModule._resolveFilename = function(request, parent, isMain) {\n  if (NativeModule.nonInternalExists(request)) {\n    return request;\n  }\n\n  var paths = Module._resolveLookupPaths(request, parent, true);\n\n  // look up the filename first, since that's the cache key.\n  var filename = Module._findPath(request, paths, isMain);\n  if (!filename) {\n    var err = new Error(`Cannot find module '${request}'`);\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  }\n  return filename;\n};\n\n\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j', filename, this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  var extension = path.extname(filename) || '.js';\n  if (!Module._extensions[extension]) extension = '.js';\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(path) {\n  assert(path, 'missing path');\n  assert(typeof path === 'string', 'path must be a string');\n  return Module._load(path, this, /* isMain */ false);\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nvar resolvedArgv;\n\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require, module, exports) to\n// the file.\n// Returns exception, if any.\nModule.prototype._compile = function(content, filename) {\n\n  content = internalModule.stripShebang(content);\n\n  // create wrapper function\n  var wrapper = Module.wrap(content);\n\n  var compiledWrapper = vm.runInThisContext(wrapper, {\n    filename: filename,\n    lineOffset: 0,\n    displayErrors: true\n  });\n\n  var inspectorWrapper = null;\n  if (process._breakFirstLine && process._eval == null) {\n    if (!resolvedArgv) {\n      // we enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        resolvedArgv = Module._resolveFilename(process.argv[1], null, false);\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (filename === resolvedArgv) {\n      delete process._breakFirstLine;\n      inspectorWrapper = process.binding('inspector').callAndPauseOnStart;\n      if (!inspectorWrapper) {\n        const Debug = vm.runInDebugContext('Debug');\n        Debug.setBreakPoint(compiledWrapper, 0, 0);\n      }\n    }\n  }\n  var dirname = path.dirname(filename);\n  var require = internalModule.makeRequireFunction(this);\n  var depth = internalModule.requireDepth;\n  if (depth === 0) stat.cache = new Map();\n  var result;\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper, this.exports, this.exports,\n                              require, this, filename, dirname);\n  } else {\n    result = compiledWrapper.call(this.exports, this.exports, require, this,\n                                  filename, dirname);\n  }\n  if (depth === 0) stat.cache = null;\n  return result;\n};\n\n\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(internalModule.stripBOM(content), filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  try {\n    module.exports = JSON.parse(internalModule.stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n//Native extension for .node\nModule._extensions['.node'] = function(module, filename) {\n  return process.dlopen(module, path._makeLong(filename));\n};\n\n\n// bootstrap main module.\nModule.runMain = function() {\n  // Load the main module--the command line argument.\n  Module._load(process.argv[1], null, true);\n  // Handle any nextTicks added in the first tick of the program\n  process._tickCallback();\n};\n\nModule._initPaths = function() {\n  const isWindows = process.platform === 'win32';\n\n  var homeDir;\n  if (isWindows) {\n    homeDir = process.env.USERPROFILE;\n  } else {\n    homeDir = process.env.HOME;\n  }\n\n  // $PREFIX/lib/node, where $PREFIX is the root of the Node.js installation.\n  var prefixDir;\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe.\n  if (isWindows) {\n    prefixDir = path.resolve(process.execPath, '..');\n  } else {\n    prefixDir = path.resolve(process.execPath, '..', '..');\n  }\n  var paths = [path.resolve(prefixDir, 'lib', 'node')];\n\n  if (homeDir) {\n    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    paths.unshift(path.resolve(homeDir, '.node_modules'));\n  }\n\n  var nodePath = process.env['NODE_PATH'];\n  if (nodePath) {\n    paths = nodePath.split(path.delimiter).filter(function(path) {\n      return !!path;\n    }).concat(paths);\n  }\n\n  modulePaths = paths;\n\n  // clone as a shallow copy, for introspection.\n  Module.globalPaths = modulePaths.slice(0);\n};\n\nModule._preloadModules = function(requests) {\n  if (!Array.isArray(requests))\n    return;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  var parent = new Module('internal/preload', null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n  for (var n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n};\n\nModule._initPaths();\n\n// backwards compatibility\nModule.Module = Module;\n",
  "net": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nconst timers = require('timers');\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst internalNet = require('internal/net');\nconst assert = require('assert');\nconst cares = process.binding('cares_wrap');\nconst uv = process.binding('uv');\n\nconst Buffer = require('buffer').Buffer;\nconst TTYWrap = process.binding('tty_wrap');\nconst TCP = process.binding('tcp_wrap').TCP;\nconst Pipe = process.binding('pipe_wrap').Pipe;\nconst TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\nconst PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\nconst ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\nconst WriteWrap = process.binding('stream_wrap').WriteWrap;\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst { newUid, setInitTriggerId } = require('async_hooks');\nconst nextTick = require('internal/process/next_tick').nextTick;\n\nvar cluster;\nvar dns;\n\nconst errnoException = util._errnoException;\nconst exceptionWithHostPort = util._exceptionWithHostPort;\nconst isLegalPort = internalNet.isLegalPort;\nconst normalizedArgsSymbol = internalNet.normalizedArgsSymbol;\n\nfunction noop() {}\n\nfunction createHandle(fd) {\n  var type = TTYWrap.guessHandleType(fd);\n  if (type === 'PIPE') return new Pipe();\n  if (type === 'TCP') return new TCP();\n  throw new TypeError('Unsupported fd type: ' + type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n      newUid() : handle.getAsyncId();\n}\n\n\nconst debug = util.debuglog('net');\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\n\n// Target API:\n//\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nfunction connect() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  debug('createConnection', normalized);\n  var socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return Socket.prototype.connect.call(socket, normalized);\n}\n\n\n// Returns an array [options, cb], where options is an object,\n// cb is either a funciton or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of paramters:\n//   (options[...][, cb])\n//   (path[...][, cb])\n//   ([port][, host][...][, cb])\n// For Socket.prototype.connect(), the [...] part is ignored\n// For Server.prototype.listen(), the [...] part is [, backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  var arr;\n\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  var options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][, cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][, cb])\n    options.path = arg0;\n  } else {\n    // ([port][, host][...][, cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options, null];\n  else\n    arr = [options, cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._bytesDispatched = 0;\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle.owner = self;\n    self._handle.onread = onread;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    // If handle doesn't support writev - neither do we\n    if (!self._handle.writev)\n      self._writev = null;\n  }\n}\n\n\nconst BYTES_READ = Symbol('bytesRead');\n\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle, that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this._handle = null;\n  this._parent = null;\n  this._host = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else if (options === undefined)\n    options = {};\n\n  stream.Duplex.call(this, options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    this._handle = createHandle(options.fd);\n    this._handle.open(options.fd);\n    this[async_id_symbol] = this._handle.getAsyncId();\n    // options.fd can be string (since it is user-defined),\n    // so changing this to === would be semver-major\n    // See: https://github.com/nodejs/node/pull/11513\n    // eslint-disable-next-line eqeqeq\n    if ((options.fd == 1 || options.fd == 2) &&\n        (this._handle instanceof Pipe) &&\n        process.platform === 'win32') {\n      // Make stdout and stderr blocking on Windows\n      var err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n    }\n    this.readable = options.readable !== false;\n    this.writable = options.writable !== false;\n  } else {\n    // these will be set once there is a connection\n    this.readable = this.writable = false;\n  }\n\n  // shut down the socket when we're finished with it.\n  this.on('finish', onSocketFinish);\n  this.on('_socketEnd', onSocketEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // handle strings directly\n  this._writableState.decodeStrings = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  // if we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this._readableState.flowing = false;\n    } else {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[BYTES_READ] = 0;\n}\nutil.inherits(Socket, stream.Duplex);\n\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (var s = this; s !== null; s = s._parent)\n    timers._unrefActive(s);\n};\n\n// the user has called .end(), and all the bytes have been\n// sent out to the other side.\nfunction onSocketFinish() {\n  // If still connecting - defer handling 'finish' until 'connect' will happen\n  if (this.connecting) {\n    debug('osF: not yet connected');\n    return this.once('connect', onSocketFinish);\n  }\n\n  debug('onSocketFinish');\n  if (!this.readable || this._readableState.ended) {\n    debug('oSF: ended, destroy', this._readableState);\n    return this.destroy();\n  }\n\n  debug('oSF: not ended, call shutdown()');\n\n  // otherwise, just shutdown, or destroy() if not possible\n  if (!this._handle || !this._handle.shutdown)\n    return this.destroy();\n\n  var req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  // node::ShutdownWrap isn't instantiated and attached to the JS instance of\n  // ShutdownWrap above until shutdown() is called. So don't set the init\n  // trigger id until now.\n  setInitTriggerId(this[async_id_symbol]);\n  var err = this._handle.shutdown(req);\n\n  if (err)\n    return this.destroy(errnoException(err, 'shutdown'));\n}\n\n\nfunction afterShutdown(status, handle, req) {\n  var self = handle.owner;\n\n  debug('afterShutdown destroyed=%j', self.destroyed,\n        self._readableState);\n\n  // callback may come after call to destroy.\n  if (self.destroyed)\n    return;\n\n  if (self._readableState.ended) {\n    debug('readableState ended, destroying');\n    self.destroy();\n  } else {\n    self.once('_socketEnd', self.destroy);\n  }\n}\n\n// the EOF has been received, and no more bytes are coming.\n// if the writable side has ended already, then clean everything\n// up.\nfunction onSocketEnd() {\n  // XXX Should not have to do as much crap in this function.\n  // ended should already be true, since this is called *after*\n  // the EOF errno and onread has eof'ed\n  debug('onSocketEnd', this._readableState);\n  this._readableState.ended = true;\n  if (this._readableState.endEmitted) {\n    this.readable = false;\n    maybeDestroy(this);\n  } else {\n    this.once('end', function end() {\n      this.readable = false;\n      maybeDestroy(this);\n    });\n    this.read(0);\n  }\n\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    this.destroySoon();\n  }\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  var er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  // TODO: defer error events consistently everywhere, not just the cb\n  this.emit('error', er);\n  if (typeof cb === 'function') {\n    nextTick(this[async_id_symbol], cb, er);\n  }\n}\n\nSocket.prototype.read = function(n) {\n  if (n === 0)\n    return stream.Readable.prototype.read.call(this, n);\n\n  this.read = stream.Readable.prototype.read;\n  this._consuming = true;\n  return this.read(n);\n};\n\n\n// FIXME(joyeecheung): this method is neither documented nor tested\nSocket.prototype.listen = function() {\n  debug('socket.listen');\n  this.on('connection', arguments[0]);\n  listenInCluster(this, null, null, null);\n};\n\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  if (msecs === 0) {\n    timers.unenroll(this);\n    if (callback) {\n      this.removeListener('timeout', callback);\n    }\n  } else {\n    timers.enroll(this, msecs);\n    timers._unrefActive(this);\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  }\n  return this;\n};\n\n\nSocket.prototype._onTimeout = function() {\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect',\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle.setNoDelay)\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (!this._handle) {\n    this.once('connect', () => this.setKeepAlive(setting, msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, '_connecting', {\n  get: function() {\n    return this.connecting;\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    if (this._handle) {\n      return this._handle.writeQueueSize + this._writableState.length;\n    }\n  }\n});\n\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', () => this._read(n));\n  } else if (!this._handle.reading) {\n    // not already reading, start the flow\n    debug('Socket._read readStart');\n    this._handle.reading = true;\n    var err = this._handle.readStart();\n    if (err)\n      this.destroy(errnoException(err, 'read'));\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding) {\n  stream.Duplex.prototype.end.call(this, data, encoding);\n  this.writable = false;\n  ;\n  ;\n\n  // just in case we're waiting for an EOF.\n  if (this.readable && !this._readableState.endEmitted)\n    this.read(0);\n  else\n    maybeDestroy(this);\n};\n\n\n// Call whenever we set writable=false or readable=false\nfunction maybeDestroy(socket) {\n  if (!socket.readable &&\n      !socket.writable &&\n      !socket.destroyed &&\n      !socket.connecting &&\n      !socket._writableState.length) {\n    socket.destroy();\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  this.readable = this.writable = false;\n\n  for (var s = this; s !== null; s = s._parent)\n    timers.unenroll(s);\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    var isException = exception ? true : false;\n    // `bytesRead` should be accessible after `.destroy()`\n    this[BYTES_READ] = this._handle.bytesRead;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close', isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n  }\n\n  cb(exception);\n\n  if (this._server) {\n    ;\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\n\n// This function is called whenever the handle gets a\n// buffer, or when there's an error reading.\nfunction onread(nread, buffer) {\n  var handle = this;\n  var self = handle.owner;\n  assert(handle === self._handle, 'handle != self._handle');\n\n  self._unrefTimer();\n\n  debug('onread', nread);\n\n  if (nread > 0) {\n    debug('got data');\n\n    // read success.\n    // In theory (and in practice) calling readStop right now\n    // will prevent this from being called again until _read() gets\n    // called again.\n\n    // Optimization: emit the original buffer with end points\n    var ret = self.push(buffer);\n\n    if (handle.reading && !ret) {\n      handle.reading = false;\n      debug('readStop');\n      var err = handle.readStop();\n      if (err)\n        self.destroy(errnoException(err, 'read'));\n    }\n    return;\n  }\n\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\n  // wait for the next one.\n  if (nread === 0) {\n    debug('not any data, keep waiting');\n    return;\n  }\n\n  // Error, possibly EOF.\n  if (nread !== uv.UV_EOF) {\n    return self.destroy(errnoException(nread, 'read'));\n  }\n\n  debug('EOF');\n\n  // push a null to signal the end of data.\n  // Do it before `maybeDestroy` for correct order of events:\n  // `end` -> `close`\n  self.push(null);\n\n  if (self._readableState.length === 0) {\n    self.readable = false;\n    maybeDestroy(self);\n  }\n\n  // internal end event so that we know that the actual socket\n  // is no longer readable, and we can start the shutdown\n  // procedure. No need to wait for all the data to be consumed.\n  self.emit('_socketEnd');\n}\n\n\nSocket.prototype._getpeername = function() {\n  if (!this._peername) {\n    if (!this._handle || !this._handle.getpeername) {\n      return {};\n    }\n    var out = {};\n    var err = this._handle.getpeername(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name, callback) {\n  Object.defineProperty(Socket.prototype, name, {\n    configurable: false,\n    enumerable: true,\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead', function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[BYTES_READ];\n});\n\nprotoGetter('remoteAddress', function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily', function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort', function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  }\n  if (!this._sockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._sockname = out;\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress', function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort', function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype.write = function(chunk, encoding, cb) {\n  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\n    throw new TypeError(\n      'Invalid data, chunk must be a string or buffer, not ' + typeof chunk);\n  }\n  return stream.Duplex.prototype.write.apply(this, arguments);\n};\n\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function connect() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  this._unrefTimer();\n\n  if (!this._handle) {\n    this.destroy(new Error('This socket is closed'), cb);\n    return false;\n  }\n\n  var req = new WriteWrap();\n  req.handle = this._handle;\n  req.oncomplete = afterWrite;\n  req.async = false;\n  var err;\n\n  if (writev) {\n    var allBuffers = data.allBuffers;\n    var chunks;\n    var i;\n    if (allBuffers) {\n      chunks = data;\n      for (i = 0; i < data.length; i++)\n        data[i] = data[i].chunk;\n    } else {\n      chunks = new Array(data.length << 1);\n      for (i = 0; i < data.length; i++) {\n        var entry = data[i];\n        chunks[i * 2] = entry.chunk;\n        chunks[i * 2 + 1] = entry.encoding;\n      }\n    }\n    err = this._handle.writev(req, chunks, allBuffers);\n\n    // Retain chunks\n    if (err === 0) req._chunks = chunks;\n  } else {\n    var enc;\n    if (data instanceof Buffer) {\n      enc = 'buffer';\n    } else {\n      enc = encoding;\n    }\n    err = createWriteReq(req, this._handle, data, enc);\n  }\n\n  if (err)\n    return this.destroy(errnoException(err, 'write', req.error), cb);\n\n  this._bytesDispatched += req.bytes;\n\n  // If it was entirely flushed, we can write some more right now.\n  // However, if more is left in the queue, then wait until that clears.\n  if (req.async && this._handle.writeQueueSize !== 0)\n    req.cb = cb;\n  else\n    cb();\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\nfunction createWriteReq(req, handle, data, encoding) {\n  switch (encoding) {\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req, data);\n\n    case 'buffer':\n      return handle.writeBuffer(req, data);\n\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req, data);\n\n    case 'ascii':\n      return handle.writeAsciiString(req, data);\n\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req, data);\n\n    default:\n      return handle.writeBuffer(req, Buffer.from(data, encoding));\n  }\n}\n\n\nprotoGetter('bytesWritten', function bytesWritten() {\n  var bytes = this._bytesDispatched;\n  const state = this._writableState;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n\n  if (!state)\n    return undefined;\n\n  state.getBuffer().forEach(function(el) {\n    if (el.chunk instanceof Buffer)\n      bytes += el.chunk.length;\n    else\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\n  });\n\n  if (data) {\n    if (data instanceof Buffer)\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction afterWrite(status, handle, req, err) {\n  var self = handle.owner;\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite', status);\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    debug('afterWrite destroyed');\n    return;\n  }\n\n  if (status < 0) {\n    var ex = errnoException(status, 'write', req.error);\n    debug('write failure', ex);\n    self.destroy(ex, req.cb);\n    return;\n  }\n\n  self._unrefTimer();\n\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite call cb');\n\n  if (req.cb)\n    req.cb.call(self);\n}\n\n\nfunction internalConnect(\n  self, address, port, addressType, localAddress, localPort) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert.ok(self.connecting);\n\n  var err;\n\n  if (localAddress || localPort) {\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    if (addressType === 4) {\n      localAddress = localAddress || '0.0.0.0';\n      err = self._handle.bind(localAddress, localPort);\n    } else if (addressType === 6) {\n      localAddress = localAddress || '::';\n      err = self._handle.bind6(localAddress, localPort);\n    } else {\n      self.destroy(new TypeError('Invalid addressType: ' + addressType));\n      return;\n    }\n\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    // node::TCPConnectWrap isn't instantiated and attached to the JS instance\n    // of TCPConnectWrap above until connect() is called. So don't set the init\n    // trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n    // node::PipeConnectWrap isn't instantiated and attached to the JS instance\n    // of PipeConnectWrap above until connect() is called. So don't set the\n    // init trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    err = self._handle.connect(req, address, afterConnect);\n  }\n\n  if (err) {\n    var sockname = self._getsockname();\n    var details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err, 'connect', address, port, details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function() {\n  let normalized;\n  // If passed an array, it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342, but was\n  // reverted as it had unintended side effects.\n  if (Array.isArray(arguments[0]) && arguments[0][normalizedArgsSymbol]) {\n    normalized = arguments[0];\n  } else {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++)\n      args[i] = arguments[i];\n    // TODO(joyeecheung): use destructuring when V8 is fast enough\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._undestroy();\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  var pipe = !!options.path;\n  debug('pipe', pipe, options.path);\n\n  if (!this._handle) {\n    this._handle = pipe ? new Pipe() : new TCP();\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect', cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n  this.writable = true;\n\n  if (pipe) {\n    internalConnect(this, options.path);\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self, options) {\n  const dns = lazyDns();\n  var host = options.host || 'localhost';\n  var port = options.port;\n  var localAddress = options.localAddress;\n  var localPort = options.localPort;\n\n  if (localAddress && !cares.isIP(localAddress))\n    throw new TypeError('\"localAddress\" option must be a valid IP: ' +\n                        localAddress);\n\n  if (localPort && typeof localPort !== 'number')\n    throw new TypeError('\"localPort\" option should be a number: ' + localPort);\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string')\n      throw new TypeError('\"port\" option should be a number or string: ' +\n                          port);\n    if (!isLegalPort(port))\n      throw new RangeError('\"port\" option should be >= 0 and < 65536: ' + port);\n  }\n  port |= 0;\n\n  // If host is an IP, skip performing a lookup\n  var addressType = cares.isIP(host);\n  if (addressType) {\n    nextTick(self[async_id_symbol], function() {\n      if (self.connecting)\n        internalConnect(self, host, port, addressType, localAddress, localPort);\n    });\n    return;\n  }\n\n  if (options.lookup && typeof options.lookup !== 'function')\n    throw new TypeError('\"lookup\" option should be a function');\n\n  var dnsopts = {\n    family: options.family,\n    hints: options.hints || 0\n  };\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host', host);\n  debug('connect: dns options', dnsopts);\n  self._host = host;\n  var lookup = options.lookup || dns.lookup;\n  setInitTriggerId(self[async_id_symbol]);\n  lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\n    self.emit('lookup', err, ip, addressType, host);\n\n    // It's possible we were destroyed while looking this up.\n    // XXX it would be great if we could cancel the promise returned by\n    // the look up.\n    if (!self.connecting) return;\n\n    if (err) {\n      // net.createConnection() creates a net.Socket object and\n      // immediately calls net.Socket.connect() on it (that's us).\n      // There are no event listeners registered yet so defer the\n      // error event to the next tick.\n      err.host = options.host;\n      err.port = options.port;\n      err.message = err.message + ' ' + options.host + ':' + options.port;\n      process.nextTick(connectErrorNT, self, err);\n    } else {\n      self._unrefTimer();\n      internalConnect(self,\n                      ip,\n                      port,\n                      addressType,\n                      localAddress,\n                      localPort);\n    }\n  });\n}\n\n\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect', this.ref);\n    return this;\n  }\n\n  this._handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect', this.unref);\n    return this;\n  }\n\n  this._handle.unref();\n\n  return this;\n};\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  var self = handle.owner;\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  // Update handle if it was wrapped\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\n  handle = self._handle;\n\n  debug('afterConnect');\n\n  assert.ok(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    self.readable = readable;\n    self.writable = writable;\n    self._unrefTimer();\n\n    self.emit('connect');\n\n    // start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    var details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    var ex = exceptionWithHostPort(status,\n                                   'connect',\n                                   req.address,\n                                   req.port,\n                                   details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\n\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection', connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection', connectionListener);\n    }\n  } else {\n    throw new TypeError('options must be an object');\n  }\n\n  this._connections = 0;\n\n  Object.defineProperty(this, 'connections', {\n    get: internalUtil.deprecate(() => {\n\n      if (this._usingSlaves) {\n        return null;\n      }\n      return this._connections;\n    }, 'Server.connections property is deprecated. ' +\n       'Use Server.getConnections method instead.', 'DEP0020'),\n    set: internalUtil.deprecate((val) => (this._connections = val),\n                                'Server.connections property is deprecated.',\n                                'DEP0020'),\n    configurable: true, enumerable: false\n  });\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingSlaves = false;\n  this._slaves = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created, or error code if it can't\nfunction createServerHandle(address, port, addressType, fd) {\n  var err = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle;\n\n  var isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:', fd, e.message);\n      return uv.UV_EINVAL;\n    }\n    handle.open(fd);\n    handle.readable = true;\n    handle.writable = true;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe();\n    if (process.platform === 'win32') {\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!isNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP();\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to', address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6('::', port);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle('0.0.0.0', port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address, port, addressType, backlog, fd) {\n  debug('setupListenHandle', address, port, addressType, backlog, fd);\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    var rval = null;\n\n    // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle('::', port, 6, fd);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = '0.0.0.0';\n        addressType = 4;\n      } else {\n        address = '::';\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd);\n\n    if (typeof rval === 'number') {\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle.owner = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  var err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\n    this._handle.close();\n    this._handle = null;\n    nextTick(this[async_id_symbol], emitErrorNT, this, ex);\n    return;\n  }\n\n  // generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  nextTick(this[async_id_symbol], emitListeningNT, this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\n\nfunction emitListeningNT(self) {\n  // ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction lazyDns() {\n  if (dns === undefined)\n    dns = require('dns');\n  return dns;\n}\n\n\nfunction listenInCluster(server, address, port, addressType,\n                         backlog, fd, exclusive) {\n  exclusive = !!exclusive;\n\n  if (!cluster) cluster = require('cluster');\n\n  if (cluster.isMaster || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n    return;\n  }\n\n  const serverQuery = {\n    address: address,\n    port: port,\n    addressType: addressType,\n    fd: fd,\n    flags: 0\n  };\n\n  // Get the master's server handle, and listen on it\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n\n  function listenOnMasterHandle(err, handle) {\n    // EADDRINUSE may not be reported until we call listen(). To complicate\n    // matters, a failed bind() followed by listen() will implicitly bind to\n    // a random port. Ergo, check that the socket is bound to the expected\n    // port before calling listen().\n    //\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n    // getsockname() method. Non-issue for now, the cluster module doesn't\n    // really support pipes anyway.\n    if (err === 0 && port > 0 && handle.getsockname) {\n      var out = {};\n      err = handle.getsockname(out);\n      if (err === 0 && port !== out.port)\n        err = uv.UV_EADDRINUSE;\n    }\n\n    if (err) {\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\n      return server.emit('error', ex);\n    }\n\n    // Reuse master's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\n\n\nServer.prototype.listen = function() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  var hasCallback = (cb !== null);\n  if (hasCallback) {\n    this.once('listening', cb);\n  }\n  var backlogFromArgs =\n    // (handle, backlog) or (path, backlog) or (port, backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port, host, backlog)\n\n  options = options._handle || options.handle || options;\n  // (handle[, backlog][, cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  // (handle[, backlog][, cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n\n  // ([port][, host][, backlog][, cb]) where port is omitted,\n  // that is, listen() or listen(cb),\n  // or (options[, cb]) where options.port is explicitly set as undefined,\n  // bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n    (typeof options.port === 'undefined' && 'port' in options)) {\n    options.port = 0;\n  }\n  // ([port][, host][, backlog][, cb]) where port is specified\n  // or (options[, cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  var backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    if (!isLegalPort(options.port)) {\n      throw new RangeError('\"port\" argument must be >= 0 and < 65536');\n    }\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog,\n                      options.exclusive);\n    } else { // Undefined host, listens on unspecified address\n      // Default addressType 4 will be used to search for master server\n      listenInCluster(this, null, options.port | 0, 4,\n                      backlog, undefined, options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[, backlog][, cb]) or (options[, cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    var pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this, pipeName, -1, -1,\n                    backlog, undefined, options.exclusive);\n    return this;\n  }\n\n  throw new Error('Invalid listen argument: ' + util.inspect(options));\n};\n\nfunction lookupAndListen(self, port, address, backlog, exclusive) {\n  const dns = lazyDns();\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType,\n                      backlog, undefined, exclusive);\n    }\n  });\n}\n\nObject.defineProperty(Server.prototype, 'listening', {\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(err, clientHandle) {\n  var handle = this;\n  var self = handle.owner;\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect\n  });\n  socket.readable = socket.writable = true;\n\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  ;\n  ;\n  ;\n  self.emit('connection', socket);\n}\n\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err, connections) {\n    nextTick(self[async_id_symbol], cb, err, connections);\n  }\n\n  if (!this._usingSlaves) {\n    return end(null, this._connections);\n  }\n\n  // Poll slaves\n  var left = this._slaves.length;\n  var total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  for (var n = 0; n < this._slaves.length; n++) {\n    this._slaves[n].getConnections(oncount);\n  }\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close', function close() {\n        cb(new Error('Not running'));\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingSlaves) {\n    var left = this._slaves.length;\n    const onSlaveClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of slaves, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll slaves\n    for (var n = 0; n < this._slaves.length; n++)\n      this._slaves[n].close(onSlaveClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!this._handle, this._connections);\n    return;\n  }\n\n  const asyncId = this._handle ? this[async_id_symbol] : null;\n  nextTick(asyncId, emitCloseNT, this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\n  return this.listen({ fd: fd });\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.',\n                                                   'DEP0021');\n\nServer.prototype._setupSlave = function(socketList) {\n  this._usingSlaves = true;\n  this._slaves.push(socketList);\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nvar _setSimultaneousAccepts;\n\nif (process.platform === 'win32') {\n  var simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function(handle) {};\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP: cares.isIP,\n  isIPv4: cares.isIPv4,\n  isIPv6: cares.isIPv6,\n  Server,\n  Socket,\n  Stream: Socket, // Legacy naming\n};\n",
  "os": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst pushValToArrayMax = process.binding('util').pushValToArrayMax;\nconst constants = process.binding('constants').os;\nconst deprecate = require('internal/util').deprecate;\nconst isWindows = process.platform === 'win32';\n\nconst {\n  getCPUs,\n  getFreeMem,\n  getHomeDirectory,\n  getHostname,\n  getInterfaceAddresses,\n  getLoadAvg,\n  getOSRelease,\n  getOSType,\n  getTotalMem,\n  getUserInfo,\n  getUptime,\n  isBigEndian\n} = process.binding('os');\n\ngetFreeMem[Symbol.toPrimitive] = () => getFreeMem();\ngetHostname[Symbol.toPrimitive] = () => getHostname();\ngetHomeDirectory[Symbol.toPrimitive] = () => getHomeDirectory();\ngetOSRelease[Symbol.toPrimitive] = () => getOSRelease();\ngetOSType[Symbol.toPrimitive] = () => getOSType();\ngetTotalMem[Symbol.toPrimitive] = () => getTotalMem();\ngetUptime[Symbol.toPrimitive] = () => getUptime();\n\nconst kEndianness = isBigEndian ? 'BE' : 'LE';\n\nconst tmpDirDeprecationMsg =\n  'os.tmpDir() is deprecated. Use os.tmpdir() instead.';\n\nconst getNetworkInterfacesDepMsg =\n  'os.getNetworkInterfaces is deprecated. Use os.networkInterfaces instead.';\n\nconst avgValues = new Float64Array(3);\nconst cpuValues = new Float64Array(6 * pushValToArrayMax);\n\nfunction loadavg() {\n  getLoadAvg(avgValues);\n  return [avgValues[0], avgValues[1], avgValues[2]];\n}\n\nfunction addCPUInfo() {\n  for (var i = 0, c = 0; i < arguments.length; ++i, c += 6) {\n    this[this.length] = {\n      model: arguments[i],\n      speed: cpuValues[c],\n      times: {\n        user: cpuValues[c + 1],\n        nice: cpuValues[c + 2],\n        sys: cpuValues[c + 3],\n        idle: cpuValues[c + 4],\n        irq: cpuValues[c + 5]\n      }\n    };\n  }\n}\n\nfunction cpus() {\n  return getCPUs(addCPUInfo, cpuValues, []);\n}\n\nfunction arch() {\n  return process.arch;\n}\narch[Symbol.toPrimitive] = () => process.arch;\n\nfunction platform() {\n  return process.platform;\n}\nplatform[Symbol.toPrimitive] = () => process.platform;\n\nfunction tmpdir() {\n  var path;\n  if (isWindows) {\n    path = process.env.TEMP ||\n           process.env.TMP ||\n           (process.env.SystemRoot || process.env.windir) + '\\\\temp';\n    if (path.length > 1 && path.endsWith('\\\\') && !path.endsWith(':\\\\'))\n      path = path.slice(0, -1);\n  } else {\n    path = process.env.TMPDIR ||\n           process.env.TMP ||\n           process.env.TEMP ||\n           '/tmp';\n    if (path.length > 1 && path.endsWith('/'))\n      path = path.slice(0, -1);\n  }\n\n  return path;\n}\ntmpdir[Symbol.toPrimitive] = () => tmpdir();\n\nfunction endianness() {\n  return kEndianness;\n}\nendianness[Symbol.toPrimitive] = () => kEndianness;\n\nmodule.exports = exports = {\n  arch,\n  cpus,\n  EOL: isWindows ? '\\r\\n' : '\\n',\n  endianness,\n  freemem: getFreeMem,\n  homedir: getHomeDirectory,\n  hostname: getHostname,\n  loadavg,\n  networkInterfaces: getInterfaceAddresses,\n  platform,\n  release: getOSRelease,\n  tmpdir,\n  totalmem: getTotalMem,\n  type: getOSType,\n  userInfo: getUserInfo,\n  uptime: getUptime,\n\n  // Deprecated APIs\n  getNetworkInterfaces: deprecate(getInterfaceAddresses,\n                                  getNetworkInterfacesDepMsg,\n                                  'DEP0023'),\n  tmpDir: deprecate(tmpdir, tmpDirDeprecationMsg, 'DEP0022')\n};\n\nObject.defineProperty(module.exports, 'constants', {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n",
  "path": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst inspect = require('util').inspect;\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + inspect(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringWin32(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/ || code === 92/*\\*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 92/*\\*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '\\\\..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '\\\\' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 47/*/*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    ((pathObject.name || '') + (pathObject.ext || ''));\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nconst win32 = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path;\n      if (i >= 0) {\n        path = arguments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            path.slice(0, 3).toLowerCase() !==\n              resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var code = path.charCodeAt(0);\n      var device = '';\n      var isAbsolute = false;\n\n      // Try to match a root\n      if (len > 1) {\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Possible UNC root\n\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n\n          code = path.charCodeAt(1);\n          if (code === 47/*/*/ || code === 92/*\\*/) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code === 47/*/*/ || code === 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              const firstPart = path.slice(last, j);\n              // Matched!\n              last = j;\n              // Match 1 or more path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code !== 47/*/*/ && code !== 92/*\\*/)\n                  break;\n              }\n              if (j < len && j !== last) {\n                // Matched!\n                last = j;\n                // Match 1 or more non-path separators\n                for (; j < len; ++j) {\n                  code = path.charCodeAt(j);\n                  if (code === 47/*/*/ || code === 92/*\\*/)\n                    break;\n                }\n                if (j === len) {\n                  // We matched a UNC root only\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                   (code >= 97/*a*/ && code <= 122/*z*/)) {\n          // Possible device root\n\n          code = path.charCodeAt(1);\n          if (path.charCodeAt(1) === 58/*:*/) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2) {\n              code = path.charCodeAt(2);\n              if (code === 47/*/*/ || code === 92/*\\*/) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (code === 47/*/*/ || code === 92/*\\*/) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n\n      if (device.length > 0 &&\n          resolvedDevice.length > 0 &&\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeStringWin32(resolvedTail, !resolvedAbsolute);\n\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n           '.';\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var device;\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n\n    code = path.charCodeAt(len - 1);\n    var trailingSeparator = (code === 47/*/*/ || code === 92/*\\*/);\n    var tail;\n    if (rootEnd < len)\n      tail = normalizeStringWin32(path.slice(rootEnd), !isAbsolute);\n    else\n      tail = '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 && trailingSeparator)\n      tail += '\\\\';\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return '\\\\' + tail;\n        else\n          return '\\\\';\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return device + '\\\\' + tail;\n        else\n          return device + '\\\\';\n      } else if (tail.length > 0) {\n        return device + tail;\n      } else {\n        return device;\n      }\n    }\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return false;\n    var code = path.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      return true;\n    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n               (code >= 97/*a*/ && code <= 122/*z*/)) {\n      // Possible device root\n\n      if (len > 2 && path.charCodeAt(1) === 58/*:*/) {\n        code = path.charCodeAt(2);\n        if (code === 47/*/*/ || code === 92/*\\*/)\n          return true;\n      }\n    }\n    return false;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n\n    var joined;\n    var firstPart;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += '\\\\' + arg;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    //var firstPart = paths[0];\n    var needsReplace = true;\n    var slashCount = 0;\n    var code = firstPart.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1) {\n        code = firstPart.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          ++slashCount;\n          if (firstLen > 2) {\n            code = firstPart.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              ++slashCount;\n            else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        code = joined.charCodeAt(slashCount);\n        if (code !== 47/*/*/ && code !== 92/*\\*/)\n          break;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = '\\\\' + joined.slice(slashCount);\n    }\n\n    return win32.normalize(joined);\n  },\n\n\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 0;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var fromEnd = from.length;\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 0;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var toEnd = to.length;\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 92/*\\*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 92/*\\*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 92/*\\*/)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n\n    var out = '';\n    if (lastCommonSep === -1)\n      lastCommonSep = 0;\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 92/*\\*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '\\\\..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    else {\n      toStart += lastCommonSep;\n      if (toOrig.charCodeAt(toStart) === 92/*\\*/)\n        ++toStart;\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string')\n      return path;\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length >= 3) {\n      var code = resolvedPath.charCodeAt(0);\n      if (code === 92/*\\*/) {\n        // Possible UNC root\n\n        if (resolvedPath.charCodeAt(1) === 92/*\\*/) {\n          code = resolvedPath.charCodeAt(2);\n          if (code !== 63/*?*/ && code !== 46/*.*/) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        if (resolvedPath.charCodeAt(1) === 58/*:*/ &&\n            resolvedPath.charCodeAt(2) === 92/*\\*/) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        rootEnd = offset = 1;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = offset = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              rootEnd = offset = 3;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      return path[0];\n    }\n\n    for (var i = len - 1; i >= offset; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n      else\n        end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2) {\n      const drive = path.charCodeAt(0);\n      if ((drive >= 65/*A*/ && drive <= 90/*Z*/) ||\n          (drive >= 97/*a*/ && drive <= 122/*z*/)) {\n        if (path.charCodeAt(1) === 58/*:*/)\n          start = 2;\n      }\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('\\\\', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        rootEnd = 1;\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path.slice(0, 3);\n                return ret;\n              }\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path.slice(0, 2);\n            return ret;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path[0];\n      return ret;\n    }\n\n    if (rootEnd > 0)\n      ret.root = path.slice(0, rootEnd);\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(rootEnd, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(rootEnd, startDot);\n        ret.base = path.slice(rootEnd, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = path.slice(0, rootEnd);\n\n    return ret;\n  },\n\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\n\n\nconst posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute = path.charCodeAt(0) === 47/*/*/;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute)\n      path = '.';\n    if (path.length > 0 && trailingSeparator)\n      path += '/';\n\n    if (isAbsolute)\n      return '/' + path;\n    return path;\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47/*/*/;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47/*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47/*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47/*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47/*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47/*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47/*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47/*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0)\n      return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = (code === 47/*/*/);\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('/', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = (code === 47/*/*/);\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n\nif (process.platform === 'win32')\n  module.exports = win32;\nelse\n  module.exports = posix;\n",
  "process": "'use strict';\n\n// Re-export process as a native module\nmodule.exports = process;\n",
  "punycode": "'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\x20-\\x7E]/; // unprintable ASCII chars + non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (var w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (var k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.0.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nmodule.exports = punycode;\n",
  "querystring": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Query String Utilities\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst {\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\nconst QueryString = module.exports = {\n  unescapeBuffer,\n  // `unescape()` is a JS global, so we need to use a different local name\n  unescape: qsUnescape,\n\n  // `escape()` is a JS global, so we need to use a different local name\n  escape: qsEscape,\n\n  stringify,\n  encode: stringify,\n\n  parse,\n  decode: parse\n};\n\nconst unhexTable = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0 - 15\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 16 - 31\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 32 - 47\n  +0, +1, +2, +3, +4, +5, +6, +7, +8, +9, -1, -1, -1, -1, -1, -1, // 48 - 63\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 64 - 79\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 80 - 95\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 96 - 111\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 112 - 127\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 128 ...\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1  // ... 255\n];\n// a safe fast alternative to decodeURIComponent\nfunction unescapeBuffer(s, decodeSpaces) {\n  var out = Buffer.allocUnsafe(s.length);\n  var index = 0;\n  var outIndex = 0;\n  var currentChar;\n  var nextChar;\n  var hexHigh;\n  var hexLow;\n  var maxLength = s.length - 2;\n  // Flag to know if some hex chars have been decoded\n  var hasHex = false;\n  while (index < s.length) {\n    currentChar = s.charCodeAt(index);\n    if (currentChar === 43 /*'+'*/ && decodeSpaces) {\n      out[outIndex++] = 32; // ' '\n      index++;\n      continue;\n    }\n    if (currentChar === 37 /*'%'*/ && index < maxLength) {\n      currentChar = s.charCodeAt(++index);\n      hexHigh = unhexTable[currentChar];\n      if (!(hexHigh >= 0)) {\n        out[outIndex++] = 37; // '%'\n      } else {\n        nextChar = s.charCodeAt(++index);\n        hexLow = unhexTable[nextChar];\n        if (!(hexLow >= 0)) {\n          out[outIndex++] = 37; // '%'\n          out[outIndex++] = currentChar;\n          currentChar = nextChar;\n        } else {\n          hasHex = true;\n          currentChar = hexHigh * 16 + hexLow;\n        }\n      }\n    }\n    out[outIndex++] = currentChar;\n    index++;\n  }\n  return hasHex ? out.slice(0, outIndex) : out;\n}\n\n\nfunction qsUnescape(s, decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch (e) {\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n  }\n}\n\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscape = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0  // 112 - 127\n];\n// QueryString.escape() replaces encodeURIComponent()\n// http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\nfunction qsEscape(str) {\n  if (typeof str !== 'string') {\n    if (typeof str === 'object')\n      str = String(str);\n    else\n      str += '';\n  }\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscape[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += hexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | (c >> 12)] +\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < str.length)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else\n      throw new URIError('URI malformed');\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += hexTable[0xF0 | (c >> 18)] +\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\n           hexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < str.length)\n    return out + str.slice(lastPos);\n  return out;\n}\n\nfunction stringifyPrimitive(v) {\n  if (typeof v === 'string')\n    return v;\n  if (typeof v === 'number' && isFinite(v))\n    return '' + v;\n  if (typeof v === 'boolean')\n    return v ? 'true' : 'false';\n  return '';\n}\n\n\nfunction stringify(obj, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n\n  var encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    var keys = Object.keys(obj);\n    var len = keys.length;\n    var flast = len - 1;\n    var fields = '';\n    for (var i = 0; i < len; ++i) {\n      var k = keys[i];\n      var v = obj[k];\n      var ks = encode(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(v)) {\n        var vlen = v.length;\n        var vlast = vlen - 1;\n        for (var j = 0; j < vlen; ++j) {\n          fields += ks + encode(stringifyPrimitive(v[j]));\n          if (j < vlast)\n            fields += sep;\n        }\n        if (vlen && i < flast)\n          fields += sep;\n      } else {\n        fields += ks + encode(stringifyPrimitive(v));\n        if (i < flast)\n          fields += sep;\n      }\n    }\n    return fields;\n  }\n  return '';\n}\n\nfunction charCodes(str) {\n  if (str.length === 0) return [];\n  if (str.length === 1) return [str.charCodeAt(0)];\n  const ret = [];\n  for (var i = 0; i < str.length; ++i)\n    ret[ret.length] = str.charCodeAt(i);\n  return ret;\n}\nconst defSepCodes = [38]; // &\nconst defEqCodes = [61]; // =\n\n// Parse a key/val string.\nfunction parse(qs, sep, eq, options) {\n  const obj = Object.create(null);\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var sepCodes = (!sep ? defSepCodes : charCodes(sep + ''));\n  var eqCodes = (!eq ? defEqCodes : charCodes(eq + ''));\n  const sepLen = sepCodes.length;\n  const eqLen = eqCodes.length;\n\n  var pairs = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    // -1 is used in place of a value like Infinity for meaning\n    // \"unlimited pairs\" because of additional checks V8 (at least as of v5.4)\n    // has to do when using variables that contain values like Infinity. Since\n    // `pairs` is always decremented and checked explicitly for 0, -1 works\n    // effectively the same as Infinity, while providing a significant\n    // performance boost.\n    pairs = (options.maxKeys > 0 ? options.maxKeys : -1);\n  }\n\n  var decode = QueryString.unescape;\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n  const customDecode = (decode !== qsUnescape);\n\n  const keys = [];\n  var lastPos = 0;\n  var sepIdx = 0;\n  var eqIdx = 0;\n  var key = '';\n  var value = '';\n  var keyEncoded = customDecode;\n  var valEncoded = customDecode;\n  const plusChar = (customDecode ? '%20' : ' ');\n  var encodeCheck = 0;\n  for (var i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator (e.g. '&')\n    if (code === sepCodes[sepIdx]) {\n      if (++sepIdx === sepLen) {\n        // Key/value pair separator match!\n        const end = i - sepIdx + 1;\n        if (eqIdx < eqLen) {\n          // We didn't find the (entire) key/value separator\n          if (lastPos < end) {\n            // Treat the substring as part of the key instead of the value\n            key += qs.slice(lastPos, end);\n            if (keyEncoded)\n              key = decodeStr(key, decode);\n          } else {\n            // We saw an empty substring between separators\n            if (--pairs === 0)\n              return obj;\n            lastPos = i + 1;\n            sepIdx = eqIdx = 0;\n            continue;\n          }\n        } else {\n          if (lastPos < end) {\n            value += qs.slice(lastPos, end);\n            if (valEncoded)\n              value = decodeStr(value, decode);\n          }\n          if (keyEncoded)\n            key = decodeStr(key, decode);\n        }\n\n        // Use a key array lookup instead of using hasOwnProperty(), which is\n        // slower\n        if (keys.indexOf(key) === -1) {\n          obj[key] = value;\n          keys[keys.length] = key;\n        } else {\n          const curValue = obj[key];\n          // A simple Array-specific property check is enough here to\n          // distinguish from a string value and is faster and still safe\n          // since we are generating all of the values being assigned.\n          if (curValue.pop)\n            curValue[curValue.length] = value;\n          else\n            obj[key] = [curValue, value];\n        }\n        if (--pairs === 0)\n          return obj;\n        keyEncoded = valEncoded = customDecode;\n        key = value = '';\n        encodeCheck = 0;\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n    } else {\n      sepIdx = 0;\n      // Try matching key/value separator (e.g. '=') if we haven't already\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            // Key/value separator match!\n            const end = i - eqIdx + 1;\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n            encodeCheck = 0;\n            lastPos = i + 1;\n          }\n          continue;\n        } else {\n          eqIdx = 0;\n          if (!keyEncoded) {\n            // Try to match an (valid) encoded byte once to minimize unnecessary\n            // calls to string decoding functions\n            if (code === 37/*%*/) {\n              encodeCheck = 1;\n              continue;\n            } else if (encodeCheck > 0) {\n              // eslint-disable-next-line no-extra-boolean-cast\n              if (!!isHexTable[code]) {\n                if (++encodeCheck === 3)\n                  keyEncoded = true;\n                continue;\n              } else {\n                encodeCheck = 0;\n              }\n            }\n          }\n        }\n        if (code === 43/*+*/) {\n          if (lastPos < i)\n            key += qs.slice(lastPos, i);\n          key += plusChar;\n          lastPos = i + 1;\n          continue;\n        }\n      }\n      if (code === 43/*+*/) {\n        if (lastPos < i)\n          value += qs.slice(lastPos, i);\n        value += plusChar;\n        lastPos = i + 1;\n      } else if (!valEncoded) {\n        // Try to match an (valid) encoded byte (once) to minimize unnecessary\n        // calls to string decoding functions\n        if (code === 37/*%*/) {\n          encodeCheck = 1;\n        } else if (encodeCheck > 0) {\n          // eslint-disable-next-line no-extra-boolean-cast\n          if (!!isHexTable[code]) {\n            if (++encodeCheck === 3)\n              valEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n  if (lastPos < qs.length) {\n    if (eqIdx < eqLen)\n      key += qs.slice(lastPos);\n    else if (sepIdx < sepLen)\n      value += qs.slice(lastPos);\n  } else if (eqIdx === 0) {\n    // We ended on an empty substring\n    return obj;\n  }\n  if (keyEncoded)\n    key = decodeStr(key, decode);\n  if (valEncoded)\n    value = decodeStr(value, decode);\n  // Use a key array lookup instead of using hasOwnProperty(), which is slower\n  if (keys.indexOf(key) === -1) {\n    obj[key] = value;\n    keys[keys.length] = key;\n  } else {\n    const curValue = obj[key];\n    // A simple Array-specific property check is enough here to\n    // distinguish from a string value and is faster and still safe since\n    // we are generating all of the values being assigned.\n    if (curValue.pop)\n      curValue[curValue.length] = value;\n    else\n      obj[key] = [curValue, value];\n  }\n\n  return obj;\n}\n\n\n// v8 does not optimize functions with try-catch blocks, so we isolate them here\n// to minimize the damage (Note: no longer true as of V8 5.4 -- but still will\n// not be inlined).\nfunction decodeStr(s, decoder) {\n  try {\n    return decoder(s);\n  } catch (e) {\n    return QueryString.unescape(s, true);\n  }\n}\n",
  "readline": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.\n// https://github.com/antirez/linenoise\n// Reference:\n// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n\n'use strict';\n\nconst { debug, inherits } = require('util');\nconst Buffer = require('buffer').Buffer;\nconst EventEmitter = require('events');\nconst {\n  CSI,\n  emitKeys,\n  getStringWidth,\n  isFullWidthCodePoint,\n  stripVTControlCharacters\n} = require('internal/readline');\n\nconst {\n  kEscape,\n  kClearToBeginning,\n  kClearToEnd,\n  kClearLine,\n  kClearScreenDown\n} = CSI;\n\nconst kHistorySize = 30;\nconst kMincrlfDelay = 100;\nconst kMaxcrlfDelay = 2000;\n// \\r\\n, \\n, or \\r followed by something other than \\n\nconst lineEnding = /\\r?\\n|\\r(?!\\n)/;\n\nconst KEYPRESS_DECODER = Symbol('keypress-decoder');\nconst ESCAPE_DECODER = Symbol('escape-decoder');\n\n// GNU readline library - keyseq-timeout is 500ms (default)\nconst ESCAPE_CODE_TIMEOUT = 500;\n\n\nfunction createInterface(input, output, completer, terminal) {\n  return new Interface(input, output, completer, terminal);\n}\n\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  this._sawReturnAt = 0;\n  this.isCompletionEnabled = true;\n  this._sawKeyPress = false;\n  this._previousKey = null;\n\n  EventEmitter.call(this);\n  var historySize;\n  var removeHistoryDuplicates = false;\n  let crlfDelay;\n  let prompt = '> ';\n\n  if (input && input.input) {\n    // an options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    historySize = input.historySize;\n    removeHistoryDuplicates = input.removeHistoryDuplicates;\n    if (input.prompt !== undefined) {\n      prompt = input.prompt;\n    }\n    crlfDelay = input.crlfDelay;\n    input = input.input;\n  }\n\n  if (completer && typeof completer !== 'function') {\n    throw new TypeError('Argument \"completer\" must be a function');\n  }\n\n  if (historySize === undefined) {\n    historySize = kHistorySize;\n  }\n\n  if (typeof historySize !== 'number' ||\n      isNaN(historySize) ||\n      historySize < 0) {\n    throw new TypeError('Argument \"historySize\" must be a positive number');\n  }\n\n  // backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (terminal === undefined && !(output === null || output === undefined)) {\n    terminal = !!output.isTTY;\n  }\n\n  var self = this;\n\n  this.output = output;\n  this.input = input;\n  this.historySize = historySize;\n  this.removeHistoryDuplicates = !!removeHistoryDuplicates;\n  this.crlfDelay = Math.max(kMincrlfDelay,\n                            Math.min(kMaxcrlfDelay, crlfDelay >>> 0));\n\n  // Check arity, 2 - for async, 1 for sync\n  if (typeof completer === 'function') {\n    this.completer = completer.length === 2 ? completer : function(v, cb) {\n      cb(null, completer(v));\n    };\n  }\n\n  this.setPrompt(prompt);\n\n  this.terminal = !!terminal;\n\n  function ondata(data) {\n    self._normalWrite(data);\n  }\n\n  function onend() {\n    if (typeof self._line_buffer === 'string' &&\n        self._line_buffer.length > 0) {\n      self.emit('line', self._line_buffer);\n    }\n    self.close();\n  }\n\n  function ontermend() {\n    if (typeof self.line === 'string' && self.line.length > 0) {\n      self.emit('line', self.line);\n    }\n    self.close();\n  }\n\n  function onkeypress(s, key) {\n    self._ttyWrite(s, key);\n    if (key && key.sequence) {\n      // if the key.sequence is half of a surrogate pair\n      // (>= 0xd800 and <= 0xdfff), refresh the line so\n      // the character is displayed appropriately.\n      const ch = key.sequence.codePointAt(0);\n      if (ch >= 0xd800 && ch <= 0xdfff)\n        self._refreshLine();\n    }\n  }\n\n  function onresize() {\n    self._refreshLine();\n  }\n\n  if (!this.terminal) {\n    input.on('data', ondata);\n    input.on('end', onend);\n    self.once('close', function() {\n      input.removeListener('data', ondata);\n      input.removeListener('end', onend);\n    });\n    var StringDecoder = require('string_decoder').StringDecoder; // lazy load\n    this._decoder = new StringDecoder('utf8');\n\n  } else {\n\n    emitKeypressEvents(input, this);\n\n    // input usually refers to stdin\n    input.on('keypress', onkeypress);\n    input.on('end', ontermend);\n\n    // Current line\n    this.line = '';\n\n    this._setRawMode(true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n\n    this.history = [];\n    this.historyIndex = -1;\n\n    if (output !== null && output !== undefined)\n      output.on('resize', onresize);\n\n    self.once('close', function() {\n      input.removeListener('keypress', onkeypress);\n      input.removeListener('end', ontermend);\n      if (output !== null && output !== undefined) {\n        output.removeListener('resize', onresize);\n      }\n    });\n  }\n\n  input.resume();\n}\n\ninherits(Interface, EventEmitter);\n\nObject.defineProperty(Interface.prototype, 'columns', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    var columns = Infinity;\n    if (this.output && this.output.columns)\n      columns = this.output.columns;\n    return columns;\n  }\n});\n\nInterface.prototype.setPrompt = function(prompt) {\n  this._prompt = prompt;\n};\n\n\nInterface.prototype._setRawMode = function(mode) {\n  const wasInRawMode = this.input.isRaw;\n\n  if (typeof this.input.setRawMode === 'function') {\n    this.input.setRawMode(mode);\n  }\n\n  return wasInRawMode;\n};\n\n\nInterface.prototype.prompt = function(preserveCursor) {\n  if (this.paused) this.resume();\n  if (this.terminal) {\n    if (!preserveCursor) this.cursor = 0;\n    this._refreshLine();\n  } else {\n    this._writeToOutput(this._prompt);\n  }\n};\n\n\nInterface.prototype.question = function(query, cb) {\n  if (typeof cb === 'function') {\n    if (this._questionCallback) {\n      this.prompt();\n    } else {\n      this._oldPrompt = this._prompt;\n      this.setPrompt(query);\n      this._questionCallback = cb;\n      this.prompt();\n    }\n  }\n};\n\n\nInterface.prototype._onLine = function(line) {\n  if (this._questionCallback) {\n    var cb = this._questionCallback;\n    this._questionCallback = null;\n    this.setPrompt(this._oldPrompt);\n    cb(line);\n  } else {\n    this.emit('line', line);\n  }\n};\n\nInterface.prototype._writeToOutput = function _writeToOutput(stringToWrite) {\n  if (typeof stringToWrite !== 'string')\n    throw new TypeError('\"stringToWrite\" argument must be a string');\n\n  if (this.output !== null && this.output !== undefined)\n    this.output.write(stringToWrite);\n};\n\nInterface.prototype._addHistory = function() {\n  if (this.line.length === 0) return '';\n\n  // if the history is disabled then return the line\n  if (this.historySize === 0) return this.line;\n\n  // if the trimmed line is empty then return the line\n  if (this.line.trim().length === 0) return this.line;\n\n  if (this.history.length === 0 || this.history[0] !== this.line) {\n    if (this.removeHistoryDuplicates) {\n      // Remove older history line if identical to new one\n      const dupIndex = this.history.indexOf(this.line);\n      if (dupIndex !== -1) this.history.splice(dupIndex, 1);\n    }\n\n    this.history.unshift(this.line);\n\n    // Only store so many\n    if (this.history.length > this.historySize) this.history.pop();\n  }\n\n  this.historyIndex = -1;\n  return this.history[0];\n};\n\n\nInterface.prototype._refreshLine = function() {\n  // line length\n  var line = this._prompt + this.line;\n  var dispPos = this._getDisplayPos(line);\n  var lineCols = dispPos.cols;\n  var lineRows = dispPos.rows;\n\n  // cursor position\n  var cursorPos = this._getCursorPos();\n\n  // first move to the bottom of the current line, based on cursor pos\n  var prevRows = this.prevRows || 0;\n  if (prevRows > 0) {\n    moveCursor(this.output, 0, -prevRows);\n  }\n\n  // Cursor to left edge.\n  cursorTo(this.output, 0);\n  // erase data\n  clearScreenDown(this.output);\n\n  // Write the prompt and the current buffer content.\n  this._writeToOutput(line);\n\n  // Force terminal to allocate a new line\n  if (lineCols === 0) {\n    this._writeToOutput(' ');\n  }\n\n  // Move cursor to original position.\n  cursorTo(this.output, cursorPos.cols);\n\n  var diff = lineRows - cursorPos.rows;\n  if (diff > 0) {\n    moveCursor(this.output, 0, -diff);\n  }\n\n  this.prevRows = cursorPos.rows;\n};\n\n\nInterface.prototype.close = function() {\n  if (this.closed) return;\n  this.pause();\n  if (this.terminal) {\n    this._setRawMode(false);\n  }\n  this.closed = true;\n  this.emit('close');\n};\n\n\nInterface.prototype.pause = function() {\n  if (this.paused) return;\n  this.input.pause();\n  this.paused = true;\n  this.emit('pause');\n  return this;\n};\n\n\nInterface.prototype.resume = function() {\n  if (!this.paused) return;\n  this.input.resume();\n  this.paused = false;\n  this.emit('resume');\n  return this;\n};\n\n\nInterface.prototype.write = function(d, key) {\n  if (this.paused) this.resume();\n  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);\n};\n\nInterface.prototype._normalWrite = function(b) {\n  if (b === undefined) {\n    return;\n  }\n  var string = this._decoder.write(b);\n  if (this._sawReturnAt &&\n      Date.now() - this._sawReturnAt <= this.crlfDelay) {\n    string = string.replace(/^\\n/, '');\n    this._sawReturnAt = 0;\n  }\n\n  // Run test() on the new string chunk, not on the entire line buffer.\n  var newPartContainsEnding = lineEnding.test(string);\n\n  if (this._line_buffer) {\n    string = this._line_buffer + string;\n    this._line_buffer = null;\n  }\n  if (newPartContainsEnding) {\n    this._sawReturnAt = string.endsWith('\\r') ? Date.now() : 0;\n\n    // got one or more newlines; process into \"line\" events\n    var lines = string.split(lineEnding);\n    // either '' or (conceivably) the unfinished portion of the next line\n    string = lines.pop();\n    this._line_buffer = string;\n    for (var n = 0; n < lines.length; n++)\n      this._onLine(lines[n]);\n  } else if (string) {\n    // no newlines this time, save what we have for next time\n    this._line_buffer = string;\n  }\n};\n\nInterface.prototype._insertString = function(c) {\n  if (this.cursor < this.line.length) {\n    var beg = this.line.slice(0, this.cursor);\n    var end = this.line.slice(this.cursor, this.line.length);\n    this.line = beg + c + end;\n    this.cursor += c.length;\n    this._refreshLine();\n  } else {\n    this.line += c;\n    this.cursor += c.length;\n\n    if (this._getCursorPos().cols === 0) {\n      this._refreshLine();\n    } else {\n      this._writeToOutput(c);\n    }\n\n    // a hack to get the line refreshed if it's needed\n    this._moveCursor(0);\n  }\n};\n\nInterface.prototype._tabComplete = function(lastKeypressWasTab) {\n  var self = this;\n\n  self.pause();\n  self.completer(self.line.slice(0, self.cursor), function(err, rv) {\n    self.resume();\n\n    if (err) {\n      debug('tab completion error %j', err);\n      return;\n    }\n\n    const completions = rv[0];\n    const completeOn = rv[1];  // the text that was completed\n    if (completions && completions.length) {\n      // Apply/show completions.\n      if (lastKeypressWasTab) {\n        self._writeToOutput('\\r\\n');\n        var width = completions.reduce(function(a, b) {\n          return a.length > b.length ? a : b;\n        }).length + 2;  // 2 space padding\n        var maxColumns = Math.floor(self.columns / width);\n        if (!maxColumns || maxColumns === Infinity) {\n          maxColumns = 1;\n        }\n        var group = [];\n        for (var i = 0, compLen = completions.length; i < compLen; i++) {\n          var c = completions[i];\n          if (c === '') {\n            handleGroup(self, group, width, maxColumns);\n            group = [];\n          } else {\n            group.push(c);\n          }\n        }\n        handleGroup(self, group, width, maxColumns);\n      }\n\n      // If there is a common prefix to all matches, then apply that portion.\n      var f = completions.filter(function(e) { if (e) return e; });\n      var prefix = commonPrefix(f);\n      if (prefix.length > completeOn.length) {\n        self._insertString(prefix.slice(completeOn.length));\n      }\n\n      self._refreshLine();\n    }\n  });\n};\n\n// this = Interface instance\nfunction handleGroup(self, group, width, maxColumns) {\n  if (group.length === 0) {\n    return;\n  }\n  var minRows = Math.ceil(group.length / maxColumns);\n  for (var row = 0; row < minRows; row++) {\n    for (var col = 0; col < maxColumns; col++) {\n      var idx = row * maxColumns + col;\n      if (idx >= group.length) {\n        break;\n      }\n      var item = group[idx];\n      self._writeToOutput(item);\n      if (col < maxColumns - 1) {\n        for (var s = 0, itemLen = item.length; s < width - itemLen;\n             s++) {\n          self._writeToOutput(' ');\n        }\n      }\n    }\n    self._writeToOutput('\\r\\n');\n  }\n  self._writeToOutput('\\r\\n');\n}\n\nfunction commonPrefix(strings) {\n  if (!strings || strings.length === 0) {\n    return '';\n  }\n  if (strings.length === 1) return strings[0];\n  var sorted = strings.slice().sort();\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0, len = min.length; i < len; i++) {\n    if (min[i] !== max[i]) {\n      return min.slice(0, i);\n    }\n  }\n  return min;\n}\n\n\nInterface.prototype._wordLeft = function() {\n  if (this.cursor > 0) {\n    var leading = this.line.slice(0, this.cursor);\n    var match = leading.match(/([^\\w\\s]+|\\w+|)\\s*$/);\n    this._moveCursor(-match[0].length);\n  }\n};\n\n\nInterface.prototype._wordRight = function() {\n  if (this.cursor < this.line.length) {\n    var trailing = this.line.slice(this.cursor);\n    var match = trailing.match(/^(\\s+|\\W+|\\w+)\\s*/);\n    this._moveCursor(match[0].length);\n  }\n};\n\n\nInterface.prototype._deleteLeft = function() {\n  if (this.cursor > 0 && this.line.length > 0) {\n    this.line = this.line.slice(0, this.cursor - 1) +\n                this.line.slice(this.cursor, this.line.length);\n\n    this.cursor--;\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteRight = function() {\n  this.line = this.line.slice(0, this.cursor) +\n              this.line.slice(this.cursor + 1, this.line.length);\n  this._refreshLine();\n};\n\n\nInterface.prototype._deleteWordLeft = function() {\n  if (this.cursor > 0) {\n    var leading = this.line.slice(0, this.cursor);\n    var match = leading.match(/([^\\w\\s]+|\\w+|)\\s*$/);\n    leading = leading.slice(0, leading.length - match[0].length);\n    this.line = leading + this.line.slice(this.cursor, this.line.length);\n    this.cursor = leading.length;\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteWordRight = function() {\n  if (this.cursor < this.line.length) {\n    var trailing = this.line.slice(this.cursor);\n    var match = trailing.match(/^(\\s+|\\W+|\\w+)\\s*/);\n    this.line = this.line.slice(0, this.cursor) +\n                trailing.slice(match[0].length);\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteLineLeft = function() {\n  this.line = this.line.slice(this.cursor);\n  this.cursor = 0;\n  this._refreshLine();\n};\n\n\nInterface.prototype._deleteLineRight = function() {\n  this.line = this.line.slice(0, this.cursor);\n  this._refreshLine();\n};\n\n\nInterface.prototype.clearLine = function() {\n  this._moveCursor(+Infinity);\n  this._writeToOutput('\\r\\n');\n  this.line = '';\n  this.cursor = 0;\n  this.prevRows = 0;\n};\n\n\nInterface.prototype._line = function() {\n  var line = this._addHistory();\n  this.clearLine();\n  this._onLine(line);\n};\n\n\nInterface.prototype._historyNext = function() {\n  if (this.historyIndex > 0) {\n    this.historyIndex--;\n    this.line = this.history[this.historyIndex];\n    this.cursor = this.line.length; // set cursor to end of line.\n    this._refreshLine();\n\n  } else if (this.historyIndex === 0) {\n    this.historyIndex = -1;\n    this.cursor = 0;\n    this.line = '';\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._historyPrev = function() {\n  if (this.historyIndex + 1 < this.history.length) {\n    this.historyIndex++;\n    this.line = this.history[this.historyIndex];\n    this.cursor = this.line.length; // set cursor to end of line.\n\n    this._refreshLine();\n  }\n};\n\n\n// Returns the last character's display position of the given string\nInterface.prototype._getDisplayPos = function(str) {\n  var offset = 0;\n  var col = this.columns;\n  var row = 0;\n  var code;\n  str = stripVTControlCharacters(str);\n  for (var i = 0, len = str.length; i < len; i++) {\n    code = str.codePointAt(i);\n    if (code >= 0x10000) { // surrogates\n      i++;\n    }\n    if (code === 0x0a) { // new line \\n\n      offset = 0;\n      row += 1;\n      continue;\n    }\n    if (isFullWidthCodePoint(code)) {\n      if ((offset + 1) % col === 0) {\n        offset++;\n      }\n      offset += 2;\n    } else {\n      offset++;\n    }\n  }\n  var cols = offset % col;\n  var rows = row + (offset - cols) / col;\n  return {cols: cols, rows: rows};\n};\n\n\n// Returns current cursor's position and line\nInterface.prototype._getCursorPos = function() {\n  var columns = this.columns;\n  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);\n  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));\n  var cols = dispPos.cols;\n  var rows = dispPos.rows;\n  // If the cursor is on a full-width character which steps over the line,\n  // move the cursor to the beginning of the next line.\n  if (cols + 1 === columns &&\n      this.cursor < this.line.length &&\n      isFullWidthCodePoint(this.line.codePointAt(this.cursor))) {\n    rows++;\n    cols = 0;\n  }\n  return {cols: cols, rows: rows};\n};\n\n\n// This function moves cursor dx places to the right\n// (-dx for left) and refreshes the line if it is needed\nInterface.prototype._moveCursor = function(dx) {\n  var oldcursor = this.cursor;\n  var oldPos = this._getCursorPos();\n  this.cursor += dx;\n\n  // bounds check\n  if (this.cursor < 0) this.cursor = 0;\n  else if (this.cursor > this.line.length) this.cursor = this.line.length;\n\n  var newPos = this._getCursorPos();\n\n  // check if cursors are in the same line\n  if (oldPos.rows === newPos.rows) {\n    var diffCursor = this.cursor - oldcursor;\n    var diffWidth;\n    if (diffCursor < 0) {\n      diffWidth = -getStringWidth(\n          this.line.substring(this.cursor, oldcursor)\n          );\n    } else if (diffCursor > 0) {\n      diffWidth = getStringWidth(\n          this.line.substring(this.cursor, oldcursor)\n          );\n    }\n    moveCursor(this.output, diffWidth, 0);\n    this.prevRows = newPos.rows;\n  } else {\n    this._refreshLine();\n  }\n};\n\n\n// handle a write from the tty\nInterface.prototype._ttyWrite = function(s, key) {\n  const previousKey = this._previousKey;\n  key = key || {};\n  this._previousKey = key;\n\n  // Ignore escape key - Fixes #2876\n  if (key.name === 'escape') return;\n\n  if (key.ctrl && key.shift) {\n    /* Control and shift pressed */\n    switch (key.name) {\n      case 'backspace':\n        this._deleteLineLeft();\n        break;\n\n      case 'delete':\n        this._deleteLineRight();\n        break;\n    }\n\n  } else if (key.ctrl) {\n    /* Control key pressed */\n\n    switch (key.name) {\n      case 'c':\n        if (this.listenerCount('SIGINT') > 0) {\n          this.emit('SIGINT');\n        } else {\n          // This readline instance is finished\n          this.close();\n        }\n        break;\n\n      case 'h': // delete left\n        this._deleteLeft();\n        break;\n\n      case 'd': // delete right or EOF\n        if (this.cursor === 0 && this.line.length === 0) {\n          // This readline instance is finished\n          this.close();\n        } else if (this.cursor < this.line.length) {\n          this._deleteRight();\n        }\n        break;\n\n      case 'u': // delete the whole line\n        this.cursor = 0;\n        this.line = '';\n        this._refreshLine();\n        break;\n\n      case 'k': // delete from current to end of line\n        this._deleteLineRight();\n        break;\n\n      case 'a': // go to the start of the line\n        this._moveCursor(-Infinity);\n        break;\n\n      case 'e': // go to the end of the line\n        this._moveCursor(+Infinity);\n        break;\n\n      case 'b': // back one character\n        this._moveCursor(-1);\n        break;\n\n      case 'f': // forward one character\n        this._moveCursor(+1);\n        break;\n\n      case 'l': // clear the whole screen\n        cursorTo(this.output, 0, 0);\n        clearScreenDown(this.output);\n        this._refreshLine();\n        break;\n\n      case 'n': // next history item\n        this._historyNext();\n        break;\n\n      case 'p': // previous history item\n        this._historyPrev();\n        break;\n\n      case 'z':\n        if (process.platform === 'win32') break;\n        if (this.listenerCount('SIGTSTP') > 0) {\n          this.emit('SIGTSTP');\n        } else {\n          process.once('SIGCONT', (function(self) {\n            return function() {\n              // Don't raise events if stream has already been abandoned.\n              if (!self.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                self.pause();\n                self.emit('SIGCONT');\n              }\n              // explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              self._setRawMode(true);\n              self._refreshLine();\n            };\n          })(this));\n          this._setRawMode(false);\n          process.kill(process.pid, 'SIGTSTP');\n        }\n        break;\n\n      case 'w': // delete backwards to a word boundary\n      case 'backspace':\n        this._deleteWordLeft();\n        break;\n\n      case 'delete': // delete forward to a word boundary\n        this._deleteWordRight();\n        break;\n\n      case 'left':\n        this._wordLeft();\n        break;\n\n      case 'right':\n        this._wordRight();\n        break;\n    }\n\n  } else if (key.meta) {\n    /* Meta key pressed */\n\n    switch (key.name) {\n      case 'b': // backward word\n        this._wordLeft();\n        break;\n\n      case 'f': // forward word\n        this._wordRight();\n        break;\n\n      case 'd': // delete forward word\n      case 'delete':\n        this._deleteWordRight();\n        break;\n\n      case 'backspace': // delete backwards to a word boundary\n        this._deleteWordLeft();\n        break;\n    }\n\n  } else {\n    /* No modifier keys used */\n\n    // \\r bookkeeping is only relevant if a \\n comes right after.\n    if (this._sawReturnAt && key.name !== 'enter')\n      this._sawReturnAt = 0;\n\n    switch (key.name) {\n      case 'return':  // carriage return, i.e. \\r\n        this._sawReturnAt = Date.now();\n        this._line();\n        break;\n\n      case 'enter':\n        // When key interval > crlfDelay\n        if (this._sawReturnAt === 0 ||\n            Date.now() - this._sawReturnAt > this.crlfDelay) {\n          this._line();\n        }\n        this._sawReturnAt = 0;\n        break;\n\n      case 'backspace':\n        this._deleteLeft();\n        break;\n\n      case 'delete':\n        this._deleteRight();\n        break;\n\n      case 'left':\n        this._moveCursor(-1);\n        break;\n\n      case 'right':\n        this._moveCursor(+1);\n        break;\n\n      case 'home':\n        this._moveCursor(-Infinity);\n        break;\n\n      case 'end':\n        this._moveCursor(+Infinity);\n        break;\n\n      case 'up':\n        this._historyPrev();\n        break;\n\n      case 'down':\n        this._historyNext();\n        break;\n\n      case 'tab':\n        // If tab completion enabled, do that...\n        if (typeof this.completer === 'function' && this.isCompletionEnabled) {\n          const lastKeypressWasTab = previousKey && previousKey.name === 'tab';\n          this._tabComplete(lastKeypressWasTab);\n          break;\n        }\n        // falls through\n\n      default:\n        if (s instanceof Buffer)\n          s = s.toString('utf-8');\n\n        if (s) {\n          var lines = s.split(/\\r\\n|\\n|\\r/);\n          for (var i = 0, len = lines.length; i < len; i++) {\n            if (i > 0) {\n              this._line();\n            }\n            this._insertString(lines[i]);\n          }\n        }\n    }\n  }\n};\n\n/**\n * accepts a readable Stream instance and makes it emit \"keypress\" events\n */\n\nfunction emitKeypressEvents(stream, iface) {\n  if (stream[KEYPRESS_DECODER]) return;\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\n  stream[KEYPRESS_DECODER] = new StringDecoder('utf8');\n\n  stream[ESCAPE_DECODER] = emitKeys(stream);\n  stream[ESCAPE_DECODER].next();\n\n  const escapeCodeTimeout = () => stream[ESCAPE_DECODER].next('');\n  let timeoutId;\n\n  function onData(b) {\n    if (stream.listenerCount('keypress') > 0) {\n      var r = stream[KEYPRESS_DECODER].write(b);\n      if (r) {\n        clearTimeout(timeoutId);\n\n        if (iface) {\n          iface._sawKeyPress = r.length === 1;\n        }\n\n        for (var i = 0; i < r.length; i++) {\n          if (r[i] === '\\t' && typeof r[i + 1] === 'string' && iface) {\n            iface.isCompletionEnabled = false;\n          }\n\n          try {\n            stream[ESCAPE_DECODER].next(r[i]);\n            // Escape letter at the tail position\n            if (r[i] === kEscape && i + 1 === r.length) {\n              timeoutId = setTimeout(escapeCodeTimeout, ESCAPE_CODE_TIMEOUT);\n            }\n          } catch (err) {\n            // if the generator throws (it could happen in the `keypress`\n            // event), we need to restart it.\n            stream[ESCAPE_DECODER] = emitKeys(stream);\n            stream[ESCAPE_DECODER].next();\n            throw err;\n          } finally {\n            if (iface) {\n              iface.isCompletionEnabled = true;\n            }\n          }\n        }\n      }\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener('data', onData);\n      stream.on('newListener', onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event === 'keypress') {\n      stream.on('data', onData);\n      stream.removeListener('newListener', onNewListener);\n    }\n  }\n\n  if (stream.listenerCount('keypress') > 0) {\n    stream.on('data', onData);\n  } else {\n    stream.on('newListener', onNewListener);\n  }\n}\n\n/**\n * moves the cursor to the x and y coordinate on the given stream\n */\n\nfunction cursorTo(stream, x, y) {\n  if (stream === null || stream === undefined)\n    return;\n\n  if (typeof x !== 'number' && typeof y !== 'number')\n    return;\n\n  if (typeof x !== 'number')\n    throw new Error('Can\\'t set cursor row without also setting it\\'s column');\n\n  if (typeof y !== 'number') {\n    stream.write(CSI`${x + 1}G`);\n  } else {\n    stream.write(CSI`${y + 1};${x + 1}H`);\n  }\n}\n\n/**\n * moves the cursor relative to its current location\n */\n\nfunction moveCursor(stream, dx, dy) {\n  if (stream === null || stream === undefined)\n    return;\n\n  if (dx < 0) {\n    stream.write(CSI`${-dx}D`);\n  } else if (dx > 0) {\n    stream.write(CSI`${dx}C`);\n  }\n\n  if (dy < 0) {\n    stream.write(CSI`${-dy}A`);\n  } else if (dy > 0) {\n    stream.write(CSI`${dy}B`);\n  }\n}\n\n/**\n * clears the current line the cursor is on:\n *   -1 for left of the cursor\n *   +1 for right of the cursor\n *    0 for the entire line\n */\n\nfunction clearLine(stream, dir) {\n  if (stream === null || stream === undefined)\n    return;\n\n  if (dir < 0) {\n    // to the beginning\n    stream.write(kClearToBeginning);\n  } else if (dir > 0) {\n    // to the end\n    stream.write(kClearToEnd);\n  } else {\n    // entire line\n    stream.write(kClearLine);\n  }\n}\n\n/**\n * clears the screen from the current position of the cursor down\n */\n\nfunction clearScreenDown(stream) {\n  if (stream === null || stream === undefined)\n    return;\n\n  stream.write(kClearScreenDown);\n}\n\nmodule.exports = {\n  Interface,\n  clearLine,\n  clearScreenDown,\n  createInterface,\n  cursorTo,\n  emitKeypressEvents,\n  moveCursor\n};\n",
  "repl": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/* A repl library that you can include in your own code to get a runtime\n * interface to your program.\n *\n *   var repl = require(\"repl\");\n *   // start repl on stdin\n *   repl.start(\"prompt> \");\n *\n *   // listen for unix socket connections and start repl on them\n *   net.createServer(function(socket) {\n *     repl.start(\"node via Unix socket> \", socket);\n *   }).listen(\"/tmp/node-repl-sock\");\n *\n *   // listen for TCP socket connections and start repl on them\n *   net.createServer(function(socket) {\n *     repl.start(\"node via TCP socket> \", socket);\n *   }).listen(5001);\n *\n *   // expose foo to repl context\n *   repl.start(\"node > \").context.foo = \"stdin is fun\";\n */\n\n'use strict';\n\nconst internalModule = require('internal/module');\nconst internalUtil = require('internal/util');\nconst util = require('util');\nconst utilBinding = process.binding('util');\nconst inherits = util.inherits;\nconst Stream = require('stream');\nconst vm = require('vm');\nconst path = require('path');\nconst fs = require('fs');\nconst Interface = require('readline').Interface;\nconst Console = require('console').Console;\nconst Module = require('module');\nconst domain = require('domain');\nconst debug = util.debuglog('repl');\n\nconst parentModule = module;\nconst replMap = new WeakMap();\n\nconst GLOBAL_OBJECT_PROPERTIES = [\n  'NaN', 'Infinity', 'undefined', 'eval', 'parseInt', 'parseFloat', 'isNaN',\n  'isFinite', 'decodeURI', 'decodeURIComponent', 'encodeURI',\n  'encodeURIComponent', 'Object', 'Function', 'Array', 'String', 'Boolean',\n  'Number', 'Date', 'RegExp', 'Error', 'EvalError', 'RangeError',\n  'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'Math', 'JSON'\n];\nconst GLOBAL_OBJECT_PROPERTY_MAP = {};\nfor (var n = 0; n < GLOBAL_OBJECT_PROPERTIES.length; n++) {\n  GLOBAL_OBJECT_PROPERTY_MAP[GLOBAL_OBJECT_PROPERTIES[n]] =\n    GLOBAL_OBJECT_PROPERTIES[n];\n}\n\ntry {\n  // hack for require.resolve(\"./relative\") to work properly.\n  module.filename = path.resolve('repl');\n} catch (e) {\n  // path.resolve('repl') fails when the current working directory has been\n  // deleted.  Fall back to the directory name of the (absolute) executable\n  // path.  It's not really correct but what are the alternatives?\n  const dirname = path.dirname(process.execPath);\n  module.filename = path.resolve(dirname, 'repl');\n}\n\n// hack for repl require to work properly with node_modules folders\nmodule.paths = require('module')._nodeModulePaths(module.filename);\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n// Can overridden with custom print functions, such as `probe` or `eyes.js`.\n// This is the default \"writer\" value if none is passed in the REPL options.\nexports.writer = util.inspect;\n\nexports._builtinLibs = internalModule.builtinLibs;\n\n\nfunction REPLServer(prompt,\n                    stream,\n                    eval_,\n                    useGlobal,\n                    ignoreUndefined,\n                    replMode) {\n  if (!(this instanceof REPLServer)) {\n    return new REPLServer(prompt,\n                          stream,\n                          eval_,\n                          useGlobal,\n                          ignoreUndefined,\n                          replMode);\n  }\n\n  var options, input, output, dom, breakEvalOnSigint;\n  if (prompt !== null && typeof prompt === 'object') {\n    // an options object was given\n    options = prompt;\n    stream = options.stream || options.socket;\n    input = options.input;\n    output = options.output;\n    eval_ = options.eval;\n    useGlobal = options.useGlobal;\n    ignoreUndefined = options.ignoreUndefined;\n    prompt = options.prompt;\n    dom = options.domain;\n    replMode = options.replMode;\n    breakEvalOnSigint = options.breakEvalOnSigint;\n  } else {\n    options = {};\n  }\n\n  if (breakEvalOnSigint && eval_) {\n    // Allowing this would not reflect user expectations.\n    // breakEvalOnSigint affects only the behaviour of the default eval().\n    throw new Error('Cannot specify both breakEvalOnSigint and eval for REPL');\n  }\n\n  var self = this;\n\n  self._domain = dom || domain.create();\n\n  self.useGlobal = !!useGlobal;\n  self.ignoreUndefined = !!ignoreUndefined;\n  self.replMode = replMode || exports.REPL_MODE_SLOPPY;\n  self.underscoreAssigned = false;\n  self.last = undefined;\n  self.breakEvalOnSigint = !!breakEvalOnSigint;\n  self.editorMode = false;\n\n  // just for backwards compat, see github.com/joyent/node/pull/7127\n  self.rli = this;\n\n  const savedRegExMatches = ['', '', '', '', '', '', '', '', '', ''];\n  const sep = '\\u0000\\u0000\\u0000';\n  const regExMatcher = new RegExp(`^${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)` +\n                                  `${sep}(.*)${sep}(.*)${sep}(.*)${sep}(.*)` +\n                                  `${sep}(.*)$`);\n\n  eval_ = eval_ || defaultEval;\n\n  function defaultEval(code, context, file, cb) {\n    var err, result, script, wrappedErr;\n    var wrappedCmd = false;\n    var input = code;\n\n    if (/^\\s*\\{/.test(code) && /\\}\\s*$/.test(code)) {\n      // It's confusing for `{ a : 1 }` to be interpreted as a block\n      // statement rather than an object literal.  So, we first try\n      // to wrap it in parentheses, so that it will be interpreted as\n      // an expression.\n      code = `(${code.trim()})\\n`;\n      wrappedCmd = true;\n    }\n\n    // first, create the Script object to check the syntax\n\n    if (code === '\\n')\n      return cb(null);\n\n    while (true) {\n      try {\n        if (!/^\\s*$/.test(code) &&\n            self.replMode === exports.REPL_MODE_STRICT) {\n          // \"void 0\" keeps the repl from returning \"use strict\" as the result\n          // value for statements and declarations that don't return a value.\n          code = `'use strict'; void 0;\\n${code}`;\n        }\n        script = vm.createScript(code, {\n          filename: file,\n          displayErrors: true\n        });\n      } catch (e) {\n        debug('parse error %j', code, e);\n        if (wrappedCmd) {\n          wrappedCmd = false;\n          // unwrap and try again\n          code = input;\n          wrappedErr = e;\n          continue;\n        }\n        // preserve original error for wrapped command\n        const error = wrappedErr || e;\n        if (isRecoverableError(error, code))\n          err = new Recoverable(error);\n        else\n          err = error;\n      }\n      break;\n    }\n\n    // This will set the values from `savedRegExMatches` to corresponding\n    // predefined RegExp properties `RegExp.$1`, `RegExp.$2` ... `RegExp.$9`\n    regExMatcher.test(savedRegExMatches.join(sep));\n\n    if (!err) {\n      // Unset raw mode during evaluation so that Ctrl+C raises a signal.\n      let previouslyInRawMode;\n      if (self.breakEvalOnSigint) {\n        // Start the SIGINT watchdog before entering raw mode so that a very\n        // quick Ctrl+C doesn't lead to aborting the process completely.\n        utilBinding.startSigintWatchdog();\n        previouslyInRawMode = self._setRawMode(false);\n      }\n\n      try {\n        try {\n          const scriptOptions = {\n            displayErrors: false,\n            breakOnSigint: self.breakEvalOnSigint\n          };\n\n          if (self.useGlobal) {\n            result = script.runInThisContext(scriptOptions);\n          } else {\n            result = script.runInContext(context, scriptOptions);\n          }\n        } finally {\n          if (self.breakEvalOnSigint) {\n            // Reset terminal mode to its previous value.\n            self._setRawMode(previouslyInRawMode);\n\n            // Returns true if there were pending SIGINTs *after* the script\n            // has terminated without being interrupted itself.\n            if (utilBinding.stopSigintWatchdog()) {\n              self.emit('SIGINT');\n            }\n          }\n        }\n      } catch (e) {\n        err = e;\n        if (err.message === 'Script execution interrupted.') {\n          // The stack trace for this case is not very useful anyway.\n          Object.defineProperty(err, 'stack', { value: '' });\n        }\n\n        if (err && process.domain) {\n          debug('not recoverable, send to domain');\n          process.domain.emit('error', err);\n          process.domain.exit();\n          return;\n        }\n      }\n    }\n\n    // After executing the current expression, store the values of RegExp\n    // predefined properties back in `savedRegExMatches`\n    for (var idx = 1; idx < savedRegExMatches.length; idx += 1) {\n      savedRegExMatches[idx] = RegExp[`$${idx}`];\n    }\n\n    cb(err, result);\n  }\n\n  self.eval = self._domain.bind(eval_);\n\n  self._domain.on('error', function debugDomainError(e) {\n    debug('domain error');\n    const top = replMap.get(self);\n    internalUtil.decorateErrorStack(e);\n    if (e instanceof SyntaxError && e.stack) {\n      // remove repl:line-number and stack trace\n      e.stack = e.stack\n                 .replace(/^repl:\\d+\\r?\\n/, '')\n                 .replace(/^\\s+at\\s.*\\n?/gm, '');\n    } else if (e.stack && self.replMode === exports.REPL_MODE_STRICT) {\n      e.stack = e.stack.replace(/(\\s+at\\s+repl:)(\\d+)/,\n                                (_, pre, line) => pre + (line - 1));\n    }\n    top.outputStream.write((e.stack || e) + '\\n');\n    top.bufferedCommand = '';\n    top.lines.level = [];\n    top.displayPrompt();\n  });\n\n  if (!input && !output) {\n    // legacy API, passing a 'stream'/'socket' option\n    if (!stream) {\n      // use stdin and stdout as the default streams if none were given\n      stream = process;\n    }\n    if (stream.stdin && stream.stdout) {\n      // We're given custom object with 2 streams, or the `process` object\n      input = stream.stdin;\n      output = stream.stdout;\n    } else {\n      // We're given a duplex readable/writable Stream, like a `net.Socket`\n      input = stream;\n      output = stream;\n    }\n  }\n\n  self.inputStream = input;\n  self.outputStream = output;\n\n  self.resetContext();\n  self.bufferedCommand = '';\n  self.lines.level = [];\n\n  // Figure out which \"complete\" function to use.\n  self.completer = (typeof options.completer === 'function') ?\n    options.completer : completer;\n\n  function completer(text, cb) {\n    complete.call(self, text, self.editorMode ?\n      self.completeOnEditorMode(cb) : cb);\n  }\n\n  Interface.call(this, {\n    input: self.inputStream,\n    output: self.outputStream,\n    completer: self.completer,\n    terminal: options.terminal,\n    historySize: options.historySize,\n    prompt\n  });\n\n  this.commands = Object.create(null);\n  defineDefaultCommands(this);\n\n  // figure out which \"writer\" function to use\n  self.writer = options.writer || exports.writer;\n\n  if (options.useColors === undefined) {\n    options.useColors = self.terminal;\n  }\n  self.useColors = !!options.useColors;\n\n  if (self.useColors && self.writer === util.inspect) {\n    // Turn on ANSI coloring.\n    self.writer = function(obj, showHidden, depth) {\n      return util.inspect(obj, showHidden, depth, true);\n    };\n  }\n\n  self.on('close', function emitExit() {\n    self.emit('exit');\n  });\n\n  var sawSIGINT = false;\n  var sawCtrlD = false;\n  self.on('SIGINT', function onSigInt() {\n    var empty = self.line.length === 0;\n    self.clearLine();\n    self.turnOffEditorMode();\n\n    if (!(self.bufferedCommand && self.bufferedCommand.length > 0) && empty) {\n      if (sawSIGINT) {\n        self.close();\n        sawSIGINT = false;\n        return;\n      }\n      self.output.write('(To exit, press ^C again or type .exit)\\n');\n      sawSIGINT = true;\n    } else {\n      sawSIGINT = false;\n    }\n\n    self.bufferedCommand = '';\n    self.lines.level = [];\n    self.displayPrompt();\n  });\n\n  self.on('line', function onLine(cmd) {\n    debug('line %j', cmd);\n    cmd = cmd || '';\n    sawSIGINT = false;\n\n    if (self.editorMode) {\n      self.bufferedCommand += cmd + '\\n';\n\n      // code alignment\n      const matches = self._sawKeyPress ? cmd.match(/^\\s+/) : null;\n      if (matches) {\n        const prefix = matches[0];\n        self.write(prefix);\n        self.line = prefix;\n        self.cursor = prefix.length;\n      }\n      self.memory(cmd);\n      return;\n    }\n\n    // Check REPL keywords and empty lines against a trimmed line input.\n    const trimmedCmd = cmd.trim();\n\n    // Check to see if a REPL keyword was used. If it returns true,\n    // display next prompt and return.\n    if (trimmedCmd) {\n      if (trimmedCmd.charAt(0) === '.' && isNaN(parseFloat(trimmedCmd))) {\n        const matches = trimmedCmd.match(/^\\.([^\\s]+)\\s*(.*)$/);\n        const keyword = matches && matches[1];\n        const rest = matches && matches[2];\n        if (self.parseREPLKeyword(keyword, rest) === true) {\n          return;\n        }\n        if (!self.bufferedCommand) {\n          self.outputStream.write('Invalid REPL keyword\\n');\n          finish(null);\n          return;\n        }\n      }\n    }\n\n    const evalCmd = self.bufferedCommand + cmd + '\\n';\n\n    debug('eval %j', evalCmd);\n    self.eval(evalCmd, self.context, 'repl', finish);\n\n    function finish(e, ret) {\n      debug('finish', e, ret);\n      self.memory(cmd);\n\n      if (e && !self.bufferedCommand && cmd.trim().startsWith('npm ')) {\n        self.outputStream.write('npm should be run outside of the ' +\n                                'node repl, in your normal shell.\\n' +\n                                '(Press Control-D to exit.)\\n');\n        self.bufferedCommand = '';\n        self.displayPrompt();\n        return;\n      }\n\n      // If error was SyntaxError and not JSON.parse error\n      if (e) {\n        if (e instanceof Recoverable && !sawCtrlD) {\n          // Start buffering data like that:\n          // {\n          // ...  x: 1\n          // ... }\n          self.bufferedCommand += cmd + '\\n';\n          self.displayPrompt();\n          return;\n        } else {\n          self._domain.emit('error', e.err || e);\n        }\n      }\n\n      // Clear buffer if no SyntaxErrors\n      self.bufferedCommand = '';\n      sawCtrlD = false;\n\n      // If we got any output - print it (if no error)\n      if (!e &&\n          // When an invalid REPL command is used, error message is printed\n          // immediately. We don't have to print anything else. So, only when\n          // the second argument to this function is there, print it.\n          arguments.length === 2 &&\n          (!self.ignoreUndefined || ret !== undefined)) {\n        if (!self.underscoreAssigned) {\n          self.last = ret;\n        }\n        self.outputStream.write(self.writer(ret) + '\\n');\n      }\n\n      // Display prompt again\n      self.displayPrompt();\n    }\n  });\n\n  self.on('SIGCONT', function onSigCont() {\n    if (self.editorMode) {\n      self.outputStream.write(`${self._initialPrompt}.editor\\n`);\n      self.outputStream.write(\n        '// Entering editor mode (^D to finish, ^C to cancel)\\n');\n      self.outputStream.write(`${self.bufferedCommand}\\n`);\n      self.prompt(true);\n    } else {\n      self.displayPrompt(true);\n    }\n  });\n\n  // Wrap readline tty to enable editor mode\n  const ttyWrite = self._ttyWrite.bind(self);\n  self._ttyWrite = (d, key) => {\n    key = key || {};\n    if (!self.editorMode || !self.terminal) {\n      ttyWrite(d, key);\n      return;\n    }\n\n    // editor mode\n    if (key.ctrl && !key.shift) {\n      switch (key.name) {\n        case 'd': // End editor mode\n          self.turnOffEditorMode();\n          sawCtrlD = true;\n          ttyWrite(d, { name: 'return' });\n          break;\n        case 'n': // Override next history item\n        case 'p': // Override previous history item\n          break;\n        default:\n          ttyWrite(d, key);\n      }\n    } else {\n      switch (key.name) {\n        case 'up':   // Override previous history item\n        case 'down': // Override next history item\n          break;\n        case 'tab':\n          // prevent double tab behavior\n          self._previousKey = null;\n          ttyWrite(d, key);\n          break;\n        default:\n          ttyWrite(d, key);\n      }\n    }\n  };\n\n  self.displayPrompt();\n}\ninherits(REPLServer, Interface);\nexports.REPLServer = REPLServer;\n\nexports.REPL_MODE_SLOPPY = Symbol('repl-sloppy');\nexports.REPL_MODE_STRICT = Symbol('repl-strict');\nexports.REPL_MODE_MAGIC = exports.REPL_MODE_SLOPPY;\n\n// prompt is a string to print on each line for the prompt,\n// source is a stream to use for I/O, defaulting to stdin/stdout.\nexports.start = function(prompt,\n                         source,\n                         eval_,\n                         useGlobal,\n                         ignoreUndefined,\n                         replMode) {\n  var repl = new REPLServer(prompt,\n                            source,\n                            eval_,\n                            useGlobal,\n                            ignoreUndefined,\n                            replMode);\n  if (!exports.repl) exports.repl = repl;\n  replMap.set(repl, repl);\n  return repl;\n};\n\nREPLServer.prototype.close = function close() {\n  if (this.terminal && this._flushing && !this._closingOnFlush) {\n    this._closingOnFlush = true;\n    this.once('flushHistory', () =>\n      Interface.prototype.close.call(this)\n    );\n\n    return;\n  }\n  process.nextTick(() =>\n    Interface.prototype.close.call(this)\n  );\n};\n\nREPLServer.prototype.createContext = function() {\n  var context;\n  if (this.useGlobal) {\n    context = global;\n  } else {\n    context = vm.createContext();\n    context.global = context;\n    const _console = new Console(this.outputStream);\n    Object.defineProperty(context, 'console', {\n      configurable: true,\n      enumerable: true,\n      get: () => _console\n    });\n\n    var names = Object.getOwnPropertyNames(global);\n    for (var n = 0; n < names.length; n++) {\n      var name = names[n];\n      if (name === 'console' || name === 'global')\n        continue;\n      if (GLOBAL_OBJECT_PROPERTY_MAP[name] === undefined) {\n        Object.defineProperty(context, name,\n                              Object.getOwnPropertyDescriptor(global, name));\n      }\n    }\n  }\n\n  var module = new Module('<repl>');\n  module.paths = Module._resolveLookupPaths('<repl>', parentModule, true) || [];\n\n  var require = internalModule.makeRequireFunction(module);\n  context.module = module;\n  context.require = require;\n\n\n  this.underscoreAssigned = false;\n  this.lines = [];\n  this.lines.level = [];\n\n  internalModule.addBuiltinLibsToObject(context);\n\n  Object.defineProperty(context, '_', {\n    configurable: true,\n    get: () => this.last,\n    set: (value) => {\n      this.last = value;\n      if (!this.underscoreAssigned) {\n        this.underscoreAssigned = true;\n        this.outputStream.write('Expression assignment to _ now disabled.\\n');\n      }\n    }\n  });\n\n  return context;\n};\n\nREPLServer.prototype.resetContext = function() {\n  this.context = this.createContext();\n\n  // Allow REPL extensions to extend the new context\n  this.emit('reset', this.context);\n};\n\nREPLServer.prototype.displayPrompt = function(preserveCursor) {\n  var prompt = this._initialPrompt;\n  if (this.bufferedCommand.length) {\n    prompt = '...';\n    const len = this.lines.level.length ? this.lines.level.length - 1 : 0;\n    const levelInd = '..'.repeat(len);\n    prompt += levelInd + ' ';\n  }\n\n  // Do not overwrite `_initialPrompt` here\n  REPLServer.super_.prototype.setPrompt.call(this, prompt);\n  this.prompt(preserveCursor);\n};\n\n// When invoked as an API method, overwrite _initialPrompt\nREPLServer.prototype.setPrompt = function setPrompt(prompt) {\n  this._initialPrompt = prompt;\n  REPLServer.super_.prototype.setPrompt.call(this, prompt);\n};\n\nREPLServer.prototype.turnOffEditorMode = function() {\n  this.editorMode = false;\n  this.setPrompt(this._initialPrompt);\n};\n\n\n// A stream to push an array into a REPL\n// used in REPLServer.complete\nfunction ArrayStream() {\n  Stream.call(this);\n\n  this.run = function(data) {\n    for (var n = 0; n < data.length; n++)\n      this.emit('data', `${data[n]}\\n`);\n  };\n}\nutil.inherits(ArrayStream, Stream);\nArrayStream.prototype.readable = true;\nArrayStream.prototype.writable = true;\nArrayStream.prototype.resume = function() {};\nArrayStream.prototype.write = function() {};\n\nconst requireRE = /\\brequire\\s*\\(['\"](([\\w@./-]+\\/)?([\\w@./-]*))/;\nconst simpleExpressionRE =\n    /(([a-zA-Z_$](?:\\w|\\$)*)\\.)*([a-zA-Z_$](?:\\w|\\$)*)\\.?$/;\n\nfunction intFilter(item) {\n  // filters out anything not starting with A-Z, a-z, $ or _\n  return /^[A-Za-z_$]/.test(item);\n}\n\nfunction filteredOwnPropertyNames(obj) {\n  if (!obj) return [];\n  return Object.getOwnPropertyNames(obj).filter(intFilter);\n}\n\nREPLServer.prototype.complete = function() {\n  this.completer.apply(this, arguments);\n};\n\n// Provide a list of completions for the given leading text. This is\n// given to the readline interface for handling tab completion.\n//\n// Example:\n//  complete('var foo = util.')\n//    -> [['util.print', 'util.debug', 'util.log', 'util.inspect'],\n//        'util.' ]\n//\n// Warning: This eval's code like \"foo.bar.baz\", so it will run property\n// getter code.\nfunction complete(line, callback) {\n  // There may be local variables to evaluate, try a nested REPL\n  if (this.bufferedCommand !== undefined && this.bufferedCommand.length) {\n    // Get a new array of inputed lines\n    var tmp = this.lines.slice();\n    // Kill off all function declarations to push all local variables into\n    // global scope\n    for (var n = 0; n < this.lines.level.length; n++) {\n      var kill = this.lines.level[n];\n      if (kill.isFunction)\n        tmp[kill.line] = '';\n    }\n    var flat = new ArrayStream();         // make a new \"input\" stream\n    var magic = new REPLServer('', flat); // make a nested REPL\n    replMap.set(magic, replMap.get(this));\n    magic.context = magic.createContext();\n    flat.run(tmp);                        // eval the flattened code\n    // all this is only profitable if the nested REPL\n    // does not have a bufferedCommand\n    if (!magic.bufferedCommand) {\n      return magic.complete(line, callback);\n    }\n  }\n\n  var completions;\n\n  // list of completion lists, one for each inheritance \"level\"\n  var completionGroups = [];\n\n  var completeOn, i, group, c;\n\n  // REPL commands (e.g. \".break\").\n  var match = null;\n  match = line.match(/^\\s*\\.(\\w*)$/);\n  if (match) {\n    completionGroups.push(Object.keys(this.commands));\n    completeOn = match[1];\n    if (match[1].length) {\n      filter = match[1];\n    }\n\n    completionGroupsLoaded();\n  } else if (match = line.match(requireRE)) {\n    // require('...<Tab>')\n    const exts = Object.keys(this.context.require.extensions);\n    var indexRe = new RegExp('^index(' + exts.map(regexpEscape).join('|') +\n                             ')$');\n\n    completeOn = match[1];\n    var subdir = match[2] || '';\n    var filter = match[1];\n    var dir, files, f, name, base, ext, abs, subfiles, s;\n    group = [];\n    var paths = module.paths.concat(require('module').globalPaths);\n    for (i = 0; i < paths.length; i++) {\n      dir = path.resolve(paths[i], subdir);\n      try {\n        files = fs.readdirSync(dir);\n      } catch (e) {\n        continue;\n      }\n      for (f = 0; f < files.length; f++) {\n        name = files[f];\n        ext = path.extname(name);\n        base = name.slice(0, -ext.length);\n        if (base.match(/-\\d+\\.\\d+(\\.\\d+)?/) || name === '.npm') {\n          // Exclude versioned names that 'npm' installs.\n          continue;\n        }\n        if (exts.indexOf(ext) !== -1) {\n          if (!subdir || base !== 'index') {\n            group.push(subdir + base);\n          }\n        } else {\n          abs = path.resolve(dir, name);\n          try {\n            if (fs.statSync(abs).isDirectory()) {\n              group.push(subdir + name + '/');\n              subfiles = fs.readdirSync(abs);\n              for (s = 0; s < subfiles.length; s++) {\n                if (indexRe.test(subfiles[s])) {\n                  group.push(subdir + name);\n                }\n              }\n            }\n          } catch (e) {}\n        }\n      }\n    }\n    if (group.length) {\n      completionGroups.push(group);\n    }\n\n    if (!subdir) {\n      completionGroups.push(exports._builtinLibs);\n    }\n\n    completionGroupsLoaded();\n\n  // Handle variable member lookup.\n  // We support simple chained expressions like the following (no function\n  // calls, etc.). That is for simplicity and also because we *eval* that\n  // leading expression so for safety (see WARNING above) don't want to\n  // eval function calls.\n  //\n  //   foo.bar<|>     # completions for 'foo' with filter 'bar'\n  //   spam.eggs.<|>  # completions for 'spam.eggs' with filter ''\n  //   foo<|>         # all scope vars with filter 'foo'\n  //   foo.<|>        # completions for 'foo' with filter ''\n  } else if (line.length === 0 || line[line.length - 1].match(/\\w|\\.|\\$/)) {\n    match = simpleExpressionRE.exec(line);\n    if (line.length === 0 || match) {\n      var expr;\n      completeOn = (match ? match[0] : '');\n      if (line.length === 0) {\n        filter = '';\n        expr = '';\n      } else if (line[line.length - 1] === '.') {\n        filter = '';\n        expr = match[0].slice(0, match[0].length - 1);\n      } else {\n        var bits = match[0].split('.');\n        filter = bits.pop();\n        expr = bits.join('.');\n      }\n\n      // Resolve expr and get its completions.\n      var memberGroups = [];\n      if (!expr) {\n        // If context is instance of vm.ScriptContext\n        // Get global vars synchronously\n        if (this.useGlobal || vm.isContext(this.context)) {\n          var contextProto = this.context;\n          while (contextProto = Object.getPrototypeOf(contextProto)) {\n            completionGroups.push(filteredOwnPropertyNames(contextProto));\n          }\n          completionGroups.push(filteredOwnPropertyNames(this.context));\n          addStandardGlobals(completionGroups, filter);\n          completionGroupsLoaded();\n        } else {\n          this.eval('.scope', this.context, 'repl', function ev(err, globals) {\n            if (err || !Array.isArray(globals)) {\n              addStandardGlobals(completionGroups, filter);\n            } else if (Array.isArray(globals[0])) {\n              // Add grouped globals\n              for (var n = 0; n < globals.length; n++)\n                completionGroups.push(globals[n]);\n            } else {\n              completionGroups.push(globals);\n              addStandardGlobals(completionGroups, filter);\n            }\n            completionGroupsLoaded();\n          });\n        }\n      } else {\n        const evalExpr = `try { ${expr} } catch (e) {}`;\n        this.eval(evalExpr, this.context, 'repl', function doEval(e, obj) {\n          // if (e) console.log(e);\n\n          if (obj != null) {\n            if (typeof obj === 'object' || typeof obj === 'function') {\n              try {\n                memberGroups.push(filteredOwnPropertyNames(obj));\n              } catch (ex) {\n                // Probably a Proxy object without `getOwnPropertyNames` trap.\n                // We simply ignore it here, as we don't want to break the\n                // autocompletion. Fixes the bug\n                // https://github.com/nodejs/node/issues/2119\n              }\n            }\n            // works for non-objects\n            try {\n              var sentinel = 5;\n              var p;\n              if (typeof obj === 'object' || typeof obj === 'function') {\n                p = Object.getPrototypeOf(obj);\n              } else {\n                p = obj.constructor ? obj.constructor.prototype : null;\n              }\n              while (p !== null) {\n                memberGroups.push(filteredOwnPropertyNames(p));\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n                if (sentinel <= 0) {\n                  break;\n                }\n              }\n            } catch (e) {\n              //console.log(\"completion error walking prototype chain:\" + e);\n            }\n          }\n\n          if (memberGroups.length) {\n            for (i = 0; i < memberGroups.length; i++) {\n              completionGroups.push(memberGroups[i].map(function(member) {\n                return expr + '.' + member;\n              }));\n            }\n            if (filter) {\n              filter = expr + '.' + filter;\n            }\n          }\n\n          completionGroupsLoaded();\n        });\n      }\n    } else {\n      completionGroupsLoaded();\n    }\n  } else {\n    completionGroupsLoaded();\n  }\n\n  // Will be called when all completionGroups are in place\n  // Useful for async autocompletion\n  function completionGroupsLoaded(err) {\n    if (err) throw err;\n\n    // Filter, sort (within each group), uniq and merge the completion groups.\n    if (completionGroups.length && filter) {\n      var newCompletionGroups = [];\n      for (i = 0; i < completionGroups.length; i++) {\n        group = completionGroups[i].filter(function(elem) {\n          return elem.indexOf(filter) === 0;\n        });\n        if (group.length) {\n          newCompletionGroups.push(group);\n        }\n      }\n      completionGroups = newCompletionGroups;\n    }\n\n    if (completionGroups.length) {\n      var uniq = {};  // unique completions across all groups\n      completions = [];\n      // Completion group 0 is the \"closest\"\n      // (least far up the inheritance chain)\n      // so we put its completions last: to be closest in the REPL.\n      for (i = completionGroups.length - 1; i >= 0; i--) {\n        group = completionGroups[i];\n        group.sort();\n        for (var j = 0; j < group.length; j++) {\n          c = group[j];\n          if (!hasOwnProperty(uniq, c)) {\n            completions.push(c);\n            uniq[c] = true;\n          }\n        }\n        completions.push(''); // separator btwn groups\n      }\n      while (completions.length && completions[completions.length - 1] === '') {\n        completions.pop();\n      }\n    }\n\n    callback(null, [completions || [], completeOn]);\n  }\n}\n\nfunction longestCommonPrefix(arr = []) {\n  const cnt = arr.length;\n  if (cnt === 0) return '';\n  if (cnt === 1) return arr[0];\n\n  const first = arr[0];\n  // complexity: O(m * n)\n  for (var m = 0; m < first.length; m++) {\n    const c = first[m];\n    for (var n = 1; n < cnt; n++) {\n      const entry = arr[n];\n      if (m >= entry.length || c !== entry[m]) {\n        return first.substring(0, m);\n      }\n    }\n  }\n  return first;\n}\n\nREPLServer.prototype.completeOnEditorMode = (callback) => (err, results) => {\n  if (err) return callback(err);\n\n  const [completions, completeOn = ''] = results;\n  const prefixLength = completeOn.length;\n\n  if (prefixLength === 0) return callback(null, [[], completeOn]);\n\n  const isNotEmpty = (v) => v.length > 0;\n  const trimCompleteOnPrefix = (v) => v.substring(prefixLength);\n  const data = completions.filter(isNotEmpty).map(trimCompleteOnPrefix);\n\n  callback(null, [[`${completeOn}${longestCommonPrefix(data)}`], completeOn]);\n};\n\n/**\n * Used to parse and execute the Node REPL commands.\n *\n * @param {keyword} keyword The command entered to check.\n * @return {Boolean} If true it means don't continue parsing the command.\n */\nREPLServer.prototype.parseREPLKeyword = function(keyword, rest) {\n  var cmd = this.commands[keyword];\n  if (cmd) {\n    cmd.action.call(this, rest);\n    return true;\n  }\n  return false;\n};\n\n\nREPLServer.prototype.defineCommand = function(keyword, cmd) {\n  if (typeof cmd === 'function') {\n    cmd = {action: cmd};\n  } else if (typeof cmd.action !== 'function') {\n    throw new Error('Bad argument, \"action\" command must be a function');\n  }\n  this.commands[keyword] = cmd;\n};\n\nREPLServer.prototype.memory = function memory(cmd) {\n  var self = this;\n\n  self.lines = self.lines || [];\n  self.lines.level = self.lines.level || [];\n\n  // save the line so I can do magic later\n  if (cmd) {\n    // TODO should I tab the level?\n    const len = self.lines.level.length ? self.lines.level.length - 1 : 0;\n    self.lines.push('  '.repeat(len) + cmd);\n  } else {\n    // I don't want to not change the format too much...\n    self.lines.push('');\n  }\n\n  // I need to know \"depth.\"\n  // Because I can not tell the difference between a } that\n  // closes an object literal and a } that closes a function\n  if (cmd) {\n    // going down is { and (   e.g. function() {\n    // going up is } and )\n    var dw = cmd.match(/{|\\(/g);\n    var up = cmd.match(/}|\\)/g);\n    up = up ? up.length : 0;\n    dw = dw ? dw.length : 0;\n    var depth = dw - up;\n\n    if (depth) {\n      (function workIt() {\n        if (depth > 0) {\n          // going... down.\n          // push the line#, depth count, and if the line is a function.\n          // Since JS only has functional scope I only need to remove\n          // \"function() {\" lines, clearly this will not work for\n          // \"function()\n          // {\" but nothing should break, only tab completion for local\n          // scope will not work for this function.\n          self.lines.level.push({\n            line: self.lines.length - 1,\n            depth: depth,\n            isFunction: /\\s*function\\s*/.test(cmd)\n          });\n        } else if (depth < 0) {\n          // going... up.\n          var curr = self.lines.level.pop();\n          if (curr) {\n            var tmp = curr.depth + depth;\n            if (tmp < 0) {\n              //more to go, recurse\n              depth += curr.depth;\n              workIt();\n            } else if (tmp > 0) {\n              //remove and push back\n              curr.depth += depth;\n              self.lines.level.push(curr);\n            }\n          }\n        }\n      }());\n    }\n\n    // it is possible to determine a syntax error at this point.\n    // if the REPL still has a bufferedCommand and\n    // self.lines.level.length === 0\n    // TODO? keep a log of level so that any syntax breaking lines can\n    // be cleared on .break and in the case of a syntax error?\n    // TODO? if a log was kept, then I could clear the bufferedCommand and\n    // eval these lines and throw the syntax error\n  } else {\n    self.lines.level = [];\n  }\n};\n\nfunction addStandardGlobals(completionGroups, filter) {\n  // Global object properties\n  // (http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n  completionGroups.push(GLOBAL_OBJECT_PROPERTIES);\n  // Common keywords. Exclude for completion on the empty string, b/c\n  // they just get in the way.\n  if (filter) {\n    completionGroups.push([\n      'break', 'case', 'catch', 'const', 'continue', 'debugger', 'default',\n      'delete', 'do', 'else', 'export', 'false', 'finally', 'for', 'function',\n      'if', 'import', 'in', 'instanceof', 'let', 'new', 'null', 'return',\n      'switch', 'this', 'throw', 'true', 'try', 'typeof', 'undefined', 'var',\n      'void', 'while', 'with', 'yield'\n    ]);\n  }\n}\n\nfunction defineDefaultCommands(repl) {\n  repl.defineCommand('break', {\n    help: 'Sometimes you get stuck, this gets you out',\n    action: function() {\n      this.bufferedCommand = '';\n      this.displayPrompt();\n    }\n  });\n\n  var clearMessage;\n  if (repl.useGlobal) {\n    clearMessage = 'Alias for .break';\n  } else {\n    clearMessage = 'Break, and also clear the local context';\n  }\n  repl.defineCommand('clear', {\n    help: clearMessage,\n    action: function() {\n      this.bufferedCommand = '';\n      if (!this.useGlobal) {\n        this.outputStream.write('Clearing context...\\n');\n        this.resetContext();\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('exit', {\n    help: 'Exit the repl',\n    action: function() {\n      this.close();\n    }\n  });\n\n  repl.defineCommand('help', {\n    help: 'Print this help message',\n    action: function() {\n      const names = Object.keys(this.commands).sort();\n      const longestNameLength = names.reduce(\n        (max, name) => Math.max(max, name.length),\n        0\n      );\n      for (var n = 0; n < names.length; n++) {\n        var name = names[n];\n        var cmd = this.commands[name];\n        var spaces = ' '.repeat(longestNameLength - name.length + 3);\n        var line = `.${name}${cmd.help ? spaces + cmd.help : ''}\\n`;\n        this.outputStream.write(line);\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('save', {\n    help: 'Save all evaluated commands in this REPL session to a file',\n    action: function(file) {\n      try {\n        fs.writeFileSync(file, this.lines.join('\\n') + '\\n');\n        this.outputStream.write('Session saved to:' + file + '\\n');\n      } catch (e) {\n        this.outputStream.write('Failed to save:' + file + '\\n');\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('load', {\n    help: 'Load JS from a file into the REPL session',\n    action: function(file) {\n      try {\n        var stats = fs.statSync(file);\n        if (stats && stats.isFile()) {\n          var data = fs.readFileSync(file, 'utf8');\n          var lines = data.split('\\n');\n          this.displayPrompt();\n          for (var n = 0; n < lines.length; n++) {\n            if (lines[n])\n              this.write(`${lines[n]}\\n`);\n          }\n        } else {\n          this.outputStream.write('Failed to load:' + file +\n                                  ' is not a valid file\\n');\n        }\n      } catch (e) {\n        this.outputStream.write('Failed to load:' + file + '\\n');\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('editor', {\n    help: 'Enter editor mode',\n    action() {\n      if (!this.terminal) return;\n      this.editorMode = true;\n      REPLServer.super_.prototype.setPrompt.call(this, '');\n      this.outputStream.write(\n        '// Entering editor mode (^D to finish, ^C to cancel)\\n');\n    }\n  });\n}\n\nfunction regexpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n\n/**\n * Converts commands that use var and function <name>() to use the\n * local exports.context when evaled. This provides a local context\n * on the REPL.\n *\n * @param {String} cmd The cmd to convert.\n * @return {String} The converted command.\n */\n// TODO(princejwesley): Remove it prior to v8.0.0 release\n// Reference: https://github.com/nodejs/node/pull/7829\nREPLServer.prototype.convertToContext = util.deprecate(function(cmd) {\n  const scopeVar = /^\\s*var\\s*([\\w$]+)(.*)$/m;\n  const scopeFunc = /^\\s*function\\s*([\\w$]+)/;\n  var matches;\n\n  // Replaces: var foo = \"bar\";  with: self.context.foo = bar;\n  matches = scopeVar.exec(cmd);\n  if (matches && matches.length === 3) {\n    return 'self.context.' + matches[1] + matches[2];\n  }\n\n  // Replaces: function foo() {};  with: foo = function foo() {};\n  matches = scopeFunc.exec(this.bufferedCommand);\n  if (matches && matches.length === 2) {\n    return matches[1] + ' = ' + this.bufferedCommand;\n  }\n\n  return cmd;\n}, 'replServer.convertToContext() is deprecated', 'DEP0024');\n\n// If the error is that we've unexpectedly ended the input,\n// then let the user try to recover by adding more input.\nfunction isRecoverableError(e, code) {\n  if (e && e.name === 'SyntaxError') {\n    var message = e.message;\n    if (message === 'Unterminated template literal' ||\n        message === 'Missing } in template expression') {\n      return true;\n    }\n\n    if (message.startsWith('Unexpected end of input') ||\n        message.startsWith('missing ) after argument list') ||\n        message.startsWith('Unexpected token'))\n      return true;\n\n    if (message === 'Invalid or unexpected token')\n      return isCodeRecoverable(code);\n  }\n  return false;\n}\n\n// Check whether a code snippet should be forced to fail in the REPL.\nfunction isCodeRecoverable(code) {\n  var current, previous, stringLiteral;\n  var isBlockComment = false;\n  var isSingleComment = false;\n  var isRegExpLiteral = false;\n  var lastChar = code.charAt(code.length - 2);\n  var prevTokenChar = null;\n\n  for (var i = 0; i < code.length; i++) {\n    previous = current;\n    current = code[i];\n\n    if (previous === '\\\\' && (stringLiteral || isRegExpLiteral)) {\n      current = null;\n      continue;\n    }\n\n    if (stringLiteral) {\n      if (stringLiteral === current) {\n        stringLiteral = null;\n      }\n      continue;\n    } else {\n      if (isRegExpLiteral && current === '/') {\n        isRegExpLiteral = false;\n        continue;\n      }\n\n      if (isBlockComment && previous === '*' && current === '/') {\n        isBlockComment = false;\n        continue;\n      }\n\n      if (isSingleComment && current === '\\n') {\n        isSingleComment = false;\n        continue;\n      }\n\n      if (isBlockComment || isRegExpLiteral || isSingleComment) continue;\n\n      if (current === '/' && previous === '/') {\n        isSingleComment = true;\n        continue;\n      }\n\n      if (previous === '/') {\n        if (current === '*') {\n          isBlockComment = true;\n        } else if (\n          // Distinguish between a division operator and the start of a regex\n          // by examining the non-whitespace character that precedes the /\n          [null, '(', '[', '{', '}', ';'].includes(prevTokenChar)\n        ) {\n          isRegExpLiteral = true;\n        }\n        continue;\n      }\n\n      if (current.trim()) prevTokenChar = current;\n    }\n\n    if (current === '\\'' || current === '\"') {\n      stringLiteral = current;\n    }\n  }\n\n  return stringLiteral ? lastChar === '\\\\' : isBlockComment;\n}\n\nfunction Recoverable(err) {\n  this.err = err;\n}\ninherits(Recoverable, SyntaxError);\nexports.Recoverable = Recoverable;\n",
  "stream": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\n// Note: export Stream before Readable/Writable/Duplex/...\n// to avoid a cross-reference(require) issues\nconst Stream = module.exports = require('internal/streams/legacy');\n\nStream.Readable = require('_stream_readable');\nStream.Writable = require('_stream_writable');\nStream.Duplex = require('_stream_duplex');\nStream.Transform = require('_stream_transform');\nStream.PassThrough = require('_stream_passthrough');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n// Internal utilities\ntry {\n  Stream._isUint8Array = process.binding('util').isUint8Array;\n} catch (e) {\n  // This throws for Node < 4.2.0 because there’s no util binding and\n  // returns undefined for Node < 7.4.0.\n}\n\nif (!Stream._isUint8Array) {\n  Stream._isUint8Array = function _isUint8Array(obj) {\n    return Object.prototype.toString.call(obj) === '[object Uint8Array]';\n  };\n}\n\nconst version = process.version.substr(1).split('.');\nif (version[0] === 0 && version[1] < 12) {\n  Stream._uint8ArrayToBuffer = Buffer;\n} else {\n  try {\n    const internalBuffer = require('internal/buffer');\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return new internalBuffer.FastBuffer(chunk.buffer,\n                                           chunk.byteOffset,\n                                           chunk.byteLength);\n    };\n  } catch (e) {\n  }\n\n  if (!Stream._uint8ArrayToBuffer) {\n    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\n      return Buffer.prototype.slice.call(chunk);\n    };\n  }\n}\n",
  "_stream_readable": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst Stream = require('stream');\nconst Buffer = require('buffer').Buffer;\nconst util = require('util');\nconst debug = util.debuglog('stream');\nconst BufferList = require('internal/streams/BufferList');\nconst destroyImpl = require('internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event])\n      emitter.on(event, fn);\n    else if (Array.isArray(emitter._events[event]))\n      emitter._events[event].unshift(fn);\n    else\n      emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck)\n      er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' &&\n          Object.getPrototypeOf(chunk) !== Buffer.prototype &&\n          !state.objectMode) {\n        chunk = Stream._uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted)\n          stream.emit('error', new Error('stream.unshift() after end event'));\n        else\n          addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0)\n            addChunk(stream, state, chunk, false);\n          else\n            maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!Stream._isUint8Array(chunk) &&\n      typeof chunk !== 'string' &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nconst MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length)\n      return state.buffer.head.data.length;\n    else\n      return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length)\n    return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if (((state.pipesCount === 1 && state.pipes === dest) ||\n           (state.pipesCount > 1 && state.pipes.indexOf(dest) !== -1)) &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // try to find the right one.\n  var index = state.pipes.indexOf(dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    const state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) {\n        return function() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0)\n    return null;\n\n  var ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.head.data;\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = (hasStrings ?\n           copyFromBufferString(n, list) :\n           copyFromBuffer(n, list));\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    const str = p.data;\n    const nb = (n > str.length ? str.length : n);\n    if (nb === str.length)\n      ret += str;\n    else\n      ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next)\n          list.head = p.next;\n        else\n          list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  const ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    const buf = p.data;\n    const nb = (n > buf.length ? buf.length : n);\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next)\n          list.head = p.next;\n        else\n          list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n",
  "_stream_writable": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst Stream = require('stream');\nconst Buffer = require('buffer').Buffer;\nconst destroyImpl = require('internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = onwrite.bind(undefined, stream);\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  var corkReq = { next: null, entry: null, finish: undefined };\n  corkReq.finish = onCorkedFinish.bind(undefined, corkReq, this);\n  this.corkedRequestsFree = corkReq;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.', 'DEP0003')\n});\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance) {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function(object) {\n      if (realHasInstance.call(this, object))\n        return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!(realHasInstance.call(Writable, this)) &&\n      !(this instanceof Stream.Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' &&\n             chunk !== undefined &&\n             !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    process.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = Stream._isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n    chunk = Stream._uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf)\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!Buffer.isEncoding(encoding))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    process.nextTick(afterError, stream, state, cb, er);\n  else\n    afterError(stream, state, cb, er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction afterError(stream, state, cb, err) {\n  cb(err);\n  finishMaybe(stream, state);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf)\n        allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      var corkReq = { next: null, entry: null, finish: undefined };\n      corkReq.finish = onCorkedFinish.bind(undefined, corkReq, state);\n      state.corkedRequestsFree = corkReq;\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\nfunction callFinal(stream, state) {\n  stream._final((err) => {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n  this.end();\n  cb(err);\n};\n",
  "_stream_duplex": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\nmodule.exports = Duplex;\n\nconst util = require('util');\nconst Readable = require('_stream_readable');\nconst Writable = require('_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = Object.keys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get() {\n    if (this._readableState === undefined ||\n        this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined ||\n        this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function(err, cb) {\n  this.push(null);\n  this.end();\n\n  process.nextTick(cb, err);\n};\n",
  "_stream_transform": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nconst Duplex = require('_stream_duplex');\nconst util = require('util');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error',\n                       new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er, data) {\n        done(stream, er, data);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nTransform.prototype._destroy = function(err, cb) {\n  Duplex.prototype._destroy.call(this, err, (err2) => {\n    cb(err2);\n    this.emit('close');\n  });\n};\n\n\nfunction done(stream, er, data) {\n  if (er)\n    return stream.emit('error', er);\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n",
  "_stream_passthrough": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nconst Transform = require('_stream_transform');\nconst util = require('util');\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n",
  "_stream_wrap": "'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst Socket = require('net').Socket;\nconst JSStream = process.binding('js_stream').JSStream;\nconst Buffer = require('buffer').Buffer;\nconst uv = process.binding('uv');\nconst debug = util.debuglog('stream_wrap');\n\nfunction StreamWrap(stream) {\n  const handle = new JSStream();\n\n  this.stream = stream;\n\n  this._list = null;\n\n  const self = this;\n  handle.close = function(cb) {\n    debug('close');\n    self.doClose(cb);\n  };\n  handle.isAlive = function() {\n    return self.isAlive();\n  };\n  handle.isClosing = function() {\n    return self.isClosing();\n  };\n  handle.onreadstart = function() {\n    return self.readStart();\n  };\n  handle.onreadstop = function() {\n    return self.readStop();\n  };\n  handle.onshutdown = function(req) {\n    return self.doShutdown(req);\n  };\n  handle.onwrite = function(req, bufs) {\n    return self.doWrite(req, bufs);\n  };\n\n  this.stream.pause();\n  this.stream.on('error', function onerror(err) {\n    self.emit('error', err);\n  });\n  this.stream.on('data', function ondata(chunk) {\n    if (!(chunk instanceof Buffer)) {\n      // Make sure that no further `data` events will happen\n      this.pause();\n      this.removeListener('data', ondata);\n\n      self.emit('error', new Error('Stream has StringDecoder'));\n      return;\n    }\n\n    debug('data', chunk.length);\n    if (self._handle)\n      self._handle.readBuffer(chunk);\n  });\n  this.stream.once('end', function onend() {\n    debug('end');\n    if (self._handle)\n      self._handle.emitEOF();\n  });\n\n  Socket.call(this, {\n    handle: handle\n  });\n}\nutil.inherits(StreamWrap, Socket);\nmodule.exports = StreamWrap;\n\n// require('_stream_wrap').StreamWrap\nStreamWrap.StreamWrap = StreamWrap;\n\nStreamWrap.prototype.isAlive = function isAlive() {\n  return true;\n};\n\nStreamWrap.prototype.isClosing = function isClosing() {\n  return !this.readable || !this.writable;\n};\n\nStreamWrap.prototype.readStart = function readStart() {\n  this.stream.resume();\n  return 0;\n};\n\nStreamWrap.prototype.readStop = function readStop() {\n  this.stream.pause();\n  return 0;\n};\n\nStreamWrap.prototype.doShutdown = function doShutdown(req) {\n  const self = this;\n  const handle = this._handle;\n  const item = this._enqueue('shutdown', req);\n\n  this.stream.end(function() {\n    // Ensure that write was dispatched\n    setImmediate(function() {\n      if (!self._dequeue(item))\n        return;\n\n      handle.finishShutdown(req, 0);\n    });\n  });\n  return 0;\n};\n\nStreamWrap.prototype.doWrite = function doWrite(req, bufs) {\n  const self = this;\n  const handle = self._handle;\n\n  var pending = bufs.length;\n\n  // Queue the request to be able to cancel it\n  const item = self._enqueue('write', req);\n\n  self.stream.cork();\n  for (var n = 0; n < bufs.length; n++)\n    self.stream.write(bufs[n], done);\n  self.stream.uncork();\n\n  function done(err) {\n    if (!err && --pending !== 0)\n      return;\n\n    // Ensure that this is called once in case of error\n    pending = 0;\n\n    // Ensure that write was dispatched\n    setImmediate(function() {\n      // Do not invoke callback twice\n      if (!self._dequeue(item))\n        return;\n\n      var errCode = 0;\n      if (err) {\n        if (err.code && uv['UV_' + err.code])\n          errCode = uv['UV_' + err.code];\n        else\n          errCode = uv.UV_EPIPE;\n      }\n\n      handle.doAfterWrite(req);\n      handle.finishWrite(req, errCode);\n    });\n  }\n\n  return 0;\n};\n\nfunction QueueItem(type, req) {\n  this.type = type;\n  this.req = req;\n  this.prev = this;\n  this.next = this;\n}\n\nStreamWrap.prototype._enqueue = function _enqueue(type, req) {\n  const item = new QueueItem(type, req);\n  if (this._list === null) {\n    this._list = item;\n    return item;\n  }\n\n  item.next = this._list.next;\n  item.prev = this._list;\n  item.next.prev = item;\n  item.prev.next = item;\n\n  return item;\n};\n\nStreamWrap.prototype._dequeue = function _dequeue(item) {\n  assert(item instanceof QueueItem);\n\n  var next = item.next;\n  var prev = item.prev;\n\n  if (next === null && prev === null)\n    return false;\n\n  item.next = null;\n  item.prev = null;\n\n  if (next === item) {\n    prev = null;\n    next = null;\n  } else {\n    prev.next = next;\n    next.prev = prev;\n  }\n\n  if (this._list === item)\n    this._list = next;\n\n  return true;\n};\n\nStreamWrap.prototype.doClose = function doClose(cb) {\n  const self = this;\n  const handle = self._handle;\n\n  setImmediate(function() {\n    while (self._list !== null) {\n      const item = self._list;\n      const req = item.req;\n      self._dequeue(item);\n\n      const errCode = uv.UV_ECANCELED;\n      if (item.type === 'write') {\n        handle.doAfterWrite(req);\n        handle.finishWrite(req, errCode);\n      } else if (item.type === 'shutdown') {\n        handle.finishShutdown(req, errCode);\n      }\n    }\n\n    // Should be already set by net.js\n    assert(self._handle === null);\n    cb();\n  });\n};\n",
  "string_decoder": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst internalUtil = require('internal/util');\nconst isEncoding = Buffer[internalUtil.kIsEncodingSymbol];\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  const nenc = internalUtil.normalizeEncoding(enc);\n  if (typeof nenc !== 'string' &&\n      (Buffer.isEncoding === isEncoding || !Buffer.isEncoding(enc)))\n    throw new Error(`Unknown encoding: ${enc}`);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function(buf) {\n  if (buf.length === 0)\n    return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined)\n      return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length)\n    return (r ? r + this.text(buf, i) : this.text(buf, i));\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function(buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F)\n    return 0;\n  else if (byte >> 5 === 0x06)\n    return 2;\n  else if (byte >> 4 === 0x0E)\n    return 3;\n  else if (byte >> 3 === 0x1E)\n    return 4;\n  return (byte >> 6 === 0x02 ? -1 : -2);\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i)\n    return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0)\n      self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2)\n    return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0)\n      self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2)\n    return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2)\n        nb = 0;\n      else\n        self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  const p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined)\n    return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  const total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed)\n    return buf.toString('utf8', i);\n  this.lastTotal = total;\n  const end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed)\n    return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    const r = buf.toString('utf16le', i);\n    if (r) {\n      const c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed) {\n    const end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  const n = (buf.length - i) % 3;\n  if (n === 0)\n    return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\n\nfunction base64End(buf) {\n  const r = (buf && buf.length ? this.write(buf) : '');\n  if (this.lastNeed)\n    return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return (buf && buf.length ? this.write(buf) : '');\n}\n",
  "sys": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// the sys module was renamed to 'util'.\n// this shim remains to keep old programs working.\n// sys is deprecated and shouldn't be used\n\nmodule.exports = require('util');\nprocess.emitWarning('sys is deprecated. Use util instead.',\n                    'DeprecationWarning', 'DEP0025');\n",
  "timers": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst async_wrap = process.binding('async_wrap');\nconst TimerWrap = process.binding('timer_wrap').Timer;\nconst L = require('internal/linkedlist');\nconst internalUtil = require('internal/util');\nconst { createPromise, promiseResolve } = process.binding('util');\nconst async_hooks = require('async_hooks');\nconst assert = require('assert');\nconst util = require('util');\nconst debug = util.debuglog('timer');\nconst kOnTimeout = TimerWrap.kOnTimeout | 0;\nconst initTriggerId = async_hooks.initTriggerId;\n// Two arrays that share state between C++ and JS.\nconst { async_hook_fields, async_uid_fields } = async_wrap;\n// Used to change the state of the async id stack.\nconst { pushAsyncIds, popAsyncIds } = async_wrap;\n// The needed emit*() functions.\nconst { emitInit, emitBefore, emitAfter, emitDestroy } = async_hooks;\n// Grab the constants necessary for working with internal arrays.\nconst { kInit, kBefore, kAfter, kDestroy, kAsyncUidCntr } =\n    async_wrap.constants;\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_id_symbol = Symbol('triggerId');\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2147483647; // 2^31-1\n\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read though the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n// The linked lists within also have some meta-properties, one of which is a\n// TimerWrap C++ handle, which makes the call after the duration to process the\n// list it is attached to.\n//\n//\n// ╔════ > Object Map\n// ║\n// ╠══\n// ║ refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n// ╚══          ┌─────────┘\n//              │\n// ╔══          │\n// ║ TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }\n// ║         ┌────────────────┘\n// ║    ╔══  │                              ^\n// ║    ║    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n// ║    ║      ┌───────────┘\n// ║    ║      │                                  ^\n// ║    ║      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n// ╠══  ╠══\n// ║    ║\n// ║    ╚════ >  Actual JavaScript timeouts\n// ║\n// ╚════ > Linked List\n//\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers due to currently timeout, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// TimerWrap's backing libuv timers implementation (a performant heap-based\n// queue), and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list).\n// However, these operations combined have shown to be trivial in comparison to\n// other alternative timers architectures.\n\n\n// Object maps containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// The difference between these two objects is that the former contains timers\n// that will keep the process open if they are the only thing left, while the\n// latter will not.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst refedLists = Object.create(null);\nconst unrefedLists = Object.create(null);\n\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nconst active = exports.active = function(item) {\n  insert(item, false);\n};\n\n// Internal APIs that need timeouts should use `_unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nexports._unrefActive = function(item) {\n  insert(item, true);\n};\n\n\nfunction timerEmitBefore(asyncId, triggerId) {\n  if (async_hook_fields[kBefore] > 0)\n    emitBefore(asyncId, triggerId);\n  else\n    pushAsyncIds(asyncId, triggerId);\n}\n\n\nfunction timerEmitAfter(asyncId) {\n  if (async_hook_fields[kAfter] > 0)\n    emitAfter(asyncId);\n  else\n    popAsyncIds(asyncId);\n}\n\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// TimerWrap backed list if one does not already exist for the specified timeout\n// duration.\nfunction insert(item, unrefed) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined) return;\n\n  item._idleStart = TimerWrap.now();\n\n  const lists = unrefed === true ? unrefedLists : refedLists;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  var list = lists[msecs];\n  if (!list) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    lists[msecs] = list = createTimersList(msecs, unrefed);\n  }\n\n  if (!item[async_id_symbol] || item._destroyed) {\n    item._destroyed = false;\n    item[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    item[trigger_id_symbol] = initTriggerId();\n    if (async_hook_fields[kInit] > 0)\n      emitInit(item[async_id_symbol], 'Timeout', item[trigger_id_symbol], item);\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction createTimersList(msecs, unrefed) {\n  // Make a new linked list of timers, and create a TimerWrap to schedule\n  // processing for the list.\n  const list = new TimersList(msecs, unrefed);\n  L.init(list);\n  list._timer._list = list;\n\n  if (unrefed === true) list._timer.unref();\n  list._timer.start(msecs);\n\n  list._timer[kOnTimeout] = listOnTimeout;\n\n  return list;\n}\n\nfunction TimersList(msecs, unrefed) {\n  this._idleNext = null; // Create the list with the linkedlist properties to\n  this._idlePrev = null; // prevent any unnecessary hidden class changes.\n  this._timer = new TimerWrap();\n  this._unrefed = unrefed;\n  this.msecs = msecs;\n  this.nextTick = false;\n}\n\nfunction listOnTimeout() {\n  var list = this._list;\n  var msecs = list.msecs;\n\n  if (list.nextTick) {\n    list.nextTick = false;\n    process.nextTick(listOnTimeoutNT, list);\n    return;\n  }\n\n  debug('timeout callback %d', msecs);\n\n  var now = TimerWrap.now();\n  debug('now: %d', now);\n\n  var diff, timer;\n  while (timer = L.peek(list)) {\n    diff = now - timer._idleStart;\n\n    // Check if this loop iteration is too early for the next timer.\n    // This happens if there are more timers scheduled for later in the list.\n    if (diff < msecs) {\n      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);\n      if (timeRemaining < 0) {\n        timeRemaining = 0;\n      }\n      this.start(timeRemaining);\n      debug('%d list wait because diff is %d', msecs, diff);\n      return;\n    }\n\n    // The actual logic for when a timeout happens.\n\n    L.remove(timer);\n    assert(timer !== L.peek(list));\n\n    if (!timer._onTimeout) {\n      if (async_hook_fields[kDestroy] > 0 && !timer._destroyed &&\n            typeof timer[async_id_symbol] === 'number') {\n        emitDestroy(timer[async_id_symbol]);\n        timer._destroyed = true;\n      }\n      continue;\n    }\n\n    var domain = timer.domain;\n    if (domain) {\n\n      // If the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/nodejs/node-v0.x-archive/issues/2631\n      if (domain._disposed)\n        continue;\n\n      domain.enter();\n    }\n\n    tryOnTimeout(timer, list);\n\n    if (domain)\n      domain.exit();\n  }\n\n  // If `L.peek(list)` returned nothing, the list was either empty or we have\n  // called all of the timer timeouts.\n  // As such, we can remove the list and clean up the TimerWrap C++ handle.\n  debug('%d list empty', msecs);\n  assert(L.isEmpty(list));\n\n  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and\n  // recreated since the reference to `list` was created. Make sure they're\n  // the same instance of the list before destroying.\n  if (list._unrefed === true && list === unrefedLists[msecs]) {\n    delete unrefedLists[msecs];\n  } else if (list === refedLists[msecs]) {\n    delete refedLists[msecs];\n  }\n\n  // Do not close the underlying handle if its ownership has changed\n  // (e.g it was unrefed in its callback).\n  if (this.owner)\n    return;\n\n  this.close();\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnTimeout(timer, list) {\n  timer._called = true;\n  const timerAsyncId = (typeof timer[async_id_symbol] === 'number') ?\n      timer[async_id_symbol] : null;\n  var threw = true;\n  if (timerAsyncId !== null)\n    timerEmitBefore(timerAsyncId, timer[trigger_id_symbol]);\n  try {\n    ontimeout(timer);\n    threw = false;\n  } finally {\n    if (timerAsyncId !== null) {\n      if (!threw)\n        timerEmitAfter(timerAsyncId);\n      if (!timer._repeat && async_hook_fields[kDestroy] > 0 &&\n          !timer._destroyed) {\n        emitDestroy(timerAsyncId);\n        timer._destroyed = true;\n      }\n    }\n\n    if (!threw) return;\n\n    // Postpone all later list events to next tick. We need to do this\n    // so that the events are called in the order they were created.\n    const lists = list._unrefed === true ? unrefedLists : refedLists;\n    for (var key in lists) {\n      if (key > list.msecs) {\n        lists[key].nextTick = true;\n      }\n    }\n    // We need to continue processing after domain error handling\n    // is complete, but not by using whatever domain was left over\n    // when the timeout threw its exception.\n    const domain = process.domain;\n    process.domain = null;\n    // If we threw, we need to process the rest of the list in nextTick.\n    process.nextTick(listOnTimeoutNT, list);\n    process.domain = domain;\n  }\n}\n\n\nfunction listOnTimeoutNT(list) {\n  list._timer[kOnTimeout]();\n}\n\n\n// A convenience function for re-using TimerWrap handles more easily.\n//\n// This mostly exists to fix https://github.com/nodejs/node/issues/1264.\n// Handles in libuv take at least one `uv_run` to be registered as unreferenced.\n// Re-using an existing handle allows us to skip that, so that a second `uv_run`\n// will return no active handles, even when running `setTimeout(fn).unref()`.\nfunction reuse(item) {\n  L.remove(item);\n\n  var list = refedLists[item._idleTimeout];\n  // if empty - reuse the watcher\n  if (list && L.isEmpty(list)) {\n    debug('reuse hit');\n    list._timer.stop();\n    delete refedLists[item._idleTimeout];\n    return list._timer;\n  }\n\n  return null;\n}\n\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nconst unenroll = exports.unenroll = function(item) {\n  // Fewer checks may be possible, but these cover everything.\n  if (async_hook_fields[kDestroy] > 0 &&\n      item &&\n      typeof item[async_id_symbol] === 'number' &&\n      !item._destroyed) {\n    emitDestroy(item[async_id_symbol]);\n    item._destroyed = true;\n  }\n\n  var handle = reuse(item);\n  if (handle) {\n    debug('unenroll: list empty');\n    handle.close();\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nexports.enroll = function(item, msecs) {\n  if (typeof msecs !== 'number') {\n    throw new TypeError('\"msecs\" argument must be a number');\n  }\n\n  if (msecs < 0 || !isFinite(msecs)) {\n    throw new RangeError('\"msecs\" argument must be ' +\n                         'a non-negative finite number');\n  }\n\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    msecs = TIMEOUT_MAX;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n/*\n * DOM-style timers\n */\n\n\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createSingleTimeout(callback, after, args);\n}\n\nsetTimeout[internalUtil.promisify.custom] = function(after, value) {\n  const promise = createPromise();\n  createSingleTimeout(promise, after, [value]);\n  return promise;\n};\n\nexports.setTimeout = setTimeout;\n\nfunction createSingleTimeout(callback, after, args) {\n  after *= 1; // coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX))\n    after = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(after, callback, args);\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\n\nfunction ontimeout(timer) {\n  var args = timer._timerArgs;\n  var callback = timer._onTimeout;\n  if (typeof callback !== 'function')\n    return promiseResolve(callback, args[0]);\n  if (!args)\n    timer._onTimeout();\n  else {\n    switch (args.length) {\n      case 1:\n        timer._onTimeout(args[0]);\n        break;\n      case 2:\n        timer._onTimeout(args[0], args[1]);\n        break;\n      case 3:\n        timer._onTimeout(args[0], args[1], args[2]);\n        break;\n      default:\n        Function.prototype.apply.call(callback, timer, args);\n    }\n  }\n  if (timer._repeat)\n    rearm(timer);\n}\n\n\nfunction rearm(timer) {\n  // // Do not re-arm unenroll'd or closed timers.\n  if (timer._idleTimeout === -1) return;\n\n  // If timer is unref'd (or was - it's permanently removed from the list.)\n  if (timer._handle && timer instanceof Timeout) {\n    timer._handle.start(timer._repeat);\n  } else {\n    timer._idleTimeout = timer._repeat;\n    active(timer);\n  }\n}\n\n\nconst clearTimeout = exports.clearTimeout = function(timer) {\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\n    timer[kOnTimeout] = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createRepeatTimeout(callback, repeat, args);\n};\n\nfunction createRepeatTimeout(callback, repeat, args) {\n  repeat *= 1; // coalesce to number or NaN\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX))\n    repeat = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(repeat, callback, args);\n  timer._repeat = repeat;\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = null;\n    clearTimeout(timer);\n  }\n};\n\n\nfunction Timeout(after, callback, args) {\n  this._called = false;\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = null;\n  this._destroyed = false;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Timeout', this[trigger_id_symbol], this);\n}\n\n\nfunction unrefdHandle() {\n  // Don't attempt to call the callback if it is not a function.\n  if (typeof this.owner._onTimeout === 'function') {\n    ontimeout(this.owner);\n  }\n\n  // Make sure we clean up if the callback is no longer a function\n  // even if the timer is an interval.\n  if (!this.owner._repeat ||\n      typeof this.owner._onTimeout !== 'function') {\n    this.owner.close();\n  }\n}\n\n\nTimeout.prototype.unref = function() {\n  if (this._handle) {\n    this._handle.unref();\n  } else if (typeof this._onTimeout === 'function') {\n    var now = TimerWrap.now();\n    if (!this._idleStart) this._idleStart = now;\n    var delay = this._idleStart + this._idleTimeout - now;\n    if (delay < 0) delay = 0;\n\n    // Prevent running cb again when unref() is called during the same cb\n    if (this._called && !this._repeat) {\n      unenroll(this);\n      return;\n    }\n\n    var handle = reuse(this);\n\n    this._handle = handle || new TimerWrap();\n    this._handle.owner = this;\n    this._handle[kOnTimeout] = unrefdHandle;\n    this._handle.start(delay);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    // Fewer checks may be possible, but these cover everything.\n    if (async_hook_fields[kDestroy] > 0 &&\n        this &&\n        typeof this[async_id_symbol] === 'number' &&\n        !this._destroyed) {\n      emitDestroy(this[async_id_symbol]);\n      this._destroyed = true;\n    }\n\n    this._idleTimeout = -1;\n    this._handle[kOnTimeout] = null;\n    this._handle.close();\n  } else {\n    unenroll(this);\n  }\n  return this;\n};\n\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list, adjusting the current tail's\n// previous and next pointers where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list, adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\n// Create a single linked list instance only once at startup\nvar immediateQueue = new ImmediateList();\n\n\nfunction processImmediate() {\n  var immediate = immediateQueue.head;\n  var tail = immediateQueue.tail;\n  var domain;\n\n  // Clear the linked list early in case new `setImmediate()` calls occur while\n  // immediate callbacks are executed\n  immediateQueue.head = immediateQueue.tail = null;\n\n  while (immediate) {\n    domain = immediate.domain;\n\n    if (!immediate._onImmediate) {\n      immediate = immediate._idleNext;\n      continue;\n    }\n\n    if (domain)\n      domain.enter();\n\n    immediate._callback = immediate._onImmediate;\n\n    // Save next in case `clearImmediate(immediate)` is called from callback\n    var next = immediate._idleNext;\n\n    tryOnImmediate(immediate, tail);\n\n    if (domain)\n      domain.exit();\n\n    // If `clearImmediate(immediate)` wasn't called from the callback, use the\n    // `immediate`'s next item\n    if (immediate._idleNext)\n      immediate = immediate._idleNext;\n    else\n      immediate = next;\n  }\n\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\n  // call to NeedImmediateCallbackSetter().\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnImmediate(immediate, oldTail) {\n  var threw = true;\n  timerEmitBefore(immediate[async_id_symbol], immediate[trigger_id_symbol]);\n  try {\n    // make the actual call outside the try/catch to allow it to be optimized\n    runCallback(immediate);\n    threw = false;\n  } finally {\n    // clearImmediate checks _callback === null for kDestroy hooks.\n    immediate._callback = null;\n    if (!threw)\n      timerEmitAfter(immediate[async_id_symbol]);\n    if (async_hook_fields[kDestroy] > 0 && !immediate._destroyed) {\n      emitDestroy(immediate[async_id_symbol]);\n      immediate._destroyed = true;\n    }\n\n    if (threw && immediate._idleNext) {\n      // Handle any remaining on next tick, assuming we're still alive to do so.\n      const curHead = immediateQueue.head;\n      const next = immediate._idleNext;\n      if (curHead) {\n        curHead._idlePrev = oldTail;\n        oldTail._idleNext = curHead;\n        next._idlePrev = null;\n        immediateQueue.head = next;\n      } else {\n        immediateQueue.head = next;\n        immediateQueue.tail = oldTail;\n      }\n      process.nextTick(processImmediate);\n    }\n  }\n}\n\nfunction runCallback(timer) {\n  const argv = timer._argv;\n  const argc = argv ? argv.length : 0;\n  if (typeof timer._callback !== 'function')\n    return promiseResolve(timer._callback, argv[0]);\n  switch (argc) {\n    // fast-path callbacks with 0-3 arguments\n    case 0:\n      return timer._callback();\n    case 1:\n      return timer._callback(argv[0]);\n    case 2:\n      return timer._callback(argv[0], argv[1]);\n    case 3:\n      return timer._callback(argv[0], argv[1], argv[2]);\n    // more than 3 arguments run slower with .apply\n    default:\n      return Function.prototype.apply.call(timer._callback, timer, argv);\n  }\n}\n\n\nfunction Immediate() {\n  // assigning the callback here can cause optimize/deoptimize thrashing\n  // so have caller annotate the object (node v6.0.0, v8 5.0.71.35)\n  this._idleNext = null;\n  this._idlePrev = null;\n  this._callback = null;\n  this._argv = null;\n  this._onImmediate = null;\n  this._destroyed = false;\n  this.domain = process.domain;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Immediate', this[trigger_id_symbol], this);\n}\n\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var i, args;\n\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++)\n        // extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      break;\n  }\n  return createImmediate(args, callback);\n}\n\nsetImmediate[internalUtil.promisify.custom] = function(value) {\n  const promise = createPromise();\n  createImmediate([value], promise);\n  return promise;\n};\n\nexports.setImmediate = setImmediate;\n\nfunction createImmediate(args, callback) {\n  // declaring it `const immediate` causes v6.0.0 to deoptimize this function\n  var immediate = new Immediate();\n  immediate._callback = callback;\n  immediate._argv = args;\n  immediate._onImmediate = callback;\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  immediateQueue.append(immediate);\n\n  return immediate;\n}\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  if (async_hook_fields[kDestroy] > 0 &&\n      immediate._callback !== null &&\n      !immediate._destroyed) {\n    emitDestroy(immediate[async_id_symbol]);\n    immediate._destroyed = true;\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n};\n",
  "tls": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst internalUtil = require('internal/util');\ninternalUtil.assertCrypto();\n\nconst net = require('net');\nconst url = require('url');\nconst binding = process.binding('crypto');\nconst Buffer = require('buffer').Buffer;\nconst { isUint8Array } = process.binding('util');\n\n// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations\n// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more\n// renegotations are seen. The settings are applied to all remote client\n// connections.\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\n\nexports.SLAB_BUFFER_SIZE = 10 * 1024 * 1024;\n\nexports.DEFAULT_CIPHERS =\n    process.binding('constants').crypto.defaultCipherList;\n\nexports.DEFAULT_ECDH_CURVE = 'prime256v1';\n\nexports.getCiphers = internalUtil.cachedResult(\n  () => internalUtil.filterDuplicateStrings(binding.getSSLCiphers(), true)\n);\n\n// Convert protocols array into valid OpenSSL protocols list\n// (\"\\x06spdy/2\\x08http/1.1\\x08http/1.0\")\nfunction convertProtocols(protocols) {\n  const lens = new Array(protocols.length);\n  const buff = Buffer.allocUnsafe(protocols.reduce((p, c, i) => {\n    var len = Buffer.byteLength(c);\n    lens[i] = len;\n    return p + 1 + len;\n  }, 0));\n\n  var offset = 0;\n  for (var i = 0, c = protocols.length; i < c; i++) {\n    buff[offset++] = lens[i];\n    buff.write(protocols[i], offset);\n    offset += lens[i];\n  }\n\n  return buff;\n}\n\nexports.convertNPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.NPNProtocols = convertProtocols(protocols);\n  } else if (isUint8Array(protocols)) {\n    // Copy new buffer not to be modified by user.\n    out.NPNProtocols = Buffer.from(protocols);\n  }\n};\n\nexports.convertALPNProtocols = function(protocols, out) {\n  // If protocols is Array - translate it into buffer\n  if (Array.isArray(protocols)) {\n    out.ALPNProtocols = convertProtocols(protocols);\n  } else if (isUint8Array(protocols)) {\n    // Copy new buffer not to be modified by user.\n    out.ALPNProtocols = Buffer.from(protocols);\n  }\n};\n\nfunction unfqdn(host) {\n  return host.replace(/[.]$/, '');\n}\n\nfunction splitHost(host) {\n  // String#toLowerCase() is locale-sensitive so we use\n  // a conservative version that only lowercases A-Z.\n  const replacer = (c) => String.fromCharCode(32 + c.charCodeAt(0));\n  return unfqdn(host).replace(/[A-Z]/g, replacer).split('.');\n}\n\nfunction check(hostParts, pattern, wildcards) {\n  // Empty strings, null, undefined, etc. never match.\n  if (!pattern)\n    return false;\n\n  const patternParts = splitHost(pattern);\n\n  if (hostParts.length !== patternParts.length)\n    return false;\n\n  // Pattern has empty components, e.g. \"bad..example.com\".\n  if (patternParts.includes(''))\n    return false;\n\n  // RFC 6125 allows IDNA U-labels (Unicode) in names but we have no\n  // good way to detect their encoding or normalize them so we simply\n  // reject them.  Control characters and blanks are rejected as well\n  // because nothing good can come from accepting them.\n  const isBad = (s) => /[^\\u0021-\\u007F]/u.test(s);\n  if (patternParts.some(isBad))\n    return false;\n\n  // Check host parts from right to left first.\n  for (var i = hostParts.length - 1; i > 0; i -= 1)\n    if (hostParts[i] !== patternParts[i])\n      return false;\n\n  const hostSubdomain = hostParts[0];\n  const patternSubdomain = patternParts[0];\n  const patternSubdomainParts = patternSubdomain.split('*');\n\n  // Short-circuit when the subdomain does not contain a wildcard.\n  // RFC 6125 does not allow wildcard substitution for components\n  // containing IDNA A-labels (Punycode) so match those verbatim.\n  if (patternSubdomainParts.length === 1 || patternSubdomain.includes('xn--'))\n    return hostSubdomain === patternSubdomain;\n\n  if (!wildcards)\n    return false;\n\n  // More than one wildcard is always wrong.\n  if (patternSubdomainParts.length > 2)\n    return false;\n\n  // *.tld wildcards are not allowed.\n  if (patternParts.length <= 2)\n    return false;\n\n  const [prefix, suffix] = patternSubdomainParts;\n\n  if (prefix.length + suffix.length > hostSubdomain.length)\n    return false;\n\n  if (!hostSubdomain.startsWith(prefix))\n    return false;\n\n  if (!hostSubdomain.endsWith(suffix))\n    return false;\n\n  return true;\n}\n\nexports.checkServerIdentity = function checkServerIdentity(host, cert) {\n  const subject = cert.subject;\n  const altNames = cert.subjectaltname;\n  const dnsNames = [];\n  const uriNames = [];\n  const ips = [];\n\n  host = '' + host;\n\n  if (altNames) {\n    for (const name of altNames.split(', ')) {\n      if (name.startsWith('DNS:')) {\n        dnsNames.push(name.slice(4));\n      } else if (name.startsWith('URI:')) {\n        const uri = url.parse(name.slice(4));\n        uriNames.push(uri.hostname);  // TODO(bnoordhuis) Also use scheme.\n      } else if (name.startsWith('IP Address:')) {\n        ips.push(name.slice(11));\n      }\n    }\n  }\n\n  let valid = false;\n  let reason = 'Unknown reason';\n\n  if (net.isIP(host)) {\n    valid = ips.includes(host);\n    if (!valid)\n      reason = `IP: ${host} is not in the cert's list: ${ips.join(', ')}`;\n    // TODO(bnoordhuis) Also check URI SANs that are IP addresses.\n  } else if (subject) {\n    host = unfqdn(host);  // Remove trailing dot for error messages.\n    const hostParts = splitHost(host);\n    const wildcard = (pattern) => check(hostParts, pattern, true);\n    const noWildcard = (pattern) => check(hostParts, pattern, false);\n\n    // Match against Common Name only if no supported identifiers are present.\n    if (dnsNames.length === 0 && ips.length === 0 && uriNames.length === 0) {\n      const cn = subject.CN;\n\n      if (Array.isArray(cn))\n        valid = cn.some(wildcard);\n      else if (cn)\n        valid = wildcard(cn);\n\n      if (!valid)\n        reason = `Host: ${host}. is not cert's CN: ${cn}`;\n    } else {\n      valid = dnsNames.some(wildcard) || uriNames.some(noWildcard);\n      if (!valid)\n        reason = `Host: ${host}. is not in the cert's altnames: ${altNames}`;\n    }\n  } else {\n    reason = 'Cert is empty';\n  }\n\n  if (!valid) {\n    const err = new Error(\n        `Hostname/IP doesn't match certificate's altnames: \"${reason}\"`);\n    err.reason = reason;\n    err.host = host;\n    err.cert = cert;\n    return err;\n  }\n};\n\n// Example:\n// C=US\\nST=CA\\nL=SF\\nO=Joyent\\nOU=Node.js\\nCN=ca1\\nemailAddress=ry@clouds.org\nexports.parseCertString = function parseCertString(s) {\n  var out = {};\n  var parts = s.split('\\n');\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var sepIndex = parts[i].indexOf('=');\n    if (sepIndex > 0) {\n      var key = parts[i].slice(0, sepIndex);\n      var value = parts[i].slice(sepIndex + 1);\n      if (key in out) {\n        if (!Array.isArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        out[key].push(value);\n      } else {\n        out[key] = value;\n      }\n    }\n  }\n  return out;\n};\n\n// Public API\nexports.createSecureContext = require('_tls_common').createSecureContext;\nexports.SecureContext = require('_tls_common').SecureContext;\nexports.TLSSocket = require('_tls_wrap').TLSSocket;\nexports.Server = require('_tls_wrap').Server;\nexports.createServer = require('_tls_wrap').createServer;\nexports.connect = require('_tls_wrap').connect;\n\n// Deprecated: DEP0064\nexports.createSecurePair = require('_tls_legacy').createSecurePair;\n",
  "_tls_common": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst tls = require('tls');\n\nconst SSL_OP_CIPHER_SERVER_PREFERENCE =\n    process.binding('constants').crypto.SSL_OP_CIPHER_SERVER_PREFERENCE;\n\n// Lazily loaded\nvar crypto = null;\n\nconst binding = process.binding('crypto');\nconst NativeSecureContext = binding.SecureContext;\n\nfunction SecureContext(secureProtocol, secureOptions, context) {\n  if (!(this instanceof SecureContext)) {\n    return new SecureContext(secureProtocol, secureOptions, context);\n  }\n\n  if (context) {\n    this.context = context;\n  } else {\n    this.context = new NativeSecureContext();\n\n    if (secureProtocol) {\n      this.context.init(secureProtocol);\n    } else {\n      this.context.init();\n    }\n  }\n\n  if (secureOptions) this.context.setOptions(secureOptions);\n}\n\nexports.SecureContext = SecureContext;\n\n\nexports.createSecureContext = function createSecureContext(options, context) {\n  if (!options) options = {};\n\n  var secureOptions = options.secureOptions;\n  if (options.honorCipherOrder)\n    secureOptions |= SSL_OP_CIPHER_SERVER_PREFERENCE;\n\n  var c = new SecureContext(options.secureProtocol, secureOptions, context);\n  var i;\n\n  if (context) return c;\n\n  // NOTE: It's important to add CA before the cert to be able to load\n  // cert's issuer in C++ code.\n  if (options.ca) {\n    if (Array.isArray(options.ca)) {\n      for (i = 0; i < options.ca.length; i++) {\n        c.context.addCACert(options.ca[i]);\n      }\n    } else {\n      c.context.addCACert(options.ca);\n    }\n  } else {\n    c.context.addRootCerts();\n  }\n\n  if (options.cert) {\n    if (Array.isArray(options.cert)) {\n      for (i = 0; i < options.cert.length; i++)\n        c.context.setCert(options.cert[i]);\n    } else {\n      c.context.setCert(options.cert);\n    }\n  }\n\n  // NOTE: It is important to set the key after the cert.\n  // `ssl_set_pkey` returns `0` when the key does not much the cert, but\n  // `ssl_set_cert` returns `1` and nullifies the key in the SSL structure\n  // which leads to the crash later on.\n  if (options.key) {\n    if (Array.isArray(options.key)) {\n      for (i = 0; i < options.key.length; i++) {\n        const key = options.key[i];\n        const passphrase = key.passphrase || options.passphrase;\n        c.context.setKey(key.pem || key, passphrase);\n      }\n    } else {\n      c.context.setKey(options.key, options.passphrase);\n    }\n  }\n\n  if (options.ciphers)\n    c.context.setCiphers(options.ciphers);\n  else\n    c.context.setCiphers(tls.DEFAULT_CIPHERS);\n\n  if (options.ecdhCurve === undefined)\n    c.context.setECDHCurve(tls.DEFAULT_ECDH_CURVE);\n  else if (options.ecdhCurve)\n    c.context.setECDHCurve(options.ecdhCurve);\n\n  if (options.dhparam) {\n    const warning = c.context.setDHParam(options.dhparam);\n    if (warning)\n      process.emitWarning(warning, 'SecurityWarning');\n  }\n\n  if (options.crl) {\n    if (Array.isArray(options.crl)) {\n      for (i = 0; i < options.crl.length; i++) {\n        c.context.addCRL(options.crl[i]);\n      }\n    } else {\n      c.context.addCRL(options.crl);\n    }\n  }\n\n  if (options.sessionIdContext) {\n    c.context.setSessionIdContext(options.sessionIdContext);\n  }\n\n  if (options.pfx) {\n    var pfx = options.pfx;\n    var passphrase = options.passphrase;\n\n    if (!crypto)\n      crypto = require('crypto');\n\n    pfx = crypto._toBuf(pfx);\n    if (passphrase)\n      passphrase = crypto._toBuf(passphrase);\n\n    if (passphrase) {\n      c.context.loadPKCS12(pfx, passphrase);\n    } else {\n      c.context.loadPKCS12(pfx);\n    }\n  }\n\n  // Do not keep read/write buffers in free list for OpenSSL < 1.1.0. (For\n  // OpenSSL 1.1.0, buffers are malloced and freed without the use of a\n  // freelist.)\n  if (options.singleUse) {\n    c.singleUse = true;\n    c.context.setFreeListLength(0);\n  }\n\n  return c;\n};\n\nexports.translatePeerCertificate = function translatePeerCertificate(c) {\n  if (!c)\n    return null;\n\n  if (c.issuer) c.issuer = tls.parseCertString(c.issuer);\n  if (c.issuerCertificate && c.issuerCertificate !== c) {\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  }\n  if (c.subject) c.subject = tls.parseCertString(c.subject);\n  if (c.infoAccess) {\n    var info = c.infoAccess;\n    c.infoAccess = {};\n\n    // XXX: More key validation?\n    info.replace(/([^\\n:]*):([^\\n]*)(?:\\n|$)/g, function(all, key, val) {\n      if (key === '__proto__')\n        return;\n\n      if (c.infoAccess.hasOwnProperty(key))\n        c.infoAccess[key].push(val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n};\n",
  "_tls_legacy": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nrequire('internal/util').assertCrypto();\n\nconst assert = require('assert');\nconst Buffer = require('buffer').Buffer;\nconst common = require('_tls_common');\nconst Connection = process.binding('crypto').Connection;\nconst EventEmitter = require('events');\nconst internalUtil = require('internal/util');\nconst stream = require('stream');\nconst Timer = process.binding('timer_wrap').Timer;\nconst tls = require('tls');\nconst util = require('util');\n\nconst debug = util.debuglog('tls-legacy');\n\nfunction SlabBuffer() {\n  this.create();\n}\n\n\nSlabBuffer.prototype.create = function create() {\n  this.isFull = false;\n  this.pool = Buffer.allocUnsafe(tls.SLAB_BUFFER_SIZE);\n  this.offset = 0;\n  this.remaining = this.pool.length;\n};\n\n\nSlabBuffer.prototype.use = function use(context, fn, size) {\n  if (this.remaining === 0) {\n    this.isFull = true;\n    return 0;\n  }\n\n  var actualSize = this.remaining;\n\n  if (size !== null) actualSize = Math.min(size, actualSize);\n\n  var bytes = fn.call(context, this.pool, this.offset, actualSize);\n  if (bytes > 0) {\n    this.offset += bytes;\n    this.remaining -= bytes;\n  }\n\n  assert(this.remaining >= 0);\n\n  return bytes;\n};\n\n\nvar slabBuffer = null;\n\n\n// Base class of both CleartextStream and EncryptedStream\nfunction CryptoStream(pair, options) {\n  stream.Duplex.call(this, options);\n\n  this.pair = pair;\n  this._pending = null;\n  this._pendingEncoding = '';\n  this._pendingCallback = null;\n  this._doneFlag = false;\n  this._retryAfterPartial = false;\n  this._halfRead = false;\n  this._sslOutCb = null;\n  this._resumingSession = false;\n  this._reading = true;\n  this._destroyed = false;\n  this._ended = false;\n  this._finished = false;\n  this._opposite = null;\n\n  if (slabBuffer === null) slabBuffer = new SlabBuffer();\n  this._buffer = slabBuffer;\n\n  this.once('finish', onCryptoStreamFinish);\n\n  // net.Socket calls .onend too\n  this.once('end', onCryptoStreamEnd);\n}\nutil.inherits(CryptoStream, stream.Duplex);\n\n\nfunction onCryptoStreamFinish() {\n  this._finished = true;\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.onfinish');\n    if (this.pair.ssl) {\n      // Generate close notify\n      // NOTE: first call checks if client has sent us shutdown,\n      // second call enqueues shutdown into the BIO.\n      if (this.pair.ssl.shutdownSSL() !== 1) {\n        if (this.pair.ssl && this.pair.ssl.error)\n          return this.pair.error();\n\n        this.pair.ssl.shutdownSSL();\n      }\n\n      if (this.pair.ssl && this.pair.ssl.error)\n        return this.pair.error();\n    }\n  } else {\n    debug('encrypted.onfinish');\n  }\n\n  // Try to read just to get sure that we won't miss EOF\n  if (this._opposite.readable) this._opposite.read(0);\n\n  if (this._opposite._ended) {\n    this._done();\n\n    // No half-close, sorry\n    if (this === this.pair.cleartext) this._opposite._done();\n  }\n}\n\n\nfunction onCryptoStreamEnd() {\n  this._ended = true;\n  if (this === this.pair.cleartext) {\n    debug('cleartext.onend');\n  } else {\n    debug('encrypted.onend');\n  }\n}\n\n\n// NOTE: Called once `this._opposite` is set.\nCryptoStream.prototype.init = function init() {\n  var self = this;\n  this._opposite.on('sslOutEnd', function() {\n    if (self._sslOutCb) {\n      var cb = self._sslOutCb;\n      self._sslOutCb = null;\n      cb(null);\n    }\n  });\n};\n\n\nCryptoStream.prototype._write = function _write(data, encoding, cb) {\n  assert(this._pending === null);\n\n  // Black-hole data\n  if (!this.pair.ssl) return cb(null);\n\n  // When resuming session don't accept any new data.\n  // And do not put too much data into openssl, before writing it from encrypted\n  // side.\n  //\n  // TODO(indutny): Remove magic number, use watermark based limits\n  if (!this._resumingSession &&\n      this._opposite._internallyPendingBytes() < 128 * 1024) {\n    // Write current buffer now\n    var written;\n    if (this === this.pair.cleartext) {\n      debug('cleartext.write called with %d bytes', data.length);\n      written = this.pair.ssl.clearIn(data, 0, data.length);\n    } else {\n      debug('encrypted.write called with %d bytes', data.length);\n      written = this.pair.ssl.encIn(data, 0, data.length);\n    }\n\n    // Handle and report errors\n    if (this.pair.ssl && this.pair.ssl.error) {\n      return cb(this.pair.error(true));\n    }\n\n    // Force SSL_read call to cycle some states/data inside OpenSSL\n    this.pair.cleartext.read(0);\n\n    // Cycle encrypted data\n    if (this.pair.encrypted._internallyPendingBytes())\n      this.pair.encrypted.read(0);\n\n    // Get ALPN, NPN and Server name when ready\n    this.pair.maybeInitFinished();\n\n    // Whole buffer was written\n    if (written === data.length) {\n      if (this === this.pair.cleartext) {\n        debug('cleartext.write succeed with ' + written + ' bytes');\n      } else {\n        debug('encrypted.write succeed with ' + written + ' bytes');\n      }\n\n      // Invoke callback only when all data read from opposite stream\n      if (this._opposite._halfRead) {\n        assert(this._sslOutCb === null);\n        this._sslOutCb = cb;\n      } else {\n        cb(null);\n      }\n      return;\n    } else if (written !== 0 && written !== -1) {\n      assert(!this._retryAfterPartial);\n      this._retryAfterPartial = true;\n      this._write(data.slice(written), encoding, cb);\n      this._retryAfterPartial = false;\n      return;\n    }\n  } else {\n    debug('cleartext.write queue is full');\n\n    // Force SSL_read call to cycle some states/data inside OpenSSL\n    this.pair.cleartext.read(0);\n  }\n\n  // No write has happened\n  this._pending = data;\n  this._pendingEncoding = encoding;\n  this._pendingCallback = cb;\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.write queued with %d bytes', data.length);\n  } else {\n    debug('encrypted.write queued with %d bytes', data.length);\n  }\n};\n\n\nCryptoStream.prototype._writePending = function _writePending() {\n  const data = this._pending;\n  const encoding = this._pendingEncoding;\n  const cb = this._pendingCallback;\n\n  this._pending = null;\n  this._pendingEncoding = '';\n  this._pendingCallback = null;\n  this._write(data, encoding, cb);\n};\n\n\nCryptoStream.prototype._read = function _read(size) {\n  // XXX: EOF?!\n  if (!this.pair.ssl) return this.push(null);\n\n  // Wait for session to be resumed\n  // Mark that we're done reading, but don't provide data or EOF\n  if (this._resumingSession || !this._reading) return this.push('');\n\n  var out;\n  if (this === this.pair.cleartext) {\n    debug('cleartext.read called with %d bytes', size);\n    out = this.pair.ssl.clearOut;\n  } else {\n    debug('encrypted.read called with %d bytes', size);\n    out = this.pair.ssl.encOut;\n  }\n\n  var bytesRead = 0;\n  const start = this._buffer.offset;\n  var last = start;\n  do {\n    assert(last === this._buffer.offset);\n    var read = this._buffer.use(this.pair.ssl, out, size - bytesRead);\n    if (read > 0) {\n      bytesRead += read;\n    }\n    last = this._buffer.offset;\n\n    // Handle and report errors\n    if (this.pair.ssl && this.pair.ssl.error) {\n      this.pair.error();\n      break;\n    }\n  } while (read > 0 &&\n           !this._buffer.isFull &&\n           bytesRead < size &&\n           this.pair.ssl !== null);\n\n  // Get ALPN, NPN and Server name when ready\n  this.pair.maybeInitFinished();\n\n  // Create new buffer if previous was filled up\n  var pool = this._buffer.pool;\n  if (this._buffer.isFull) this._buffer.create();\n\n  assert(bytesRead >= 0);\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.read succeed with %d bytes', bytesRead);\n  } else {\n    debug('encrypted.read succeed with %d bytes', bytesRead);\n  }\n\n  // Try writing pending data\n  if (this._pending !== null) this._writePending();\n  if (this._opposite._pending !== null) this._opposite._writePending();\n\n  if (bytesRead === 0) {\n    // EOF when cleartext has finished and we have nothing to read\n    if (this._opposite._finished && this._internallyPendingBytes() === 0 ||\n        this.pair.ssl && this.pair.ssl.receivedShutdown) {\n      // Perform graceful shutdown\n      this._done();\n\n      // No half-open, sorry!\n      if (this === this.pair.cleartext) {\n        this._opposite._done();\n\n        // EOF\n        this.push(null);\n      } else if (!this.pair.ssl || !this.pair.ssl.receivedShutdown) {\n        // EOF\n        this.push(null);\n      }\n    } else {\n      // Bail out\n      this.push('');\n    }\n  } else {\n    // Give them requested data\n    this.push(pool.slice(start, start + bytesRead));\n  }\n\n  // Let users know that we've some internal data to read\n  var halfRead = this._internallyPendingBytes() !== 0;\n\n  // Smart check to avoid invoking 'sslOutEnd' in the most of the cases\n  if (this._halfRead !== halfRead) {\n    this._halfRead = halfRead;\n\n    // Notify listeners about internal data end\n    if (!halfRead) {\n      if (this === this.pair.cleartext) {\n        debug('cleartext.sslOutEnd');\n      } else {\n        debug('encrypted.sslOutEnd');\n      }\n\n      this.emit('sslOutEnd');\n    }\n  }\n};\n\n\nCryptoStream.prototype.setTimeout = function(timeout, callback) {\n  if (this.socket) this.socket.setTimeout(timeout, callback);\n};\n\n\nCryptoStream.prototype.setNoDelay = function(noDelay) {\n  if (this.socket) this.socket.setNoDelay(noDelay);\n};\n\n\nCryptoStream.prototype.setKeepAlive = function(enable, initialDelay) {\n  if (this.socket) this.socket.setKeepAlive(enable, initialDelay);\n};\n\nObject.defineProperty(CryptoStream.prototype, 'bytesWritten', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket ? this.socket.bytesWritten : 0;\n  }\n});\n\nCryptoStream.prototype.getPeerCertificate = function(detailed) {\n  if (this.pair.ssl) {\n    return common.translatePeerCertificate(\n        this.pair.ssl.getPeerCertificate(detailed));\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.getSession = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.getSession();\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.isSessionReused = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.isSessionReused();\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.getCipher = function(err) {\n  if (this.pair.ssl) {\n    return this.pair.ssl.getCurrentCipher();\n  } else {\n    return null;\n  }\n};\n\n\nCryptoStream.prototype.end = function(chunk, encoding) {\n  if (this === this.pair.cleartext) {\n    debug('cleartext.end');\n  } else {\n    debug('encrypted.end');\n  }\n\n  // Write pending data first\n  if (this._pending !== null) this._writePending();\n\n  this.writable = false;\n\n  stream.Duplex.prototype.end.call(this, chunk, encoding);\n};\n\n\nCryptoStream.prototype.destroySoon = function(err) {\n  if (this === this.pair.cleartext) {\n    debug('cleartext.destroySoon');\n  } else {\n    debug('encrypted.destroySoon');\n  }\n\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished && this._opposite._ended) {\n    this.destroy();\n  } else {\n    // Wait for both `finish` and `end` events to ensure that all data that\n    // was written on this side was read from the other side.\n    var self = this;\n    var waiting = 1;\n    function finish() {\n      if (--waiting === 0) self.destroy();\n    }\n    this._opposite.once('end', finish);\n    if (!this._finished) {\n      this.once('finish', finish);\n      ++waiting;\n    }\n  }\n};\n\n\nCryptoStream.prototype.destroy = function(err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.readable = this.writable = false;\n\n  // Destroy both ends\n  if (this === this.pair.cleartext) {\n    debug('cleartext.destroy');\n  } else {\n    debug('encrypted.destroy');\n  }\n  this._opposite.destroy();\n\n  process.nextTick(destroyNT, this, err ? true : false);\n};\n\n\nfunction destroyNT(self, hadErr) {\n  // Force EOF\n  self.push(null);\n\n  // Emit 'close' event\n  self.emit('close', hadErr);\n}\n\n\nCryptoStream.prototype._done = function() {\n  this._doneFlag = true;\n\n  if (this === this.pair.encrypted && !this.pair._secureEstablished)\n    return this.pair.error();\n\n  if (this.pair.cleartext._doneFlag &&\n      this.pair.encrypted._doneFlag &&\n      !this.pair._doneFlag) {\n    // If both streams are done:\n    this.pair.destroy();\n  }\n};\n\n\n// readyState is deprecated. Don't use it.\n// Deprecation Code: DEP0004\nObject.defineProperty(CryptoStream.prototype, 'readyState', {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nfunction CleartextStream(pair, options) {\n  CryptoStream.call(this, pair, options);\n\n  // This is a fake kludge to support how the http impl sits\n  // on top of net Sockets\n  var self = this;\n  this._handle = {\n    readStop: function() {\n      self._reading = false;\n    },\n    readStart: function() {\n      if (self._reading && self._readableState.length > 0) return;\n      self._reading = true;\n      self.read(0);\n      if (self._opposite.readable) self._opposite.read(0);\n    }\n  };\n}\nutil.inherits(CleartextStream, CryptoStream);\n\n\nCleartextStream.prototype._internallyPendingBytes = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.clearPending();\n  } else {\n    return 0;\n  }\n};\n\n\nCleartextStream.prototype.address = function() {\n  return this.socket && this.socket.address();\n};\n\nObject.defineProperty(CleartextStream.prototype, 'remoteAddress', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket && this.socket.remoteAddress;\n  }\n});\n\nObject.defineProperty(CleartextStream.prototype, 'remoteFamily', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket && this.socket.remoteFamily;\n  }\n});\n\nObject.defineProperty(CleartextStream.prototype, 'remotePort', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket && this.socket.remotePort;\n  }\n});\n\nObject.defineProperty(CleartextStream.prototype, 'localAddress', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket && this.socket.localAddress;\n  }\n});\n\nObject.defineProperty(CleartextStream.prototype, 'localPort', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.socket && this.socket.localPort;\n  }\n});\n\n\nfunction EncryptedStream(pair, options) {\n  CryptoStream.call(this, pair, options);\n}\nutil.inherits(EncryptedStream, CryptoStream);\n\n\nEncryptedStream.prototype._internallyPendingBytes = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.encPending();\n  } else {\n    return 0;\n  }\n};\n\n\nfunction onhandshakestart() {\n  debug('onhandshakestart');\n\n  var self = this;\n  var ssl = self.ssl;\n  var now = Timer.now();\n\n  assert(now >= ssl.lastHandshakeTime);\n\n  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {\n    ssl.handshakes = 0;\n  }\n\n  var first = (ssl.lastHandshakeTime === 0);\n  ssl.lastHandshakeTime = now;\n  if (first) return;\n\n  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    // Defer the error event to the next tick. We're being called from OpenSSL's\n    // state machine and OpenSSL is not re-entrant. We cannot allow the user's\n    // callback to destroy the connection right now, it would crash and burn.\n    setImmediate(function() {\n      var err = new Error('TLS session renegotiation attack detected');\n      if (self.cleartext) self.cleartext.emit('error', err);\n    });\n  }\n}\n\n\nfunction onhandshakedone() {\n  // for future use\n  debug('onhandshakedone');\n}\n\n\nfunction onclienthello(hello) {\n  const self = this;\n  var once = false;\n\n  this._resumingSession = true;\n  function callback(err, session) {\n    if (once) return;\n    once = true;\n\n    if (err) return self.socket.destroy(err);\n\n    setImmediate(function() {\n      self.ssl.loadSession(session);\n      self.ssl.endParser();\n\n      // Cycle data\n      self._resumingSession = false;\n      self.cleartext.read(0);\n      self.encrypted.read(0);\n    });\n  }\n\n  if (hello.sessionId.length <= 0 ||\n      !this.server ||\n      !this.server.emit('resumeSession', hello.sessionId, callback)) {\n    callback(null, null);\n  }\n}\n\n\nfunction onnewsession(key, session) {\n  if (!this.server) return;\n\n  var self = this;\n  var once = false;\n\n  if (!self.server.emit('newSession', key, session, done))\n    done();\n\n  function done() {\n    if (once)\n      return;\n    once = true;\n\n    if (self.ssl)\n      self.ssl.newSessionDone();\n  }\n}\n\n\nfunction onocspresponse(resp) {\n  this.emit('OCSPResponse', resp);\n}\n\n\n/**\n * Provides a pair of streams to do encrypted communication.\n */\n\nfunction SecurePair(context, isServer, requestCert, rejectUnauthorized,\n                    options) {\n  if (!(this instanceof SecurePair)) {\n    return new SecurePair(context,\n                          isServer,\n                          requestCert,\n                          rejectUnauthorized,\n                          options);\n  }\n\n  options || (options = {});\n\n  EventEmitter.call(this);\n\n  this.server = options.server;\n  this._secureEstablished = false;\n  this._isServer = isServer ? true : false;\n  this._encWriteState = true;\n  this._clearWriteState = true;\n  this._doneFlag = false;\n  this._destroying = false;\n\n  if (!context) {\n    this.credentials = tls.createSecureContext();\n  } else {\n    this.credentials = context;\n  }\n\n  if (!this._isServer) {\n    // For clients, we will always have either a given ca list or be using\n    // default one\n    requestCert = true;\n  }\n\n  this._rejectUnauthorized = rejectUnauthorized ? true : false;\n  this._requestCert = requestCert ? true : false;\n\n  this.ssl = new Connection(this.credentials.context,\n                            this._isServer ? true : false,\n                            this._isServer ? this._requestCert :\n                                             options.servername,\n                            this._rejectUnauthorized);\n\n  if (this._isServer) {\n    this.ssl.onhandshakestart = () => onhandshakestart.call(this);\n    this.ssl.onhandshakedone = () => onhandshakedone.call(this);\n    this.ssl.onclienthello = (hello) => onclienthello.call(this, hello);\n    this.ssl.onnewsession =\n        (key, session) => onnewsession.call(this, key, session);\n    this.ssl.lastHandshakeTime = 0;\n    this.ssl.handshakes = 0;\n  } else {\n    this.ssl.onocspresponse = (resp) => onocspresponse.call(this, resp);\n  }\n\n  if (process.features.tls_sni) {\n    if (this._isServer && options.SNICallback) {\n      this.ssl.setSNICallback(options.SNICallback);\n    }\n    this.servername = null;\n  }\n\n  if (process.features.tls_npn && options.NPNProtocols) {\n    this.ssl.setNPNProtocols(options.NPNProtocols);\n    this.npnProtocol = null;\n  }\n\n  if (process.features.tls_alpn && options.ALPNProtocols) {\n    // keep reference in secureContext not to be GC-ed\n    this.ssl._secureContext.alpnBuffer = options.ALPNProtocols;\n    this.ssl.setALPNrotocols(this.ssl._secureContext.alpnBuffer);\n    this.alpnProtocol = null;\n  }\n\n  /* Acts as a r/w stream to the cleartext side of the stream. */\n  this.cleartext = new CleartextStream(this, options.cleartext);\n\n  /* Acts as a r/w stream to the encrypted side of the stream. */\n  this.encrypted = new EncryptedStream(this, options.encrypted);\n\n  /* Let streams know about each other */\n  this.cleartext._opposite = this.encrypted;\n  this.encrypted._opposite = this.cleartext;\n  this.cleartext.init();\n  this.encrypted.init();\n\n  process.nextTick(securePairNT, this, options);\n}\n\nutil.inherits(SecurePair, EventEmitter);\n\nfunction securePairNT(self, options) {\n  /* The Connection may be destroyed by an abort call */\n  if (self.ssl) {\n    self.ssl.start();\n\n    if (options.requestOCSP)\n      self.ssl.requestOCSP();\n\n    /* In case of cipher suite failures - SSL_accept/SSL_connect may fail */\n    if (self.ssl && self.ssl.error)\n      self.error();\n  }\n}\n\n\nfunction createSecurePair(context, isServer, requestCert,\n                          rejectUnauthorized, options) {\n  return new SecurePair(context, isServer, requestCert,\n                        rejectUnauthorized, options);\n}\n\n\nSecurePair.prototype.maybeInitFinished = function() {\n  if (this.ssl && !this._secureEstablished && this.ssl.isInitFinished()) {\n    if (process.features.tls_npn) {\n      this.npnProtocol = this.ssl.getNegotiatedProtocol();\n    }\n\n    if (process.features.tls_alpn) {\n      this.alpnProtocol = this.ssl.getALPNNegotiatedProtocol();\n    }\n\n    if (process.features.tls_sni) {\n      this.servername = this.ssl.getServername();\n    }\n\n    this._secureEstablished = true;\n    debug('secure established');\n    this.emit('secure');\n  }\n};\n\n\nSecurePair.prototype.destroy = function() {\n  if (this._destroying) return;\n\n  if (!this._doneFlag) {\n    debug('SecurePair.destroy');\n    this._destroying = true;\n\n    // SecurePair should be destroyed only after it's streams\n    this.cleartext.destroy();\n    this.encrypted.destroy();\n\n    this._doneFlag = true;\n    this.ssl.error = null;\n    this.ssl.close();\n    this.ssl = null;\n  }\n};\n\n\nSecurePair.prototype.error = function(returnOnly) {\n  var err = this.ssl.error;\n  this.ssl.error = null;\n\n  if (!this._secureEstablished) {\n    // Emit ECONNRESET instead of zero return\n    if (!err || err.message === 'ZERO_RETURN') {\n      var connReset = new Error('socket hang up');\n      connReset.code = 'ECONNRESET';\n      connReset.sslError = err && err.message;\n\n      err = connReset;\n    }\n    this.destroy();\n    if (!returnOnly) this.emit('error', err);\n  } else if (this._isServer &&\n             this._rejectUnauthorized &&\n             /peer did not return a certificate/.test(err.message)) {\n    // Not really an error.\n    this.destroy();\n  } else {\n    if (!returnOnly) this.cleartext.emit('error', err);\n  }\n  return err;\n};\n\n\nfunction pipe(pair, socket) {\n  pair.encrypted.pipe(socket);\n  socket.pipe(pair.encrypted);\n\n  pair.encrypted.on('close', function() {\n    process.nextTick(pipeCloseNT, pair, socket);\n  });\n\n  pair.fd = socket.fd;\n  var cleartext = pair.cleartext;\n  cleartext.socket = socket;\n  cleartext.encrypted = pair.encrypted;\n  cleartext.authorized = false;\n\n  // cycle the data whenever the socket drains, so that\n  // we can pull some more into it.  normally this would\n  // be handled by the fact that pipe() triggers read() calls\n  // on writable.drain, but CryptoStreams are a bit more\n  // complicated.  Since the encrypted side actually gets\n  // its data from the cleartext side, we have to give it a\n  // light kick to get in motion again.\n  socket.on('drain', function() {\n    if (pair.encrypted._pending)\n      pair.encrypted._writePending();\n    if (pair.cleartext._pending)\n      pair.cleartext._writePending();\n    pair.encrypted.read(0);\n    pair.cleartext.read(0);\n  });\n\n  function onerror(e) {\n    if (cleartext._controlReleased) {\n      cleartext.emit('error', e);\n    }\n  }\n\n  function onclose() {\n    socket.removeListener('error', onerror);\n    socket.removeListener('timeout', ontimeout);\n  }\n\n  function ontimeout() {\n    cleartext.emit('timeout');\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('timeout', ontimeout);\n\n  return cleartext;\n}\n\n\nfunction pipeCloseNT(pair, socket) {\n  // Encrypted should be unpiped from socket to prevent possible\n  // write after destroy.\n  pair.encrypted.unpipe(socket);\n  socket.destroySoon();\n}\n\nmodule.exports = {\n  createSecurePair:\n    internalUtil.deprecate(createSecurePair,\n                           'tls.createSecurePair() is deprecated. Please use ' +\n                           'tls.Socket instead.', 'DEP0064'),\n  pipe\n};\n",
  "_tls_wrap": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nrequire('internal/util').assertCrypto();\n\nconst assert = require('assert');\nconst crypto = require('crypto');\nconst net = require('net');\nconst tls = require('tls');\nconst util = require('util');\nconst common = require('_tls_common');\nconst StreamWrap = require('_stream_wrap').StreamWrap;\nconst Buffer = require('buffer').Buffer;\nconst debug = util.debuglog('tls');\nconst Timer = process.binding('timer_wrap').Timer;\nconst tls_wrap = process.binding('tls_wrap');\nconst TCP = process.binding('tcp_wrap').TCP;\nconst Pipe = process.binding('pipe_wrap').Pipe;\n\nfunction onhandshakestart() {\n  debug('onhandshakestart');\n\n  var self = this;\n  var ssl = self._handle;\n  var now = Timer.now();\n\n  assert(now >= ssl.lastHandshakeTime);\n\n  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {\n    ssl.handshakes = 0;\n  }\n\n  var first = (ssl.lastHandshakeTime === 0);\n  ssl.lastHandshakeTime = now;\n  if (first) return;\n\n  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    // Defer the error event to the next tick. We're being called from OpenSSL's\n    // state machine and OpenSSL is not re-entrant. We cannot allow the user's\n    // callback to destroy the connection right now, it would crash and burn.\n    setImmediate(function() {\n      var err = new Error('TLS session renegotiation attack detected');\n      self._emitTLSError(err);\n    });\n  }\n}\n\n\nfunction onhandshakedone() {\n  // for future use\n  debug('onhandshakedone');\n  this._finishInit();\n}\n\n\nfunction loadSession(self, hello, cb) {\n  var once = false;\n  function onSession(err, session) {\n    if (once)\n      return cb(new Error('TLS session callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    if (!self._handle)\n      return cb(new Error('Socket is closed'));\n\n    self._handle.loadSession(session);\n    cb(null);\n  }\n\n  if (hello.sessionId.length <= 0 ||\n      hello.tlsTicket ||\n      self.server &&\n      !self.server.emit('resumeSession', hello.sessionId, onSession)) {\n    cb(null);\n  }\n}\n\n\nfunction loadSNI(self, servername, cb) {\n  if (!servername || !self._SNICallback)\n    return cb(null);\n\n  var once = false;\n  self._SNICallback(servername, function(err, context) {\n    if (once)\n      return cb(new Error('TLS SNI callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    if (!self._handle)\n      return cb(new Error('Socket is closed'));\n\n    // TODO(indutny): eventually disallow raw `SecureContext`\n    if (context)\n      self._handle.sni_context = context.context || context;\n\n    cb(null, self._handle.sni_context);\n  });\n}\n\n\nfunction requestOCSP(self, hello, ctx, cb) {\n  if (!hello.OCSPRequest || !self.server)\n    return cb(null);\n\n  if (!ctx)\n    ctx = self.server._sharedCreds;\n\n  // TLS socket is using a `net.Server` instead of a tls.TLSServer.\n  // Some TLS properties like `server._sharedCreds` will not be present\n  if (!ctx)\n    return cb(null);\n\n  // TODO(indutny): eventually disallow raw `SecureContext`\n  if (ctx.context)\n    ctx = ctx.context;\n\n  if (self.server.listenerCount('OCSPRequest') === 0) {\n    return cb(null);\n  } else {\n    self.server.emit('OCSPRequest',\n                     ctx.getCertificate(),\n                     ctx.getIssuer(),\n                     onOCSP);\n  }\n\n  var once = false;\n  function onOCSP(err, response) {\n    if (once)\n      return cb(new Error('TLS OCSP callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    if (!self._handle)\n      return cb(new Error('Socket is closed'));\n\n    if (response)\n      self._handle.setOCSPResponse(response);\n    cb(null);\n  }\n}\n\n\nfunction onclienthello(hello) {\n  var self = this;\n\n  loadSession(self, hello, function(err) {\n    if (err)\n      return self.destroy(err);\n\n    self._handle.endParser();\n  });\n}\n\n\nfunction oncertcb(info) {\n  var self = this;\n  var servername = info.servername;\n\n  loadSNI(self, servername, function(err, ctx) {\n    if (err)\n      return self.destroy(err);\n    requestOCSP(self, info, ctx, function(err) {\n      if (err)\n        return self.destroy(err);\n\n      if (!self._handle)\n        return self.destroy(new Error('Socket is closed'));\n\n      try {\n        self._handle.certCbDone();\n      } catch (e) {\n        self.destroy(e);\n      }\n    });\n  });\n}\n\n\nfunction onnewsession(key, session) {\n  if (!this.server)\n    return;\n\n  var self = this;\n  var once = false;\n\n  this._newSessionPending = true;\n  if (!this.server.emit('newSession', key, session, done))\n    done();\n\n  function done() {\n    if (once)\n      return;\n    once = true;\n\n    if (!self._handle)\n      return self.destroy(new Error('Socket is closed'));\n\n    self._handle.newSessionDone();\n\n    self._newSessionPending = false;\n    if (self._securePending)\n      self._finishInit();\n    self._securePending = false;\n  }\n}\n\n\nfunction onocspresponse(resp) {\n  this.emit('OCSPResponse', resp);\n}\n\nfunction initRead(tls, wrapped) {\n  // If we were destroyed already don't bother reading\n  if (!tls._handle)\n    return;\n\n  // Socket already has some buffered data - emulate receiving it\n  if (wrapped && wrapped._readableState && wrapped._readableState.length) {\n    var buf;\n    while ((buf = wrapped.read()) !== null)\n      tls._handle.receive(buf);\n  }\n\n  tls.read(0);\n}\n\n/**\n * Provides a wrap of socket stream to do encrypted communication.\n */\n\nfunction TLSSocket(socket, options) {\n  if (options === undefined)\n    this._tlsOptions = {};\n  else\n    this._tlsOptions = options;\n  this._secureEstablished = false;\n  this._securePending = false;\n  this._newSessionPending = false;\n  this._controlReleased = false;\n  this._SNICallback = null;\n  this.servername = null;\n  this.npnProtocol = null;\n  this.alpnProtocol = null;\n  this.authorized = false;\n  this.authorizationError = null;\n\n  // Wrap plain JS Stream into StreamWrap\n  var wrap;\n  if ((socket instanceof net.Socket && socket._handle) || !socket)\n    wrap = socket;\n  else\n    wrap = new StreamWrap(socket);\n\n  // Just a documented property to make secure sockets\n  // distinguishable from regular ones.\n  this.encrypted = true;\n\n  net.Socket.call(this, {\n    handle: this._wrapHandle(wrap),\n    allowHalfOpen: socket && socket.allowHalfOpen,\n    readable: false,\n    writable: false\n  });\n\n  // Proxy for API compatibility\n  this.ssl = this._handle;\n\n  this.on('error', this._tlsError);\n\n  this._init(socket, wrap);\n\n  // Make sure to setup all required properties like: `connecting` before\n  // starting the flow of the data\n  this.readable = true;\n  this.writable = true;\n\n  // Read on next tick so the caller has a chance to setup listeners\n  process.nextTick(initRead, this, socket);\n}\nutil.inherits(TLSSocket, net.Socket);\nexports.TLSSocket = TLSSocket;\n\nvar proxiedMethods = [\n  'ref', 'unref', 'open', 'bind', 'listen', 'connect', 'bind6',\n  'connect6', 'getsockname', 'getpeername', 'setNoDelay', 'setKeepAlive',\n  'setSimultaneousAccepts', 'setBlocking',\n\n  // PipeWrap\n  'setPendingInstances'\n];\n\n// Proxy HandleWrap, PipeWrap and TCPWrap methods\nfunction makeMethodProxy(name) {\n  return function methodProxy(...args) {\n    if (this._parent[name])\n      return this._parent[name].apply(this._parent, args);\n  };\n}\nfor (var n = 0; n < proxiedMethods.length; n++) {\n  tls_wrap.TLSWrap.prototype[proxiedMethods[n]] =\n    makeMethodProxy(proxiedMethods[n]);\n}\n\ntls_wrap.TLSWrap.prototype.close = function close(cb) {\n  let ssl;\n  if (this.owner) {\n    ssl = this.owner.ssl;\n    this.owner.ssl = null;\n  }\n\n  // Invoke `destroySSL` on close to clean up possibly pending write requests\n  // that may self-reference TLSWrap, leading to leak\n  const done = () => {\n    if (ssl) {\n      ssl.destroySSL();\n      if (ssl._secureContext.singleUse) {\n        ssl._secureContext.context.close();\n        ssl._secureContext.context = null;\n      }\n    }\n    if (cb)\n      cb();\n  };\n\n  if (this._parentWrap && this._parentWrap._handle === this._parent) {\n    this._parentWrap.once('close', done);\n    return this._parentWrap.destroy();\n  }\n  return this._parent.close(done);\n};\n\nTLSSocket.prototype._wrapHandle = function(wrap) {\n  var res;\n  var handle;\n\n  if (wrap)\n    handle = wrap._handle;\n\n  var options = this._tlsOptions;\n  if (!handle) {\n    handle = options.pipe ? new Pipe() : new TCP();\n    handle.owner = this;\n  }\n\n  // Wrap socket's handle\n  var context = options.secureContext ||\n                options.credentials ||\n                tls.createSecureContext(options);\n  res = tls_wrap.wrap(handle._externalStream,\n                      context.context,\n                      !!options.isServer);\n  res._parent = handle;\n  res._parentWrap = wrap;\n  res._secureContext = context;\n  res.reading = handle.reading;\n  Object.defineProperty(handle, 'reading', {\n    get: function get() {\n      return res.reading;\n    },\n    set: function set(value) {\n      res.reading = value;\n    }\n  });\n\n  this.on('close', function() {\n    // Make sure we are not doing it on OpenSSL's stack\n    setImmediate(destroySSL, this);\n    res = null;\n  });\n\n  return res;\n};\n\nfunction destroySSL(self) {\n  self._destroySSL();\n}\n\nTLSSocket.prototype._destroySSL = function _destroySSL() {\n  if (!this.ssl) return;\n  this.ssl.destroySSL();\n  if (this.ssl._secureContext.singleUse) {\n    this.ssl._secureContext.context.close();\n    this.ssl._secureContext.context = null;\n  }\n  this.ssl = null;\n};\n\nTLSSocket.prototype._init = function(socket, wrap) {\n  var self = this;\n  var options = this._tlsOptions;\n  var ssl = this._handle;\n\n  // lib/net.js expect this value to be non-zero if write hasn't been flushed\n  // immediately\n  // TODO(indutny): rewise this solution, it might be 1 before handshake and\n  // represent real writeQueueSize during regular writes.\n  ssl.writeQueueSize = 1;\n\n  this.server = options.server;\n\n  // For clients, we will always have either a given ca list or be using\n  // default one\n  const requestCert = !!options.requestCert || !options.isServer;\n  const rejectUnauthorized = !!options.rejectUnauthorized;\n\n  this._requestCert = requestCert;\n  this._rejectUnauthorized = rejectUnauthorized;\n  if (requestCert || rejectUnauthorized)\n    ssl.setVerifyMode(requestCert, rejectUnauthorized);\n\n  if (options.isServer) {\n    ssl.onhandshakestart = () => onhandshakestart.call(this);\n    ssl.onhandshakedone = () => onhandshakedone.call(this);\n    ssl.onclienthello = (hello) => onclienthello.call(this, hello);\n    ssl.oncertcb = (info) => oncertcb.call(this, info);\n    ssl.onnewsession = (key, session) => onnewsession.call(this, key, session);\n    ssl.lastHandshakeTime = 0;\n    ssl.handshakes = 0;\n\n    if (this.server) {\n      if (this.server.listenerCount('resumeSession') > 0 ||\n          this.server.listenerCount('newSession') > 0) {\n        ssl.enableSessionCallbacks();\n      }\n      if (this.server.listenerCount('OCSPRequest') > 0)\n        ssl.enableCertCb();\n    }\n  } else {\n    ssl.onhandshakestart = function() {};\n    ssl.onhandshakedone = () => this._finishInit();\n    ssl.onocspresponse = (resp) => onocspresponse.call(this, resp);\n\n    if (options.session)\n      ssl.setSession(options.session);\n  }\n\n  ssl.onerror = function(err) {\n    if (self._writableState.errorEmitted)\n      return;\n\n    // Destroy socket if error happened before handshake's finish\n    if (!self._secureEstablished) {\n      // When handshake fails control is not yet released,\n      // so self._tlsError will return null instead of actual error\n      self.destroy(err);\n    } else if (options.isServer &&\n               rejectUnauthorized &&\n               /peer did not return a certificate/.test(err.message)) {\n      // Ignore server's authorization errors\n      self.destroy();\n    } else {\n      // Throw error\n      self._emitTLSError(err);\n    }\n\n    self._writableState.errorEmitted = true;\n  };\n\n  // If custom SNICallback was given, or if\n  // there're SNI contexts to perform match against -\n  // set `.onsniselect` callback.\n  if (process.features.tls_sni &&\n      options.isServer &&\n      options.SNICallback &&\n      options.server &&\n      (options.SNICallback !== SNICallback ||\n       options.server._contexts.length)) {\n    assert(typeof options.SNICallback === 'function');\n    this._SNICallback = options.SNICallback;\n    ssl.enableCertCb();\n  }\n\n  if (process.features.tls_npn && options.NPNProtocols)\n    ssl.setNPNProtocols(options.NPNProtocols);\n\n  if (process.features.tls_alpn && options.ALPNProtocols) {\n    // keep reference in secureContext not to be GC-ed\n    ssl._secureContext.alpnBuffer = options.ALPNProtocols;\n    ssl.setALPNProtocols(ssl._secureContext.alpnBuffer);\n  }\n\n  if (options.handshakeTimeout > 0)\n    this.setTimeout(options.handshakeTimeout, this._handleTimeout);\n\n  if (socket instanceof net.Socket) {\n    this._parent = socket;\n\n    // To prevent assertion in afterConnect() and properly kick off readStart\n    this.connecting = socket.connecting || !socket._handle;\n    socket.once('connect', function() {\n      self.connecting = false;\n      self.emit('connect');\n    });\n  }\n\n  // Assume `tls.connect()`\n  if (wrap) {\n    wrap.on('error', function(err) {\n      self._emitTLSError(err);\n    });\n  } else {\n    assert(!socket);\n    this.connecting = true;\n  }\n};\n\nTLSSocket.prototype.renegotiate = function(options, callback) {\n  var requestCert = this._requestCert;\n  var rejectUnauthorized = this._rejectUnauthorized;\n\n  if (this.destroyed)\n    return;\n\n  if (typeof options.requestCert !== 'undefined')\n    requestCert = !!options.requestCert;\n  if (typeof options.rejectUnauthorized !== 'undefined')\n    rejectUnauthorized = !!options.rejectUnauthorized;\n\n  if (requestCert !== this._requestCert ||\n      rejectUnauthorized !== this._rejectUnauthorized) {\n    this._handle.setVerifyMode(requestCert, rejectUnauthorized);\n    this._requestCert = requestCert;\n    this._rejectUnauthorized = rejectUnauthorized;\n  }\n  if (!this._handle.renegotiate()) {\n    if (callback) {\n      process.nextTick(callback, new Error('Failed to renegotiate'));\n    }\n    return false;\n  }\n\n  // Ensure that we'll cycle through internal openssl's state\n  this.write('');\n\n  if (callback) {\n    this.once('secure', function() {\n      callback(null);\n    });\n  }\n\n  return true;\n};\n\nTLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(size) {\n  return this._handle.setMaxSendFragment(size) === 1;\n};\n\nTLSSocket.prototype.getTLSTicket = function getTLSTicket() {\n  return this._handle.getTLSTicket();\n};\n\nTLSSocket.prototype._handleTimeout = function() {\n  this._emitTLSError(new Error('TLS handshake timeout'));\n};\n\nTLSSocket.prototype._emitTLSError = function(err) {\n  var e = this._tlsError(err);\n  if (e)\n    this.emit('error', e);\n};\n\nTLSSocket.prototype._tlsError = function(err) {\n  this.emit('_tlsError', err);\n  if (this._controlReleased)\n    return err;\n  return null;\n};\n\nTLSSocket.prototype._releaseControl = function() {\n  if (this._controlReleased)\n    return false;\n  this._controlReleased = true;\n  this.removeListener('error', this._tlsError);\n  return true;\n};\n\nTLSSocket.prototype._finishInit = function() {\n  // `newSession` callback wasn't called yet\n  if (this._newSessionPending) {\n    this._securePending = true;\n    return;\n  }\n\n  if (process.features.tls_npn) {\n    this.npnProtocol = this._handle.getNegotiatedProtocol();\n  }\n\n  if (process.features.tls_alpn) {\n    this.alpnProtocol = this.ssl.getALPNNegotiatedProtocol();\n  }\n\n  if (process.features.tls_sni && this._tlsOptions.isServer) {\n    this.servername = this._handle.getServername();\n  }\n\n  debug('secure established');\n  this._secureEstablished = true;\n  if (this._tlsOptions.handshakeTimeout > 0)\n    this.setTimeout(0, this._handleTimeout);\n  this.emit('secure');\n};\n\nTLSSocket.prototype._start = function() {\n  if (this.connecting) {\n    this.once('connect', function() {\n      this._start();\n    });\n    return;\n  }\n\n  // Socket was destroyed before the connection was established\n  if (!this._handle)\n    return;\n\n  debug('start');\n  if (this._tlsOptions.requestOCSP)\n    this._handle.requestOCSP();\n  this._handle.start();\n};\n\nTLSSocket.prototype.setServername = function(name) {\n  this._handle.setServername(name);\n};\n\nTLSSocket.prototype.setSession = function(session) {\n  if (typeof session === 'string')\n    session = Buffer.from(session, 'latin1');\n  this._handle.setSession(session);\n};\n\nTLSSocket.prototype.getPeerCertificate = function(detailed) {\n  if (this._handle) {\n    return common.translatePeerCertificate(\n        this._handle.getPeerCertificate(detailed));\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getSession = function() {\n  if (this._handle) {\n    return this._handle.getSession();\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.isSessionReused = function() {\n  if (this._handle) {\n    return this._handle.isSessionReused();\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getCipher = function(err) {\n  if (this._handle) {\n    return this._handle.getCurrentCipher();\n  } else {\n    return null;\n  }\n};\n\nTLSSocket.prototype.getEphemeralKeyInfo = function() {\n  if (this._handle)\n    return this._handle.getEphemeralKeyInfo();\n\n  return null;\n};\n\nTLSSocket.prototype.getProtocol = function() {\n  if (this._handle)\n    return this._handle.getProtocol();\n\n  return null;\n};\n\n// TODO: support anonymous (nocert) and PSK\n\n\n// AUTHENTICATION MODES\n//\n// There are several levels of authentication that TLS/SSL supports.\n// Read more about this in \"man SSL_set_verify\".\n//\n// 1. The server sends a certificate to the client but does not request a\n// cert from the client. This is common for most HTTPS servers. The browser\n// can verify the identity of the server, but the server does not know who\n// the client is. Authenticating the client is usually done over HTTP using\n// login boxes and cookies and stuff.\n//\n// 2. The server sends a cert to the client and requests that the client\n// also send it a cert. The client knows who the server is and the server is\n// requesting the client also identify themselves. There are several\n// outcomes:\n//\n//   A) verifyError returns null meaning the client's certificate is signed\n//   by one of the server's CAs. The server know's the client idenity now\n//   and the client is authorized.\n//\n//   B) For some reason the client's certificate is not acceptable -\n//   verifyError returns a string indicating the problem. The server can\n//   either (i) reject the client or (ii) allow the client to connect as an\n//   unauthorized connection.\n//\n// The mode is controlled by two boolean variables.\n//\n// requestCert\n//   If true the server requests a certificate from client connections. For\n//   the common HTTPS case, users will want this to be false, which is what\n//   it defaults to.\n//\n// rejectUnauthorized\n//   If true clients whose certificates are invalid for any reason will not\n//   be allowed to make connections. If false, they will simply be marked as\n//   unauthorized but secure communication will continue. By default this is\n//   true.\n//\n//\n//\n// Options:\n// - requestCert. Send verify request. Default to false.\n// - rejectUnauthorized. Boolean, default to true.\n// - key. string.\n// - cert: string.\n// - ca: string or array of strings.\n// - sessionTimeout: integer.\n//\n// emit 'secureConnection'\n//   function (tlsSocket) { }\n//\n//   \"UNABLE_TO_GET_ISSUER_CERT\", \"UNABLE_TO_GET_CRL\",\n//   \"UNABLE_TO_DECRYPT_CERT_SIGNATURE\", \"UNABLE_TO_DECRYPT_CRL_SIGNATURE\",\n//   \"UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY\", \"CERT_SIGNATURE_FAILURE\",\n//   \"CRL_SIGNATURE_FAILURE\", \"CERT_NOT_YET_VALID\" \"CERT_HAS_EXPIRED\",\n//   \"CRL_NOT_YET_VALID\", \"CRL_HAS_EXPIRED\" \"ERROR_IN_CERT_NOT_BEFORE_FIELD\",\n//   \"ERROR_IN_CERT_NOT_AFTER_FIELD\", \"ERROR_IN_CRL_LAST_UPDATE_FIELD\",\n//   \"ERROR_IN_CRL_NEXT_UPDATE_FIELD\", \"OUT_OF_MEM\",\n//   \"DEPTH_ZERO_SELF_SIGNED_CERT\", \"SELF_SIGNED_CERT_IN_CHAIN\",\n//   \"UNABLE_TO_GET_ISSUER_CERT_LOCALLY\", \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\",\n//   \"CERT_CHAIN_TOO_LONG\", \"CERT_REVOKED\" \"INVALID_CA\",\n//   \"PATH_LENGTH_EXCEEDED\", \"INVALID_PURPOSE\" \"CERT_UNTRUSTED\",\n//   \"CERT_REJECTED\"\n//\nfunction Server(options, listener) {\n  if (!(this instanceof Server))\n    return new Server(options, listener);\n\n  if (typeof options === 'function') {\n    listener = options;\n    options = {};\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n  } else {\n    throw new TypeError('options must be an object');\n  }\n\n\n  this._contexts = [];\n\n  var self = this;\n\n  // Handle option defaults:\n  this.setOptions(options);\n\n  var sharedCreds = tls.createSecureContext({\n    pfx: self.pfx,\n    key: self.key,\n    passphrase: self.passphrase,\n    cert: self.cert,\n    ca: self.ca,\n    ciphers: self.ciphers,\n    ecdhCurve: self.ecdhCurve,\n    dhparam: self.dhparam,\n    secureProtocol: self.secureProtocol,\n    secureOptions: self.secureOptions,\n    honorCipherOrder: self.honorCipherOrder,\n    crl: self.crl,\n    sessionIdContext: self.sessionIdContext\n  });\n  this._sharedCreds = sharedCreds;\n\n  var timeout = options.handshakeTimeout || (120 * 1000);\n\n  if (typeof timeout !== 'number') {\n    throw new TypeError('handshakeTimeout must be a number');\n  }\n\n  if (self.sessionTimeout) {\n    sharedCreds.context.setSessionTimeout(self.sessionTimeout);\n  }\n\n  if (self.ticketKeys) {\n    sharedCreds.context.setTicketKeys(self.ticketKeys);\n  }\n\n  // constructor call\n  net.Server.call(this, function(raw_socket) {\n    var socket = new TLSSocket(raw_socket, {\n      secureContext: sharedCreds,\n      isServer: true,\n      server: self,\n      requestCert: self.requestCert,\n      rejectUnauthorized: self.rejectUnauthorized,\n      handshakeTimeout: timeout,\n      NPNProtocols: self.NPNProtocols,\n      ALPNProtocols: self.ALPNProtocols,\n      SNICallback: options.SNICallback || SNICallback\n    });\n\n    socket.on('secure', function() {\n      if (socket._requestCert) {\n        var verifyError = socket._handle.verifyError();\n        if (verifyError) {\n          socket.authorizationError = verifyError.code;\n\n          if (socket._rejectUnauthorized)\n            socket.destroy();\n        } else {\n          socket.authorized = true;\n        }\n      }\n\n      if (!socket.destroyed && socket._releaseControl())\n        self.emit('secureConnection', socket);\n    });\n\n    var errorEmitted = false;\n    socket.on('close', function(err) {\n      // Closed because of error - no need to emit it twice\n      if (err)\n        return;\n\n      // Emit ECONNRESET\n      if (!socket._controlReleased && !errorEmitted) {\n        errorEmitted = true;\n        var connReset = new Error('socket hang up');\n        connReset.code = 'ECONNRESET';\n        self.emit('tlsClientError', connReset, socket);\n      }\n    });\n\n    socket.on('_tlsError', function(err) {\n      if (!socket._controlReleased && !errorEmitted) {\n        errorEmitted = true;\n        self.emit('tlsClientError', err, socket);\n      }\n    });\n  });\n\n  if (listener) {\n    this.on('secureConnection', listener);\n  }\n}\n\nutil.inherits(Server, net.Server);\nexports.Server = Server;\nexports.createServer = function(options, listener) {\n  return new Server(options, listener);\n};\n\n\nServer.prototype._getServerData = function() {\n  return {\n    ticketKeys: this.getTicketKeys().toString('hex')\n  };\n};\n\n\nServer.prototype._setServerData = function(data) {\n  this.setTicketKeys(Buffer.from(data.ticketKeys, 'hex'));\n};\n\n\nServer.prototype.getTicketKeys = function getTicketKeys(keys) {\n  return this._sharedCreds.context.getTicketKeys(keys);\n};\n\n\nServer.prototype.setTicketKeys = function setTicketKeys(keys) {\n  this._sharedCreds.context.setTicketKeys(keys);\n};\n\n\nServer.prototype.setOptions = function(options) {\n  this.requestCert = options.requestCert === true;\n  this.rejectUnauthorized = options.rejectUnauthorized !== false;\n\n  if (options.pfx) this.pfx = options.pfx;\n  if (options.key) this.key = options.key;\n  if (options.passphrase) this.passphrase = options.passphrase;\n  if (options.cert) this.cert = options.cert;\n  if (options.ca) this.ca = options.ca;\n  if (options.secureProtocol) this.secureProtocol = options.secureProtocol;\n  if (options.crl) this.crl = options.crl;\n  if (options.ciphers) this.ciphers = options.ciphers;\n  if (options.ecdhCurve !== undefined)\n    this.ecdhCurve = options.ecdhCurve;\n  if (options.dhparam) this.dhparam = options.dhparam;\n  if (options.sessionTimeout) this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys) this.ticketKeys = options.ticketKeys;\n  var secureOptions = options.secureOptions || 0;\n  if (options.honorCipherOrder !== undefined)\n    this.honorCipherOrder = !!options.honorCipherOrder;\n  else\n    this.honorCipherOrder = true;\n  if (secureOptions) this.secureOptions = secureOptions;\n  if (options.NPNProtocols) tls.convertNPNProtocols(options.NPNProtocols, this);\n  if (options.ALPNProtocols)\n    tls.convertALPNProtocols(options.ALPNProtocols, this);\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = crypto.createHash('sha1')\n                                  .update(process.argv.join(' '))\n                                  .digest('hex')\n                                  .slice(0, 32);\n  }\n};\n\n// SNI Contexts High-Level API\nServer.prototype.addContext = function(servername, context) {\n  if (!servername) {\n    throw new Error('\"servername\" is required parameter for Server.addContext');\n  }\n\n  var re = new RegExp('^' +\n                      servername.replace(/([.^$+?\\-\\\\[\\]{}])/g, '\\\\$1')\n                                .replace(/\\*/g, '[^.]*') +\n                      '$');\n  this._contexts.push([re, tls.createSecureContext(context).context]);\n};\n\nfunction SNICallback(servername, callback) {\n  var ctx;\n\n  this.server._contexts.some(function(elem) {\n    if (servername.match(elem[0]) !== null) {\n      ctx = elem[1];\n      return true;\n    }\n  });\n\n  callback(null, ctx);\n}\n\n\n// Target API:\n//\n//  var s = tls.connect({port: 8000, host: \"google.com\"}, function() {\n//    if (!s.authorized) {\n//      s.destroy();\n//      return;\n//    }\n//\n//    // s.socket;\n//\n//    s.end(\"hello world\\n\");\n//  });\n//\n//\nfunction normalizeConnectArgs(listArgs) {\n  var args = net._normalizeArgs(listArgs);\n  var options = args[0];\n  var cb = args[1];\n\n  // If args[0] was options, then normalize dealt with it.\n  // If args[0] is port, or args[0], args[1]  is host,port, we need to\n  // find the options and merge them in, normalize's options has only\n  // the host/port/path args that it knows about, not the tls options.\n  // This means that options.host overrides a host arg.\n  if (listArgs[1] !== null && typeof listArgs[1] === 'object') {\n    util._extend(options, listArgs[1]);\n  } else if (listArgs[2] !== null && typeof listArgs[2] === 'object') {\n    util._extend(options, listArgs[2]);\n  }\n\n  return (cb) ? [options, cb] : [options];\n}\n\nexports.connect = function(...args /* [port,] [host,] [options,] [cb] */) {\n  args = normalizeConnectArgs(args);\n  var options = args[0];\n  var cb = args[1];\n\n  var defaults = {\n    rejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,\n    ciphers: tls.DEFAULT_CIPHERS,\n    checkServerIdentity: tls.checkServerIdentity,\n    minDHSize: 1024\n  };\n\n  options = util._extend(defaults, options || {});\n  if (!options.keepAlive)\n    options.singleUse = true;\n\n  assert(typeof options.checkServerIdentity === 'function');\n  assert(typeof options.minDHSize === 'number',\n         'options.minDHSize is not a number: ' + options.minDHSize);\n  assert(options.minDHSize > 0,\n         'options.minDHSize is not a positive number: ' +\n         options.minDHSize);\n\n  var hostname = options.servername ||\n                 options.host ||\n                 (options.socket && options.socket._host) ||\n                 'localhost';\n  const NPN = {};\n  const ALPN = {};\n  const context = options.secureContext || tls.createSecureContext(options);\n  tls.convertNPNProtocols(options.NPNProtocols, NPN);\n  tls.convertALPNProtocols(options.ALPNProtocols, ALPN);\n\n  var socket = new TLSSocket(options.socket, {\n    pipe: options.path && !options.port,\n    secureContext: context,\n    isServer: false,\n    requestCert: true,\n    rejectUnauthorized: options.rejectUnauthorized !== false,\n    session: options.session,\n    NPNProtocols: NPN.NPNProtocols,\n    ALPNProtocols: ALPN.ALPNProtocols,\n    requestOCSP: options.requestOCSP\n  });\n\n  if (cb)\n    socket.once('secureConnect', cb);\n\n  if (!options.socket) {\n    var connect_opt;\n    if (options.path && !options.port) {\n      connect_opt = { path: options.path };\n    } else {\n      connect_opt = {\n        port: options.port,\n        host: options.host,\n        family: options.family,\n        localAddress: options.localAddress,\n        lookup: options.lookup\n      };\n    }\n    socket.connect(connect_opt, function() {\n      socket._start();\n    });\n  }\n\n  socket._releaseControl();\n\n  if (options.session)\n    socket.setSession(options.session);\n\n  if (options.servername)\n    socket.setServername(options.servername);\n\n  if (options.socket)\n    socket._start();\n\n  socket.on('secure', function() {\n    // Check the size of DHE parameter above minimum requirement\n    // specified in options.\n    var ekeyinfo = socket.getEphemeralKeyInfo();\n    if (ekeyinfo.type === 'DH' && ekeyinfo.size < options.minDHSize) {\n      var err = new Error('DH parameter size ' + ekeyinfo.size +\n                          ' is less than ' + options.minDHSize);\n      socket.emit('error', err);\n      socket.destroy();\n      return;\n    }\n\n    var verifyError = socket._handle.verifyError();\n\n    // Verify that server's identity matches it's certificate's names\n    // Unless server has resumed our existing session\n    if (!verifyError && !socket.isSessionReused()) {\n      var cert = socket.getPeerCertificate();\n      verifyError = options.checkServerIdentity(hostname, cert);\n    }\n\n    if (verifyError) {\n      socket.authorized = false;\n      socket.authorizationError = verifyError.code || verifyError.message;\n\n      if (options.rejectUnauthorized) {\n        socket.destroy(verifyError);\n        return;\n      } else {\n        socket.emit('secureConnect');\n      }\n    } else {\n      socket.authorized = true;\n      socket.emit('secureConnect');\n    }\n\n    // Uncork incoming data\n    socket.removeListener('end', onHangUp);\n  });\n\n  function onHangUp() {\n    // NOTE: This logic is shared with _http_client.js\n    if (!socket._hadError) {\n      socket._hadError = true;\n      var error = new Error('socket hang up');\n      error.code = 'ECONNRESET';\n      socket.destroy(error);\n    }\n  }\n  socket.once('end', onHangUp);\n\n  return socket;\n};\n",
  "tty": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst net = require('net');\nconst TTY = process.binding('tty_wrap').TTY;\nconst isTTY = process.binding('tty_wrap').isTTY;\nconst inherits = util.inherits;\nconst errnoException = util._errnoException;\n\n\nexports.isatty = function(fd) {\n  return isTTY(fd);\n};\n\n\nfunction ReadStream(fd, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(fd, options);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new RangeError('fd must be positive integer: ' + fd);\n\n  options = util._extend({\n    highWaterMark: 0,\n    readable: true,\n    writable: false,\n    handle: new TTY(fd, true)\n  }, options);\n\n  net.Socket.call(this, options);\n\n  this.isRaw = false;\n  this.isTTY = true;\n}\ninherits(ReadStream, net.Socket);\n\nexports.ReadStream = ReadStream;\n\nReadStream.prototype.setRawMode = function(flag) {\n  flag = !!flag;\n  this._handle.setRawMode(flag);\n  this.isRaw = flag;\n};\n\n\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(fd);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new RangeError('fd must be positive integer: ' + fd);\n\n  net.Socket.call(this, {\n    handle: new TTY(fd, false),\n    readable: false,\n    writable: true\n  });\n\n  // Prevents interleaved or dropped stdout/stderr output for terminals.\n  // As noted in the following reference, local TTYs tend to be quite fast and\n  // this behaviour has become expected due historical functionality on OS X,\n  // even though it was originally intended to change in v1.0.2 (Libuv 1.2.1).\n  // Ref: https://github.com/nodejs/node/pull/1771#issuecomment-119351671\n  this._handle.setBlocking(true);\n\n  var winSize = new Array(2);\n  var err = this._handle.getWindowSize(winSize);\n  if (!err) {\n    this.columns = winSize[0];\n    this.rows = winSize[1];\n  }\n}\ninherits(WriteStream, net.Socket);\nexports.WriteStream = WriteStream;\n\n\nWriteStream.prototype.isTTY = true;\n\n\nWriteStream.prototype._refreshSize = function() {\n  var oldCols = this.columns;\n  var oldRows = this.rows;\n  var winSize = new Array(2);\n  var err = this._handle.getWindowSize(winSize);\n  if (err) {\n    this.emit('error', errnoException(err, 'getWindowSize'));\n    return;\n  }\n  var newCols = winSize[0];\n  var newRows = winSize[1];\n  if (oldCols !== newCols || oldRows !== newRows) {\n    this.columns = newCols;\n    this.rows = newRows;\n    this.emit('resize');\n  }\n};\n\n\n// backwards-compat\nWriteStream.prototype.cursorTo = function(x, y) {\n  require('readline').cursorTo(this, x, y);\n};\nWriteStream.prototype.moveCursor = function(dx, dy) {\n  require('readline').moveCursor(this, dx, dy);\n};\nWriteStream.prototype.clearLine = function(dir) {\n  require('readline').clearLine(this, dir);\n};\nWriteStream.prototype.clearScreenDown = function() {\n  require('readline').clearScreenDown(this);\n};\nWriteStream.prototype.getWindowSize = function() {\n  return [this.columns, this.rows];\n};\n",
  "url": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst { toASCII } = process.binding('config').hasIntl ?\n  process.binding('icu') : require('punycode');\n\nconst { hexTable } = require('internal/querystring');\n\n// WHATWG URL implementation provided by internal/url\nconst {\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  formatSymbol\n} = require('internal/url');\n\n// Original url.parse() API\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i;\nconst portPattern = /:[0-9]*$/;\nconst hostPattern = /^\\/\\/[^@/]+@[^@/]+/;\n\n// Special case for a simple path URL\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/;\n\nconst hostnameMaxLen = 255;\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\nconst unsafeProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  'javascript': true,\n  'javascript:': true\n};\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  'http': true,\n  'http:': true,\n  'https': true,\n  'https:': true,\n  'ftp': true,\n  'ftp:': true,\n  'gopher': true,\n  'gopher:': true,\n  'file': true,\n  'file:': true\n};\nconst querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url instanceof Url) return url;\n\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n  if (typeof url !== 'string') {\n    throw new TypeError('Parameter \"url\" must be a string, not ' + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var hasHash = false;\n  var start = -1;\n  var end = -1;\n  var rest = '';\n  var lastPos = 0;\n  var i = 0;\n  for (var inWs = false, split = false; i < url.length; ++i) {\n    const code = url.charCodeAt(i);\n\n    // Find first and last non-whitespace characters for trimming\n    const isWs = code === 32/* */ ||\n                 code === 9/*\\t*/ ||\n                 code === 13/*\\r*/ ||\n                 code === 10/*\\n*/ ||\n                 code === 12/*\\f*/ ||\n                 code === 160/*\\u00A0*/ ||\n                 code === 65279/*\\uFEFF*/;\n    if (start === -1) {\n      if (isWs)\n        continue;\n      lastPos = start = i;\n    } else {\n      if (inWs) {\n        if (!isWs) {\n          end = -1;\n          inWs = false;\n        }\n      } else if (isWs) {\n        end = i;\n        inWs = true;\n      }\n    }\n\n    // Only convert backslashes while we haven't seen a split character\n    if (!split) {\n      switch (code) {\n        case 35: // '#'\n          hasHash = true;\n        // Fall through\n        case 63: // '?'\n          split = true;\n          break;\n        case 92: // '\\\\'\n          if (i - lastPos > 0)\n            rest += url.slice(lastPos, i);\n          rest += '/';\n          lastPos = i + 1;\n          break;\n      }\n    } else if (!hasHash && code === 35/*#*/) {\n      hasHash = true;\n    }\n  }\n\n  // Check if string was non-empty (including strings with only whitespace)\n  if (start !== -1) {\n    if (lastPos === start) {\n      // We didn't convert any backslashes\n\n      if (end === -1) {\n        if (start === 0)\n          rest = url;\n        else\n          rest = url.slice(start);\n      } else {\n        rest = url.slice(start, end);\n      }\n    } else if (end === -1 && lastPos < url.length) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos);\n    } else if (end !== -1 && lastPos < end) {\n      // We converted some backslashes and have only part of the entire string\n      rest += url.slice(lastPos, end);\n    }\n  }\n\n  if (!slashesDenoteHost && !hasHash) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.slice(1));\n        } else {\n          this.query = this.search.slice(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = Object.create(null);\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.slice(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || hostPattern.test(rest)) {\n    var slashes = rest.charCodeAt(0) === 47/*/*/ &&\n                  rest.charCodeAt(1) === 47/*/*/;\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.slice(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:b path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    var hostEnd = -1;\n    var atSign = -1;\n    var nonHost = -1;\n    for (i = 0; i < rest.length; ++i) {\n      switch (rest.charCodeAt(i)) {\n        case 9:   // '\\t'\n        case 10:  // '\\n'\n        case 13:  // '\\r'\n        case 32:  // ' '\n        case 34:  // '\"'\n        case 37:  // '%'\n        case 39:  // '\\''\n        case 59:  // ';'\n        case 60:  // '<'\n        case 62:  // '>'\n        case 92:  // '\\\\'\n        case 94:  // '^'\n        case 96:  // '`'\n        case 123: // '{'\n        case 124: // '|'\n        case 125: // '}'\n          // Characters that are never ever allowed in a hostname from RFC 2396\n          if (nonHost === -1)\n            nonHost = i;\n          break;\n        case 35: // '#'\n        case 47: // '/'\n        case 63: // '?'\n          // Find the first instance of any host-ending characters\n          if (nonHost === -1)\n            nonHost = i;\n          hostEnd = i;\n          break;\n        case 64: // '@'\n          // At this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          atSign = i;\n          nonHost = -1;\n          break;\n      }\n      if (hostEnd !== -1)\n        break;\n    }\n    start = 0;\n    if (atSign !== -1) {\n      this.auth = decodeURIComponent(rest.slice(0, atSign));\n      start = atSign + 1;\n    }\n    if (nonHost === -1) {\n      this.host = rest.slice(start);\n      rest = '';\n    } else {\n      this.host = rest.slice(start, nonHost);\n      rest = rest.slice(nonHost);\n    }\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    if (typeof this.hostname !== 'string')\n      this.hostname = '';\n\n    var hostname = this.hostname;\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = hostname.charCodeAt(0) === 91/*[*/ &&\n                       hostname.charCodeAt(hostname.length - 1) === 93/*]*/;\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const result = validateHostname(this, rest, hostname);\n      if (result !== undefined)\n        rest = result;\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n\n      // Use lenient mode (`true`) to try to support even non-compliant\n      // URLs.\n      this.hostname = toASCII(this.hostname, true);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.slice(1, -1);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    const result = autoEscapeStr(rest);\n    if (result !== undefined)\n      rest = result;\n  }\n\n  var questionIdx = -1;\n  var hashIdx = -1;\n  for (i = 0; i < rest.length; ++i) {\n    const code = rest.charCodeAt(i);\n    if (code === 35/*#*/) {\n      this.hash = rest.slice(i);\n      hashIdx = i;\n      break;\n    } else if (code === 63/*?*/ && questionIdx === -1) {\n      questionIdx = i;\n    }\n  }\n\n  if (questionIdx !== -1) {\n    if (hashIdx === -1) {\n      this.search = rest.slice(questionIdx);\n      this.query = rest.slice(questionIdx + 1);\n    } else {\n      this.search = rest.slice(questionIdx, hashIdx);\n      this.query = rest.slice(questionIdx + 1, hashIdx);\n    }\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = Object.create(null);\n  }\n\n  var firstIdx = (questionIdx !== -1 &&\n                  (hashIdx === -1 || questionIdx < hashIdx) ?\n                  questionIdx :\n                  hashIdx);\n  if (firstIdx === -1) {\n    if (rest.length > 0)\n      this.pathname = rest;\n  } else if (firstIdx > 0) {\n    this.pathname = rest.slice(0, firstIdx);\n  }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  // to support http.request\n  if (this.pathname || this.search) {\n    const p = this.pathname || '';\n    const s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\nfunction validateHostname(self, rest, hostname) {\n  for (var i = 0; i < hostname.length; ++i) {\n    const code = hostname.charCodeAt(i);\n    const isValid = (code >= 97/*a*/ && code <= 122/*z*/) ||\n                    code === 46/*.*/ ||\n                    (code >= 65/*A*/ && code <= 90/*Z*/) ||\n                    (code >= 48/*0*/ && code <= 57/*9*/) ||\n                    code === 45/*-*/ ||\n                    code === 43/*+*/ ||\n                    code === 95/*_*/ ||\n                    code > 127;\n\n    // Invalid host character\n    if (!isValid) {\n      self.hostname = hostname.slice(0, i);\n      return '/' + hostname.slice(i) + rest;\n    }\n  }\n}\n\n// Automatically escape all delimiters and unwise characters from RFC 2396.\n// Also escape single quotes in case of an XSS attack.\n// Return undefined if the string doesn't need escaping,\n// otherwise return the escaped string.\nfunction autoEscapeStr(rest) {\n  var escaped = '';\n  var lastEscapedPos = 0;\n  for (var i = 0; i < rest.length; ++i) {\n    // Manual switching is faster than using a Map/Object.\n    // `escaped` contains substring up to the last escaped cahracter.\n    switch (rest.charCodeAt(i)) {\n      case 9:   // '\\t'\n        // Concat if there are ordinary characters in the middle.\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%09';\n        lastEscapedPos = i + 1;\n        break;\n      case 10:  // '\\n'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%0A';\n        lastEscapedPos = i + 1;\n        break;\n      case 13:  // '\\r'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%0D';\n        lastEscapedPos = i + 1;\n        break;\n      case 32:  // ' '\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%20';\n        lastEscapedPos = i + 1;\n        break;\n      case 34:  // '\"'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%22';\n        lastEscapedPos = i + 1;\n        break;\n      case 39:  // '\\''\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%27';\n        lastEscapedPos = i + 1;\n        break;\n      case 60:  // '<'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%3C';\n        lastEscapedPos = i + 1;\n        break;\n      case 62:  // '>'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%3E';\n        lastEscapedPos = i + 1;\n        break;\n      case 92:  // '\\\\'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%5C';\n        lastEscapedPos = i + 1;\n        break;\n      case 94:  // '^'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%5E';\n        lastEscapedPos = i + 1;\n        break;\n      case 96:  // '`'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%60';\n        lastEscapedPos = i + 1;\n        break;\n      case 123: // '{'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%7B';\n        lastEscapedPos = i + 1;\n        break;\n      case 124: // '|'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%7C';\n        lastEscapedPos = i + 1;\n        break;\n      case 125: // '}'\n        if (i > lastEscapedPos)\n          escaped += rest.slice(lastEscapedPos, i);\n        escaped += '%7D';\n        lastEscapedPos = i + 1;\n        break;\n    }\n  }\n  if (lastEscapedPos === 0)  // Nothing has been escaped.\n    return;\n  // There are ordinary characters at the end.\n  if (lastEscapedPos < rest.length)\n    return escaped + rest.slice(lastEscapedPos);\n  else  // The last character is escaped.\n    return escaped;\n}\n\n// format a parsed object into a url string\nfunction urlFormat(obj, options) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (typeof obj === 'string') {\n    obj = urlParse(obj);\n  } else if (typeof obj !== 'object' || obj === null) {\n    throw new TypeError('Parameter \"urlObj\" must be an object, not ' +\n                        (obj === null ? 'null' : typeof obj));\n  } else if (!(obj instanceof Url)) {\n    var format = obj[formatSymbol];\n    return format ?\n      format.call(obj, options) :\n      Url.prototype.format.call(obj);\n  }\n  return obj.format();\n}\n\nUrl.prototype.format = function format() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeAuth(auth);\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '';\n  var pathname = this.pathname || '';\n  var hash = this.hash || '';\n  var host = '';\n  var query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query !== null && typeof this.query === 'object')\n    query = querystring.stringify(this.query);\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58/*:*/)\n    protocol += ':';\n\n  var newPathname = '';\n  var lastPos = 0;\n  for (var i = 0; i < pathname.length; ++i) {\n    switch (pathname.charCodeAt(i)) {\n      case 35: // '#'\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += '%23';\n        lastPos = i + 1;\n        break;\n      case 63: // '?'\n        if (i - lastPos > 0)\n          newPathname += pathname.slice(lastPos, i);\n        newPathname += '%3F';\n        lastPos = i + 1;\n        break;\n    }\n  }\n  if (lastPos > 0) {\n    if (lastPos !== pathname.length)\n      pathname = newPathname + pathname.slice(lastPos);\n    else\n      pathname = newPathname;\n  }\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes || slashedProtocol[protocol]) {\n    if (this.slashes || host) {\n      if (pathname && pathname.charCodeAt(0) !== 47/*/*/)\n        pathname = '/' + pathname;\n      host = '//' + host;\n    } else if (protocol.length >= 4 &&\n               protocol.charCodeAt(0) === 102/*f*/ &&\n               protocol.charCodeAt(1) === 105/*i*/ &&\n               protocol.charCodeAt(2) === 108/*l*/ &&\n               protocol.charCodeAt(3) === 101/*e*/) {\n      host = '//';\n    }\n  }\n\n  search = search.replace(/#/g, '%23');\n\n  if (hash && hash.charCodeAt(0) !== 35/*#*/) hash = '#' + hash;\n  if (search && search.charCodeAt(0) !== 63/*?*/) search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function resolve(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function resolveObject(relative) {\n  if (typeof relative === 'string') {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host &&\n        !/^file:?$/.test(relative.protocol) &&\n        !hostlessProtocol[relative.protocol]) {\n      const relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');\n  var isRelAbs = (\n      relative.host ||\n      relative.pathname && relative.pathname.charAt(0) === '/'\n  );\n  var mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname));\n  var removeAllDots = mustEndAbs;\n  var srcPath = result.pathname && result.pathname.split('/') || [];\n  var relPath = relative.pathname && relative.pathname.split('/') || [];\n  var noLeadingSlashes = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (noLeadingSlashes) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      result.auth = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    if (relative.host || relative.host === '') {\n      if (result.host !== relative.host) result.auth = null;\n      result.host = relative.host;\n      result.port = relative.port;\n    }\n    if (relative.hostname || relative.hostname === '') {\n      if (result.hostname !== relative.hostname) result.auth = null;\n      result.hostname = relative.hostname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (relative.search !== null && relative.search !== undefined) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (noLeadingSlashes) {\n      result.hostname = result.host = srcPath.shift();\n      //occasionally the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      const authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (result.pathname !== null || result.search !== null) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length - 1; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      spliceOne(srcPath, i);\n    } else if (last === '..') {\n      spliceOne(srcPath, i);\n      up++;\n    } else if (up) {\n      spliceOne(srcPath, i);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (noLeadingSlashes) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occasionally the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    const authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (result.pathname !== null || result.search !== null) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function parseHost() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.slice(1);\n    }\n    host = host.slice(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\n// These characters do not need escaping:\n// ! - . _ ~\n// ' ( ) * :\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscapeAuth = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0  // 0x70 - 0x7F\n];\n\nfunction encodeAuth(str) {\n  // faster encodeURIComponent alternative for encoding auth uri components\n  var out = '';\n  var lastPos = 0;\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscapeAuth[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += hexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | (c >> 12)] +\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < str.length)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else\n      c2 = 0;\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += hexTable[0xF0 | (c >> 18)] +\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\n           hexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < str.length)\n    return out + str.slice(lastPos);\n  return out;\n}\n\nmodule.exports = {\n  // Original API\n  Url,\n  parse: urlParse,\n  resolve: urlResolve,\n  resolveObject: urlResolveObject,\n  format: urlFormat,\n\n  // WHATWG API\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode\n};\n",
  "util": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst uv = process.binding('uv');\nconst Buffer = require('buffer').Buffer;\nconst internalUtil = require('internal/util');\nconst binding = process.binding('util');\n\nconst isError = internalUtil.isError;\n\nconst inspectDefaultOptions = Object.seal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  breakLength: 60\n});\n\nvar CIRCULAR_ERROR_MESSAGE;\nvar Debug;\n\nfunction tryStringify(arg) {\n  try {\n    return JSON.stringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSON.stringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = err.message;\n      }\n    }\n    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE)\n      return '[Circular]';\n    throw err;\n  }\n}\n\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    const objects = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n      objects[index] = inspect(arguments[index]);\n    }\n    return objects.join(' ');\n  }\n\n  var argLen = arguments.length;\n\n  if (argLen === 1) return f;\n\n  var str = '';\n  var a = 1;\n  var lastPos = 0;\n  for (var i = 0; i < f.length;) {\n    if (f.charCodeAt(i) === 37/*'%'*/ && i + 1 < f.length) {\n      switch (f.charCodeAt(i + 1)) {\n        case 100: // 'd'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += Number(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 105: // 'i'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += parseInt(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 102: // 'f'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += parseFloat(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 106: // 'j'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += tryStringify(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 115: // 's'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += String(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 37: // '%'\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += '%';\n          lastPos = i = i + 2;\n          continue;\n      }\n    }\n    ++i;\n  }\n  if (lastPos === 0)\n    str = f;\n  else if (lastPos < f.length)\n    str += f.slice(lastPos);\n  while (a < argLen) {\n    const x = arguments[a++];\n    if (x === null || (typeof x !== 'object' && typeof x !== 'symbol')) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\nexports.deprecate = internalUtil.deprecate;\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (debugEnviron === undefined)\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp(`\\\\b${set}\\\\b`, 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3 && arguments[2] !== undefined) {\n    ctx.depth = arguments[2];\n  }\n  if (arguments.length >= 4 && arguments[3] !== undefined) {\n    ctx.colors = arguments[3];\n  }\n  if (typeof opts === 'boolean') {\n    // legacy...\n    ctx.showHidden = opts;\n  }\n  // Set default and user-specified options\n  ctx = Object.assign({}, inspect.defaultOptions, ctx, opts);\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\nObject.defineProperty(inspect, 'defaultOptions', {\n  get: function() {\n    return inspectDefaultOptions;\n  },\n  set: function(options) {\n    if (options === null || typeof options !== 'object') {\n      throw new TypeError('\"options\" must be an object');\n    }\n    Object.assign(inspectDefaultOptions, options);\n    return inspectDefaultOptions;\n  }\n});\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = Object.assign(Object.create(null), {\n  'bold': [1, 22],\n  'italic': [3, 23],\n  'underline': [4, 24],\n  'inverse': [7, 27],\n  'white': [37, 39],\n  'grey': [90, 39],\n  'black': [30, 39],\n  'blue': [34, 39],\n  'cyan': [36, 39],\n  'green': [32, 39],\n  'magenta': [35, 39],\n  'red': [31, 39],\n  'yellow': [33, 39]\n});\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = Object.assign(Object.create(null), {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'symbol': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n});\n\nconst customInspectSymbol = internalUtil.customInspectSymbol;\n\nexports.inspect = inspect;\nexports.inspect.custom = customInspectSymbol;\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return `\\u001b[${inspect.colors[style][0]}m${str}` +\n           `\\u001b[${inspect.colors[style][1]}m`;\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = Object.create(null);\n\n  for (var i = 0; i < array.length; i++) {\n    var val = array[i];\n    hash[val] = true;\n  }\n\n  return hash;\n}\n\n\nfunction ensureDebugIsInitialized() {\n  if (Debug === undefined) {\n    const runInDebugContext = require('vm').runInDebugContext;\n    Debug = runInDebugContext('Debug');\n  }\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  if (ctx.showProxy &&\n      ((typeof value === 'object' && value !== null) ||\n       typeof value === 'function')) {\n    var proxy = undefined;\n    var proxyCache = ctx.proxyCache;\n    if (!proxyCache)\n      proxyCache = ctx.proxyCache = new Map();\n    // Determine if we've already seen this object and have\n    // determined that it either is or is not a proxy.\n    if (proxyCache.has(value)) {\n      // We've seen it, if the value is not undefined, it's a Proxy.\n      proxy = proxyCache.get(value);\n    } else {\n      // Haven't seen it. Need to check.\n      // If it's not a Proxy, this will return undefined.\n      // Otherwise, it'll return an array. The first item\n      // is the target, the second item is the handler.\n      // We ignore (and do not return) the Proxy isRevoked property.\n      proxy = binding.getProxyDetails(value);\n      if (proxy) {\n        // We know for a fact that this isn't a Proxy.\n        // Mark it as having already been evaluated.\n        // We do this because this object is passed\n        // recursively to formatValue below in order\n        // for it to get proper formatting, and because\n        // the target and handle objects also might be\n        // proxies... it's unfortunate but necessary.\n        proxyCache.set(proxy, undefined);\n      }\n      // If the object is not a Proxy, then this stores undefined.\n      // This tells the code above that we've already checked and\n      // ruled it out. If the object is a proxy, this caches the\n      // results of the getProxyDetails call.\n      proxyCache.set(value, proxy);\n    }\n    if (proxy) {\n      return 'Proxy ' + formatValue(ctx, proxy, recurseTimes);\n    }\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect && value) {\n    const maybeCustomInspect = value[customInspectSymbol] || value.inspect;\n\n    if (typeof maybeCustomInspect === 'function' &&\n        // Filter out the util module, its inspect function is special\n        maybeCustomInspect !== exports.inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      let ret = maybeCustomInspect.call(value, recurseTimes, ctx);\n\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== value) {\n        if (typeof ret !== 'string') {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n      }\n    }\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n  const symbolKeys = Object.getOwnPropertySymbols(value);\n  const enumSymbolKeys = symbolKeys\n      .filter((key) => Object.prototype.propertyIsEnumerable.call(value, key));\n  keys = keys.concat(enumSymbolKeys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value).concat(symbolKeys);\n  }\n\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\n  // a number which, when object has some additional user-stored `keys`,\n  // will be printed out.\n  var formatted;\n  var raw = value;\n  try {\n    // the .valueOf() call can fail for a multitude of reasons\n    if (!isDate(value))\n      raw = value.valueOf();\n  } catch (e) {\n    // ignore...\n  }\n\n  if (typeof raw === 'string') {\n    // for boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    keys = keys.filter(function(key) {\n      if (typeof key === 'symbol') {\n        return true;\n      }\n\n      return !(key >= 0 && key < raw.length);\n    });\n  }\n\n  var constructor = internalUtil.getConstructorOf(value);\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      const ctorName = constructor ? constructor.name : 'Function';\n      return ctx.stylize(\n          `[${ctorName}${value.name ? `: ${value.name}` : ''}]`, 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      if (Number.isNaN(value.getTime())) {\n        return ctx.stylize(value.toString(), 'date');\n      } else {\n        return ctx.stylize(Date.prototype.toISOString.call(value), 'date');\n      }\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n    // now check the `raw` value to handle boxed primitives\n    if (typeof raw === 'string') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[String: ${formatted}]`, 'string');\n    }\n    if (typeof raw === 'symbol') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Symbol: ${formatted}]`, 'symbol');\n    }\n    if (typeof raw === 'number') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Number: ${formatted}]`, 'number');\n    }\n    if (typeof raw === 'boolean') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Boolean: ${formatted}]`, 'boolean');\n    }\n    // Fast path for ArrayBuffer and SharedArrayBuffer.\n    // Can't do the same for DataView because it has a non-primitive\n    // .buffer property that we need to recurse for.\n    if (binding.isAnyArrayBuffer(value)) {\n      return `${constructor.name}` +\n             ` { byteLength: ${formatNumber(ctx, value.byteLength)} }`;\n    }\n    if (binding.isExternal(value)) {\n      return ctx.stylize('[External]', 'special');\n    }\n  }\n\n  var base = '';\n  var empty = false;\n  var formatter = formatObject;\n  var braces;\n\n  // We can't compare constructors for various objects using a comparison like\n  // `constructor === Array` because the object could have come from a different\n  // context and thus the constructor won't match. Instead we check the\n  // constructor names (including those up the prototype chain where needed) to\n  // determine object types.\n  if (Array.isArray(value)) {\n    // Unset the constructor to prevent \"Array [...]\" for ordinary arrays.\n    if (constructor && constructor.name === 'Array')\n      constructor = null;\n    braces = ['[', ']'];\n    empty = value.length === 0;\n    formatter = formatArray;\n  } else if (binding.isSet(value)) {\n    braces = ['{', '}'];\n    // With `showHidden`, `length` will display as a hidden property for\n    // arrays. For consistency's sake, do the same for `size`, even though this\n    // property isn't selected by Object.getOwnPropertyNames().\n    if (ctx.showHidden)\n      keys.unshift('size');\n    empty = value.size === 0;\n    formatter = formatSet;\n  } else if (binding.isMap(value)) {\n    braces = ['{', '}'];\n    // Ditto.\n    if (ctx.showHidden)\n      keys.unshift('size');\n    empty = value.size === 0;\n    formatter = formatMap;\n  } else if (binding.isAnyArrayBuffer(value)) {\n    braces = ['{', '}'];\n    keys.unshift('byteLength');\n    visibleKeys.byteLength = true;\n  } else if (binding.isDataView(value)) {\n    braces = ['{', '}'];\n    // .buffer goes last, it's not a primitive like the others.\n    keys.unshift('byteLength', 'byteOffset', 'buffer');\n    visibleKeys.byteLength = true;\n    visibleKeys.byteOffset = true;\n    visibleKeys.buffer = true;\n  } else if (binding.isTypedArray(value)) {\n    braces = ['[', ']'];\n    formatter = formatTypedArray;\n    if (ctx.showHidden) {\n      // .buffer goes last, it's not a primitive like the others.\n      keys.unshift('BYTES_PER_ELEMENT',\n                   'length',\n                   'byteLength',\n                   'byteOffset',\n                   'buffer');\n    }\n  } else if (binding.isPromise(value)) {\n    braces = ['{', '}'];\n    formatter = formatPromise;\n  } else if (binding.isMapIterator(value)) {\n    constructor = { name: 'MapIterator' };\n    braces = ['{', '}'];\n    empty = false;\n    formatter = formatCollectionIterator;\n  } else if (binding.isSetIterator(value)) {\n    constructor = { name: 'SetIterator' };\n    braces = ['{', '}'];\n    empty = false;\n    formatter = formatCollectionIterator;\n  } else {\n    // Unset the constructor to prevent \"Object {...}\" for ordinary objects.\n    if (constructor && constructor.name === 'Object')\n      constructor = null;\n    braces = ['{', '}'];\n    empty = true;  // No other data than keys.\n  }\n\n  empty = empty === true && keys.length === 0;\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    const ctorName = constructor ? constructor.name : 'Function';\n    base = ` [${ctorName}${value.name ? `: ${value.name}` : ''}]`;\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toISOString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  // Make boxed primitive Strings look like such\n  if (typeof raw === 'string') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [String: ${formatted}]`;\n  }\n\n  // Make boxed primitive Numbers look like such\n  if (typeof raw === 'number') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [Number: ${formatted}]`;\n  }\n\n  // Make boxed primitive Booleans look like such\n  if (typeof raw === 'boolean') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [Boolean: ${formatted}]`;\n  }\n\n  // Add constructor name if available\n  if (base === '' && constructor)\n    braces[0] = `${constructor.name} ${braces[0]}`;\n\n  if (empty === true) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else if (Array.isArray(value)) {\n      return ctx.stylize('[Array]', 'special');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output = formatter(ctx, value, recurseTimes, visibleKeys, keys);\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces, ctx.breakLength);\n}\n\n\nfunction formatNumber(ctx, value) {\n  // Format -0 as '-0'. Strict equality won't distinguish 0 from -0.\n  if (Object.is(value, -0))\n    return ctx.stylize('-0', 'number');\n  return ctx.stylize('' + value, 'number');\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (value === undefined)\n    return ctx.stylize('undefined', 'undefined');\n\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null)\n    return ctx.stylize('null', 'null');\n\n  var type = typeof value;\n\n  if (type === 'string') {\n    var simple = '\\'' +\n                 JSON.stringify(value)\n                     .replace(/^\"|\"$/g, '')\n                     .replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"') +\n                 '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (type === 'number')\n    return formatNumber(ctx, value);\n  if (type === 'boolean')\n    return ctx.stylize('' + value, 'boolean');\n  // es6 symbol primitive\n  if (type === 'symbol')\n    return ctx.stylize(value.toString(), 'symbol');\n}\n\n\nfunction formatPrimitiveNoColor(ctx, value) {\n  var stylize = ctx.stylize;\n  ctx.stylize = stylizeNoColor;\n  var str = formatPrimitive(ctx, value);\n  ctx.stylize = stylize;\n  return str;\n}\n\n\nfunction formatError(value) {\n  return value.stack || `[${Error.prototype.toString.call(value)}]`;\n}\n\n\nfunction formatObject(ctx, value, recurseTimes, visibleKeys, keys) {\n  return keys.map(function(key) {\n    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, false);\n  });\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  let visibleLength = 0;\n  let index = 0;\n  while (index < value.length && visibleLength < ctx.maxArrayLength) {\n    let emptyItems = 0;\n    while (index < value.length && !hasOwnProperty(value, String(index))) {\n      emptyItems++;\n      index++;\n    }\n    if (emptyItems > 0) {\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n    } else {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                                 String(index), true));\n      index++;\n    }\n    visibleLength++;\n  }\n  var remaining = value.length - index;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  for (var n = 0; n < keys.length; n++) {\n    var key = keys[n];\n    if (typeof key === 'symbol' || !key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                                 key, true));\n    }\n  }\n  return output;\n}\n\n\nfunction formatTypedArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n  const remaining = value.length - maxLength;\n  var output = new Array(maxLength);\n  for (var i = 0; i < maxLength; ++i)\n    output[i] = formatNumber(ctx, value[i]);\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  for (const key of keys) {\n    if (typeof key === 'symbol' || !key.match(/^\\d+$/)) {\n      output.push(\n          formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n    }\n  }\n  return output;\n}\n\n\nfunction formatSet(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  value.forEach(function(v) {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, v, nextRecurseTimes);\n    output.push(str);\n  });\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\n\nfunction formatMap(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  value.forEach(function(v, k) {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, k, nextRecurseTimes);\n    str += ' => ';\n    str += formatValue(ctx, v, nextRecurseTimes);\n    output.push(str);\n  });\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\nfunction formatCollectionIterator(ctx, value, recurseTimes, visibleKeys, keys) {\n  ensureDebugIsInitialized();\n  const mirror = Debug.MakeMirror(value, true);\n  var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n  var vals = mirror.preview();\n  var output = [];\n  for (const o of vals) {\n    output.push(formatValue(ctx, o, nextRecurseTimes));\n  }\n  return output;\n}\n\nfunction formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {\n  const output = [];\n  const [state, result] = binding.getPromiseDetails(value);\n\n  if (state === binding.kPending) {\n    output.push('<pending>');\n  } else {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, result, nextRecurseTimes);\n    if (state === binding.kRejected) {\n      output.push('<rejected> ' + str);\n    } else {\n      output.push(str);\n    }\n  }\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    if (typeof key === 'symbol') {\n      name = `[${ctx.stylize(key.toString(), 'symbol')}]`;\n    } else {\n      name = `[${key}]`;\n    }\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.replace(/\\n/g, '\\n  ');\n        } else {\n          str = str.replace(/(^|\\n)/g, '\\n   ');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (name === undefined) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\")\n                 .replace(/\\\\\\\\/g, '\\\\');\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return `${name}: ${str}`;\n}\n\n\nfunction reduceToSingleString(output, base, braces, breakLength) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > breakLength) {\n    return braces[0] +\n           // If the opening \"brace\" is too large, like in the case of \"Set {\",\n           // we need to force the first item to be on the next line or the\n           // items will not line up correctly.\n           (base === '' && braces[0].length === 1 ? '' : base + '\\n ') +\n           ` ${output.join(',\\n  ')} ${braces[1]}`;\n  }\n\n  return `${braces[0]}${base} ${output.join(', ')} ${braces[1]}`;\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.isArray = Array.isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg === null || arg === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === undefined;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return binding.isRegExp(re);\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return arg !== null && typeof arg === 'object';\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return binding.isDate(d);\n}\nexports.isDate = isDate;\n\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg !== 'object' && typeof arg !== 'function';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nconst months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n                'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n * @throws {TypeError} Will error if either constructor is null, or if\n *     the super constructor lacks a prototype.\n */\nexports.inherits = function(ctor, superCtor) {\n\n  if (ctor === undefined || ctor === null)\n    throw new TypeError('The constructor to \"inherits\" must not be ' +\n                        'null or undefined');\n\n  if (superCtor === undefined || superCtor === null)\n    throw new TypeError('The super constructor to \"inherits\" must not ' +\n                        'be null or undefined');\n\n  if (superCtor.prototype === undefined)\n    throw new TypeError('The super constructor to \"inherits\" must ' +\n                        'have a prototype');\n\n  ctor.super_ = superCtor;\n  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);\n};\n\nexports._extend = function(target, source) {\n  // Don't do anything if source isn't an object\n  if (source === null || typeof source !== 'object') return target;\n\n  var keys = Object.keys(source);\n  var i = keys.length;\n  while (i--) {\n    target[keys[i]] = source[keys[i]];\n  }\n  return target;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n// Deprecated old stuff.\n\nexports.print = internalUtil.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(String(arguments[i]));\n  }\n}, 'util.print is deprecated. Use console.log instead.', 'DEP0026');\n\n\nexports.puts = internalUtil.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(arguments[i] + '\\n');\n  }\n}, 'util.puts is deprecated. Use console.log instead.', 'DEP0027');\n\n\nexports.debug = internalUtil.deprecate(function(x) {\n  process.stderr.write(`DEBUG: ${x}\\n`);\n}, 'util.debug is deprecated. Use console.error instead.', 'DEP0028');\n\n\nexports.error = internalUtil.deprecate(function(x) {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stderr.write(arguments[i] + '\\n');\n  }\n}, 'util.error is deprecated. Use console.error instead.', 'DEP0029');\n\n\nexports._errnoException = function(err, syscall, original) {\n  var errname = uv.errname(err);\n  var message = `${syscall} ${errname}`;\n  if (original)\n    message += ' ' + original;\n  var e = new Error(message);\n  e.code = errname;\n  e.errno = errname;\n  e.syscall = syscall;\n  return e;\n};\n\n\nexports._exceptionWithHostPort = function(err,\n                                          syscall,\n                                          address,\n                                          port,\n                                          additional) {\n  var details;\n  if (port && port > 0) {\n    details = `${address}:${port}`;\n  } else {\n    details = address;\n  }\n\n  if (additional) {\n    details += ` - Local (${additional})`;\n  }\n  var ex = exports._errnoException(err, syscall, details);\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  return ex;\n};\n\n// process.versions needs a custom function as some values are lazy-evaluated.\nprocess.versions[exports.inspect.custom] =\n  (depth) => exports.format(JSON.parse(JSON.stringify(process.versions)));\n\nexports.promisify = internalUtil.promisify;\n",
  "v8": "// Copyright (c) 2014, StrongLoop Inc.\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst { Serializer, Deserializer } = process.binding('serdes');\nconst { copy } = process.binding('buffer');\nconst { objectToString } = require('internal/util');\nconst { FastBuffer } = require('internal/buffer');\n\nconst {\n  cachedDataVersionTag,\n  setFlagsFromString,\n  heapStatisticsArrayBuffer,\n  heapSpaceStatisticsArrayBuffer,\n  updateHeapStatisticsArrayBuffer,\n  updateHeapSpaceStatisticsArrayBuffer,\n\n  // Properties for heap and heap space statistics buffer extraction.\n  kTotalHeapSizeIndex,\n  kTotalHeapSizeExecutableIndex,\n  kTotalPhysicalSizeIndex,\n  kTotalAvailableSize,\n  kUsedHeapSizeIndex,\n  kHeapSizeLimitIndex,\n  kDoesZapGarbageIndex,\n  kMallocedMemoryIndex,\n  kPeakMallocedMemoryIndex,\n  kHeapSpaces,\n  kHeapSpaceStatisticsPropertiesCount,\n  kSpaceSizeIndex,\n  kSpaceUsedSizeIndex,\n  kSpaceAvailableSizeIndex,\n  kPhysicalSpaceSizeIndex\n} = process.binding('v8');\n\nconst kNumberOfHeapSpaces = kHeapSpaces.length;\n\nconst heapStatisticsBuffer =\n    new Float64Array(heapStatisticsArrayBuffer);\n\nconst heapSpaceStatisticsBuffer =\n    new Float64Array(heapSpaceStatisticsArrayBuffer);\n\nfunction getHeapStatistics() {\n  const buffer = heapStatisticsBuffer;\n\n  updateHeapStatisticsArrayBuffer();\n\n  return {\n    'total_heap_size': buffer[kTotalHeapSizeIndex],\n    'total_heap_size_executable': buffer[kTotalHeapSizeExecutableIndex],\n    'total_physical_size': buffer[kTotalPhysicalSizeIndex],\n    'total_available_size': buffer[kTotalAvailableSize],\n    'used_heap_size': buffer[kUsedHeapSizeIndex],\n    'heap_size_limit': buffer[kHeapSizeLimitIndex],\n    'malloced_memory': buffer[kMallocedMemoryIndex],\n    'peak_malloced_memory': buffer[kPeakMallocedMemoryIndex],\n    'does_zap_garbage': buffer[kDoesZapGarbageIndex]\n  };\n}\n\nfunction getHeapSpaceStatistics() {\n  const heapSpaceStatistics = new Array(kNumberOfHeapSpaces);\n  const buffer = heapSpaceStatisticsBuffer;\n  updateHeapSpaceStatisticsArrayBuffer();\n\n  for (var i = 0; i < kNumberOfHeapSpaces; i++) {\n    const propertyOffset = i * kHeapSpaceStatisticsPropertiesCount;\n    heapSpaceStatistics[i] = {\n      space_name: kHeapSpaces[i],\n      space_size: buffer[propertyOffset + kSpaceSizeIndex],\n      space_used_size: buffer[propertyOffset + kSpaceUsedSizeIndex],\n      space_available_size: buffer[propertyOffset + kSpaceAvailableSizeIndex],\n      physical_space_size: buffer[propertyOffset + kPhysicalSpaceSizeIndex]\n    };\n  }\n\n  return heapSpaceStatistics;\n}\n\n/* V8 serialization API */\n\n/* JS methods for the base objects */\nSerializer.prototype._getDataCloneError = Error;\n\nDeserializer.prototype.readRawBytes = function readRawBytes(length) {\n  const offset = this._readRawBytes(length);\n  // `this.buffer` can be a Buffer or a plain Uint8Array, so just calling\n  // `.slice()` doesn't work.\n  return new FastBuffer(this.buffer.buffer,\n                        this.buffer.byteOffset + offset,\n                        length);\n};\n\n/* Keep track of how to handle different ArrayBufferViews.\n * The default Serializer for Node does not use the V8 methods for serializing\n * those objects because Node's `Buffer` objects use pooled allocation in many\n * cases, and their underlying `ArrayBuffer`s would show up in the\n * serialization. Because a) those may contain sensitive data and the user\n * may not be aware of that and b) they are often much larger than the `Buffer`\n * itself, custom serialization is applied. */\nconst arrayBufferViewTypes = [Int8Array, Uint8Array, Uint8ClampedArray,\n                              Int16Array, Uint16Array, Int32Array, Uint32Array,\n                              Float32Array, Float64Array, DataView];\n\nconst arrayBufferViewTypeToIndex = new Map();\n\n{\n  const dummy = new ArrayBuffer();\n  for (const [i, ctor] of arrayBufferViewTypes.entries()) {\n    const tag = objectToString(new ctor(dummy));\n    arrayBufferViewTypeToIndex.set(tag, i);\n  }\n}\n\nconst bufferConstructorIndex = arrayBufferViewTypes.push(Buffer) - 1;\n\nclass DefaultSerializer extends Serializer {\n  constructor() {\n    super();\n\n    this._setTreatArrayBufferViewsAsHostObjects(true);\n  }\n\n  _writeHostObject(abView) {\n    let i = 0;\n    if (abView.constructor === Buffer) {\n      i = bufferConstructorIndex;\n    } else {\n      const tag = objectToString(abView);\n      i = arrayBufferViewTypeToIndex.get(tag);\n\n      if (i === undefined) {\n        throw this._getDataCloneError(`Unknown host object type: ${tag}`);\n      }\n    }\n    this.writeUint32(i);\n    this.writeUint32(abView.byteLength);\n    this.writeRawBytes(new Uint8Array(abView.buffer,\n                                      abView.byteOffset,\n                                      abView.byteLength));\n  }\n}\n\nclass DefaultDeserializer extends Deserializer {\n  constructor(buffer) {\n    super(buffer);\n  }\n\n  _readHostObject() {\n    const typeIndex = this.readUint32();\n    const ctor = arrayBufferViewTypes[typeIndex];\n    const byteLength = this.readUint32();\n    const byteOffset = this._readRawBytes(byteLength);\n    const BYTES_PER_ELEMENT = ctor.BYTES_PER_ELEMENT || 1;\n\n    const offset = this.buffer.byteOffset + byteOffset;\n    if (offset % BYTES_PER_ELEMENT === 0) {\n      return new ctor(this.buffer.buffer,\n                      offset,\n                      byteLength / BYTES_PER_ELEMENT);\n    } else {\n      // Copy to an aligned buffer first.\n      const buffer_copy = Buffer.allocUnsafe(byteLength);\n      copy(this.buffer, buffer_copy, 0, byteOffset, byteOffset + byteLength);\n      return new ctor(buffer_copy.buffer,\n                      buffer_copy.byteOffset,\n                      byteLength / BYTES_PER_ELEMENT);\n    }\n  }\n}\n\nfunction serialize(value) {\n  const ser = new DefaultSerializer();\n  ser.writeHeader();\n  ser.writeValue(value);\n  return ser.releaseBuffer();\n}\n\nfunction deserialize(buffer) {\n  const der = new DefaultDeserializer(buffer);\n  der.readHeader();\n  return der.readValue();\n}\n\nmodule.exports = exports = {\n  cachedDataVersionTag,\n  getHeapStatistics,\n  getHeapSpaceStatistics,\n  setFlagsFromString,\n  Serializer,\n  Deserializer,\n  DefaultSerializer,\n  DefaultDeserializer,\n  deserialize,\n  serialize\n};\n",
  "vm": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst binding = process.binding('contextify');\nconst Script = binding.ContextifyScript;\n\n// The binding provides a few useful primitives:\n// - Script(code, { filename = \"evalmachine.anonymous\",\n//                  displayErrors = true } = {})\n//   with methods:\n//   - runInThisContext({ displayErrors = true } = {})\n//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})\n// - makeContext(sandbox)\n// - isContext(sandbox)\n// From this we build the entire documented API.\n\nconst realRunInThisContext = Script.prototype.runInThisContext;\nconst realRunInContext = Script.prototype.runInContext;\n\nScript.prototype.runInThisContext = function(options) {\n  if (options && options.breakOnSigint && process._events.SIGINT) {\n    return sigintHandlersWrap(realRunInThisContext, this, [options]);\n  } else {\n    return realRunInThisContext.call(this, options);\n  }\n};\n\nScript.prototype.runInContext = function(contextifiedSandbox, options) {\n  if (options && options.breakOnSigint && process._events.SIGINT) {\n    return sigintHandlersWrap(realRunInContext, this,\n                              [contextifiedSandbox, options]);\n  } else {\n    return realRunInContext.call(this, contextifiedSandbox, options);\n  }\n};\n\nScript.prototype.runInNewContext = function(sandbox, options) {\n  var context = createContext(sandbox);\n  return this.runInContext(context, options);\n};\n\nfunction createContext(sandbox) {\n  if (sandbox === undefined) {\n    sandbox = {};\n  } else if (binding.isContext(sandbox)) {\n    return sandbox;\n  }\n\n  binding.makeContext(sandbox);\n  return sandbox;\n}\n\nfunction createScript(code, options) {\n  return new Script(code, options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed, so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn, thisArg, argsArray) {\n  // Using the internal list here to make sure `.once()` wrappers are used,\n  // not the original ones.\n  let sigintListeners = process._events.SIGINT;\n\n  if (Array.isArray(sigintListeners))\n    sigintListeners = sigintListeners.slice();\n  else\n    sigintListeners = [sigintListeners];\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return fn.apply(thisArg, argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    for (const listener of sigintListeners) {\n      process.addListener('SIGINT', listener);\n    }\n  }\n}\n\nfunction runInDebugContext(code) {\n  return binding.runInDebugContext(code);\n}\n\nfunction runInContext(code, contextifiedSandbox, options) {\n  return createScript(code, options)\n    .runInContext(contextifiedSandbox, options);\n}\n\nfunction runInNewContext(code, sandbox, options) {\n  return createScript(code, options).runInNewContext(sandbox, options);\n}\n\nfunction runInThisContext(code, options) {\n  return createScript(code, options).runInThisContext(options);\n}\n\nmodule.exports = {\n  Script,\n  createContext,\n  createScript,\n  runInDebugContext,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext: binding.isContext\n};\n",
  "zlib": "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst internalUtil = require('internal/util');\nconst Transform = require('_stream_transform');\nconst binding = process.binding('zlib');\nconst assert = require('assert').ok;\nconst kMaxLength = require('buffer').kMaxLength;\nconst kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' +\n                           `than 0x${kMaxLength.toString(16)} bytes`;\n\nconst constants = process.binding('constants').zlib;\nconst createClassWrapper = internalUtil.createClassWrapper;\n\n// translation table for return codes.\nconst codes = {\n  Z_OK: constants.Z_OK,\n  Z_STREAM_END: constants.Z_STREAM_END,\n  Z_NEED_DICT: constants.Z_NEED_DICT,\n  Z_ERRNO: constants.Z_ERRNO,\n  Z_STREAM_ERROR: constants.Z_STREAM_ERROR,\n  Z_DATA_ERROR: constants.Z_DATA_ERROR,\n  Z_MEM_ERROR: constants.Z_MEM_ERROR,\n  Z_BUF_ERROR: constants.Z_BUF_ERROR,\n  Z_VERSION_ERROR: constants.Z_VERSION_ERROR\n};\n\nconst ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nfunction isInvalidFlushFlag(flag) {\n  return typeof flag !== 'number' ||\n         flag < constants.Z_NO_FLUSH ||\n         flag > constants.Z_BLOCK;\n\n  // Covers: constants.Z_NO_FLUSH (0),\n  //         constants.Z_PARTIAL_FLUSH (1),\n  //         constants.Z_SYNC_FLUSH (2),\n  //         constants.Z_FULL_FLUSH (3),\n  //         constants.Z_FINISH (4), and\n  //         constants.Z_BLOCK (5)\n}\n\nfunction isInvalidStrategy(strategy) {\n  return typeof strategy !== 'number' ||\n         strategy < constants.Z_DEFAULT_STRATEGY ||\n         strategy > constants.Z_FIXED;\n\n  // Covers: constants.Z_FILTERED, (1)\n  //         constants.Z_HUFFMAN_ONLY (2),\n  //         constants.Z_RLE (3),\n  //         constants.Z_FIXED (4), and\n  //         constants.Z_DEFAULT_STRATEGY (0)\n}\n\nfunction zlibBuffer(engine, buffer, callback) {\n  // Streams do not support non-Buffer ArrayBufferViews yet. Convert it to a\n  // Buffer without copying.\n  if (ArrayBuffer.isView(buffer) &&\n      Object.getPrototypeOf(buffer) !== Buffer.prototype) {\n    buffer = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  }\n\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.byteLength;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string')\n    buffer = Buffer.from(buffer);\n  else if (!ArrayBuffer.isView(buffer))\n    throw new TypeError('\"buffer\" argument must be a string, Buffer, ' +\n                        'TypedArray, or DataView');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction zlibOnError(message, errno) {\n  // there is no way to cleanly recover.\n  // continuing only obscures problems.\n  _close(this);\n  this._hadError = true;\n\n  var error = new Error(message);\n  error.errno = errno;\n  error.code = codes[errno];\n  this.emit('error', error);\n}\n\nfunction flushCallback(level, strategy, callback) {\n  assert(this._handle, 'zlib binding closed');\n  this._handle.params(level, strategy);\n  if (!this._hadError) {\n    this._level = level;\n    this._strategy = strategy;\n    if (callback) callback();\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nclass Zlib extends Transform {\n  constructor(opts, mode) {\n    opts = opts || {};\n    super(opts);\n\n    this._opts = opts;\n    this._chunkSize = opts.chunkSize || constants.Z_DEFAULT_CHUNK;\n\n    if (opts.flush && isInvalidFlushFlag(opts.flush)) {\n      throw new RangeError('Invalid flush flag: ' + opts.flush);\n    }\n    if (opts.finishFlush && isInvalidFlushFlag(opts.finishFlush)) {\n      throw new RangeError('Invalid flush flag: ' + opts.finishFlush);\n    }\n\n    this._flushFlag = opts.flush || constants.Z_NO_FLUSH;\n    this._finishFlushFlag = opts.finishFlush !== undefined ?\n      opts.finishFlush : constants.Z_FINISH;\n\n    if (opts.chunkSize !== undefined) {\n      if (opts.chunkSize < constants.Z_MIN_CHUNK) {\n        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);\n      }\n    }\n\n    if (opts.windowBits !== undefined) {\n      if (opts.windowBits < constants.Z_MIN_WINDOWBITS ||\n          opts.windowBits > constants.Z_MAX_WINDOWBITS) {\n        throw new RangeError('Invalid windowBits: ' + opts.windowBits);\n      }\n    }\n\n    if (opts.level !== undefined) {\n      if (opts.level < constants.Z_MIN_LEVEL ||\n          opts.level > constants.Z_MAX_LEVEL) {\n        throw new RangeError('Invalid compression level: ' + opts.level);\n      }\n    }\n\n    if (opts.memLevel !== undefined) {\n      if (opts.memLevel < constants.Z_MIN_MEMLEVEL ||\n          opts.memLevel > constants.Z_MAX_MEMLEVEL) {\n        throw new RangeError('Invalid memLevel: ' + opts.memLevel);\n      }\n    }\n\n    if (opts.strategy !== undefined && isInvalidStrategy(opts.strategy))\n      throw new TypeError('Invalid strategy: ' + opts.strategy);\n\n    if (opts.dictionary !== undefined) {\n      if (!ArrayBuffer.isView(opts.dictionary)) {\n        throw new TypeError(\n          'Invalid dictionary: it should be a Buffer, TypedArray, or DataView');\n      }\n    }\n\n    this._handle = new binding.Zlib(mode);\n    this._handle.onerror = zlibOnError.bind(this);\n    this._hadError = false;\n\n    var level = constants.Z_DEFAULT_COMPRESSION;\n    if (Number.isFinite(opts.level)) {\n      level = opts.level;\n    }\n\n    var strategy = constants.Z_DEFAULT_STRATEGY;\n    if (Number.isFinite(opts.strategy)) {\n      strategy = opts.strategy;\n    }\n\n    var windowBits = constants.Z_DEFAULT_WINDOWBITS;\n    if (Number.isFinite(opts.windowBits)) {\n      windowBits = opts.windowBits;\n    }\n\n    var memLevel = constants.Z_DEFAULT_MEMLEVEL;\n    if (Number.isFinite(opts.memLevel)) {\n      memLevel = opts.memLevel;\n    }\n\n    this._handle.init(windowBits,\n                      level,\n                      memLevel,\n                      strategy,\n                      opts.dictionary);\n\n    this._buffer = Buffer.allocUnsafe(this._chunkSize);\n    this._offset = 0;\n    this._level = level;\n    this._strategy = strategy;\n\n    this.once('end', this.close);\n  }\n\n  get _closed() {\n    return !this._handle;\n  }\n\n  params(level, strategy, callback) {\n    if (level < constants.Z_MIN_LEVEL ||\n        level > constants.Z_MAX_LEVEL) {\n      throw new RangeError('Invalid compression level: ' + level);\n    }\n    if (isInvalidStrategy(strategy))\n      throw new TypeError('Invalid strategy: ' + strategy);\n\n    if (this._level !== level || this._strategy !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH,\n                 flushCallback.bind(this, level, strategy, callback));\n    } else {\n      process.nextTick(callback);\n    }\n  }\n\n  reset() {\n    assert(this._handle, 'zlib binding closed');\n    return this._handle.reset();\n  }\n\n  // This is the _flush function called by the transform class,\n  // internally, when the last chunk has been written.\n  _flush(callback) {\n    this._transform(Buffer.alloc(0), '', callback);\n  }\n\n  flush(kind, callback) {\n    var ws = this._writableState;\n\n    if (typeof kind === 'function' || (kind === undefined && !callback)) {\n      callback = kind;\n      kind = constants.Z_FULL_FLUSH;\n    }\n\n    if (ws.ended) {\n      if (callback)\n        process.nextTick(callback);\n    } else if (ws.ending) {\n      if (callback)\n        this.once('end', callback);\n    } else if (ws.needDrain) {\n      if (callback) {\n        const drainHandler = () => this.flush(kind, callback);\n        this.once('drain', drainHandler);\n      }\n    } else {\n      this._flushFlag = kind;\n      this.write(Buffer.alloc(0), '', callback);\n    }\n  }\n\n  close(callback) {\n    _close(this, callback);\n    process.nextTick(emitCloseNT, this);\n  }\n\n  _transform(chunk, encoding, cb) {\n    var flushFlag;\n    var ws = this._writableState;\n    var ending = ws.ending || ws.ended;\n    var last = ending && (!chunk || ws.length === chunk.byteLength);\n\n    if (chunk !== null && !ArrayBuffer.isView(chunk))\n      return cb(new TypeError('invalid input'));\n\n    if (!this._handle)\n      return cb(new Error('zlib binding closed'));\n\n    // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n    // (or whatever flag was provided using opts.finishFlush).\n    // If it's explicitly flushing at some other time, then we use\n    // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n    // goodness.\n    if (last)\n      flushFlag = this._finishFlushFlag;\n    else {\n      flushFlag = this._flushFlag;\n      // once we've flushed the last of the queue, stop flushing and\n      // go back to the normal behavior.\n      if (chunk.byteLength >= ws.length) {\n        this._flushFlag = this._opts.flush || constants.Z_NO_FLUSH;\n      }\n    }\n\n    this._processChunk(chunk, flushFlag, cb);\n  }\n\n  _processChunk(chunk, flushFlag, cb) {\n    var availInBefore = chunk && chunk.byteLength;\n    var availOutBefore = this._chunkSize - this._offset;\n    var inOff = 0;\n\n    var self = this;\n\n    var async = typeof cb === 'function';\n\n    if (!async) {\n      var buffers = [];\n      var nread = 0;\n\n      var error;\n      this.on('error', function(er) {\n        error = er;\n      });\n\n      assert(this._handle, 'zlib binding closed');\n      do {\n        var res = this._handle.writeSync(flushFlag,\n                                         chunk, // in\n                                         inOff, // in_off\n                                         availInBefore, // in_len\n                                         this._buffer, // out\n                                         this._offset, //out_off\n                                         availOutBefore); // out_len\n      } while (!this._hadError && callback(res[0], res[1]));\n\n      if (this._hadError) {\n        throw error;\n      }\n\n      if (nread >= kMaxLength) {\n        _close(this);\n        throw new RangeError(kRangeErrorMessage);\n      }\n\n      var buf = Buffer.concat(buffers, nread);\n      _close(this);\n\n      return buf;\n    }\n\n    assert(this._handle, 'zlib binding closed');\n    var req = this._handle.write(flushFlag,\n                                 chunk, // in\n                                 inOff, // in_off\n                                 availInBefore, // in_len\n                                 this._buffer, // out\n                                 this._offset, //out_off\n                                 availOutBefore); // out_len\n\n    req.buffer = chunk;\n    req.callback = callback;\n\n    function callback(availInAfter, availOutAfter) {\n      // When the callback is used in an async write, the callback's\n      // context is the `req` object that was created. The req object\n      // is === this._handle, and that's why it's important to null\n      // out the values after they are done being used. `this._handle`\n      // can stay in memory longer than the callback and buffer are needed.\n      if (this) {\n        this.buffer = null;\n        this.callback = null;\n      }\n\n      if (self._hadError)\n        return;\n\n      var have = availOutBefore - availOutAfter;\n      assert(have >= 0, 'have should not go down');\n\n      if (have > 0) {\n        var out = self._buffer.slice(self._offset, self._offset + have);\n        self._offset += have;\n        // serve some output to the consumer.\n        if (async) {\n          self.push(out);\n        } else {\n          buffers.push(out);\n          nread += out.byteLength;\n        }\n      }\n\n      // exhausted the output buffer, or used all the input create a new one.\n      if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n        availOutBefore = self._chunkSize;\n        self._offset = 0;\n        self._buffer = Buffer.allocUnsafe(self._chunkSize);\n      }\n\n      if (availOutAfter === 0) {\n        // Not actually done.  Need to reprocess.\n        // Also, update the availInBefore to the availInAfter value,\n        // so that if we have to hit it a third (fourth, etc.) time,\n        // it'll have the correct byte counts.\n        inOff += (availInBefore - availInAfter);\n        availInBefore = availInAfter;\n\n        if (!async)\n          return true;\n\n        var newReq = self._handle.write(flushFlag,\n                                        chunk,\n                                        inOff,\n                                        availInBefore,\n                                        self._buffer,\n                                        self._offset,\n                                        self._chunkSize);\n        newReq.callback = callback; // this same function\n        newReq.buffer = chunk;\n        return;\n      }\n\n      if (!async)\n        return false;\n\n      // finished with the chunk.\n      cb();\n    }\n  }\n}\n\nfunction _close(engine, callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle)\n    return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\n// generic zlib\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor(opts) {\n    super(opts, constants.DEFLATE);\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor(opts) {\n    super(opts, constants.INFLATE);\n  }\n}\n\nclass Gzip extends Zlib {\n  constructor(opts) {\n    super(opts, constants.GZIP);\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor(opts) {\n    super(opts, constants.GUNZIP);\n  }\n}\n\nclass DeflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, constants.DEFLATERAW);\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor(opts) {\n    super(opts, constants.INFLATERAW);\n  }\n}\n\nclass Unzip extends Zlib {\n  constructor(opts) {\n    super(opts, constants.UNZIP);\n  }\n}\n\nfunction createConvenienceMethod(type, sync) {\n  if (sync) {\n    return function(buffer, opts) {\n      return zlibBufferSync(new type(opts), buffer);\n    };\n  } else {\n    return function(buffer, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      return zlibBuffer(new type(opts), buffer, callback);\n    };\n  }\n}\n\nfunction createProperty(type) {\n  return {\n    configurable: true,\n    enumerable: true,\n    value: type\n  };\n}\n\nmodule.exports = {\n  Deflate: createClassWrapper(Deflate),\n  Inflate: createClassWrapper(Inflate),\n  Gzip: createClassWrapper(Gzip),\n  Gunzip: createClassWrapper(Gunzip),\n  DeflateRaw: createClassWrapper(DeflateRaw),\n  InflateRaw: createClassWrapper(InflateRaw),\n  Unzip: createClassWrapper(Unzip),\n\n  // Convenience methods.\n  // compress/decompress a string or buffer in one step.\n  deflate: createConvenienceMethod(Deflate, false),\n  deflateSync: createConvenienceMethod(Deflate, true),\n  gzip: createConvenienceMethod(Gzip, false),\n  gzipSync: createConvenienceMethod(Gzip, true),\n  deflateRaw: createConvenienceMethod(DeflateRaw, false),\n  deflateRawSync: createConvenienceMethod(DeflateRaw, true),\n  unzip: createConvenienceMethod(Unzip, false),\n  unzipSync: createConvenienceMethod(Unzip, true),\n  inflate: createConvenienceMethod(Inflate, false),\n  inflateSync: createConvenienceMethod(Inflate, true),\n  gunzip: createConvenienceMethod(Gunzip, false),\n  gunzipSync: createConvenienceMethod(Gunzip, true),\n  inflateRaw: createConvenienceMethod(InflateRaw, false),\n  inflateRawSync: createConvenienceMethod(InflateRaw, true)\n};\n\nObject.defineProperties(module.exports, {\n  createDeflate: createProperty(module.exports.Deflate),\n  createInflate: createProperty(module.exports.Inflate),\n  createDeflateRaw: createProperty(module.exports.DeflateRaw),\n  createInflateRaw: createProperty(module.exports.InflateRaw),\n  createGzip: createProperty(module.exports.Gzip),\n  createGunzip: createProperty(module.exports.Gunzip),\n  createUnzip: createProperty(module.exports.Unzip),\n  constants: {\n    configurable: false,\n    enumerable: true,\n    value: constants\n  },\n  codes: {\n    enumerable: true,\n    writable: false,\n    value: Object.freeze(codes)\n  }\n});\n\n// These should be considered deprecated\n// expose all the zlib constants\nconst bkeys = Object.keys(constants);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  Object.defineProperty(module.exports, bkey, {\n    enumerable: true, value: constants[bkey], writable: false\n  });\n}\n",
  "internal/buffer": "'use strict';\n\nif (!process.binding('config').hasIntl) {\n  return;\n}\n\nconst normalizeEncoding = require('internal/util').normalizeEncoding;\nconst Buffer = require('buffer').Buffer;\n\nconst icu = process.binding('icu');\nconst { isUint8Array } = process.binding('util');\n\n// Transcodes the Buffer from one encoding to another, returning a new\n// Buffer instance.\nfunction transcode(source, fromEncoding, toEncoding) {\n  if (!isUint8Array(source))\n    throw new TypeError('\"source\" argument must be a Buffer or Uint8Array');\n  if (source.length === 0) return Buffer.alloc(0);\n\n  fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n  toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n  const result = icu.transcode(source, fromEncoding, toEncoding);\n  if (typeof result !== 'number')\n    return result;\n\n  const code = icu.icuErrName(result);\n  const err = new Error(`Unable to transcode Buffer [${code}]`);\n  err.code = code;\n  err.errno = result;\n  throw err;\n}\n\nmodule.exports = {\n  transcode\n};\n",
  "internal/child_process": "'use strict';\n\nconst errors = require('internal/errors');\nconst StringDecoder = require('string_decoder').StringDecoder;\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst util = require('util');\nconst assert = require('assert');\n\nconst Process = process.binding('process_wrap').Process;\nconst WriteWrap = process.binding('stream_wrap').WriteWrap;\nconst uv = process.binding('uv');\nconst Pipe = process.binding('pipe_wrap').Pipe;\nconst TTY = process.binding('tty_wrap').TTY;\nconst TCP = process.binding('tcp_wrap').TCP;\nconst UDP = process.binding('udp_wrap').UDP;\nconst SocketList = require('internal/socket_list');\nconst { isUint8Array } = process.binding('util');\nconst { convertToValidSignal } = require('internal/util');\n\nconst errnoException = util._errnoException;\nconst SocketListSend = SocketList.SocketListSend;\nconst SocketListReceive = SocketList.SocketListReceive;\n\n// this object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true,\n\n    send: function(message, handle, options) {\n      return handle;\n    },\n\n    got: function(message, handle, emit) {\n      emit(handle);\n    }\n  },\n\n  'net.Server': {\n    simultaneousAccepts: true,\n\n    send: function(message, server, options) {\n      return server._handle;\n    },\n\n    got: function(message, handle, emit) {\n      var server = new net.Server();\n      server.listen(handle, function() {\n        emit(server);\n      });\n    }\n  },\n\n  'net.Socket': {\n    send: function(message, socket, options) {\n      if (!socket._handle)\n        return;\n\n      // if the socket was created by net.Server\n      if (socket.server) {\n        // the slave should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        var firstTime = !this.channel.sockets.send[message.key];\n        var socketList = getSocketList('send', this, message.key);\n\n        // the server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the slaves\n        if (firstTime) socket.server._setupSlave(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      var handle = socket._handle;\n\n      // remove handle from socket object, it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n      }\n\n      return handle;\n    },\n\n    postSend: function(handle, options, target) {\n      // Store the handle after successfully sending it, so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent,\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingHandle as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingHandle);\n          target._pendingHandle = handle;\n        } else {\n          handle.close();\n        }\n      }\n    },\n\n    got: function(message, handle, emit) {\n      var socket = new net.Socket({handle: handle});\n      socket.readable = socket.writable = true;\n\n      // if the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // add socket to connections list\n        var socketList = getSocketList('got', this, message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  },\n\n  'dgram.Native': {\n    simultaneousAccepts: false,\n\n    send: function(message, handle, options) {\n      return handle;\n    },\n\n    got: function(message, handle, emit) {\n      emit(handle);\n    }\n  },\n\n  'dgram.Socket': {\n    simultaneousAccepts: false,\n\n    send: function(message, socket, options) {\n      message.dgramType = socket.type;\n\n      return socket._handle;\n    },\n\n    got: function(message, handle, emit) {\n      var socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle, function() {\n        emit(socket);\n      });\n    }\n  }\n};\n\n\nfunction ChildProcess() {\n  EventEmitter.call(this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle.owner = this;\n\n  this._handle.onexit = (exitCode, signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      var syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode, syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = this.spawnargs.slice(1);\n      this.emit('error', err);\n    } else {\n      this.emit('exit', this.exitCode, this.signalCode);\n    }\n\n    // if any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio, this);\n\n    maybeClose(this);\n  };\n}\nutil.inherits(ChildProcess, EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (var i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (!stream || !stream.readable || stream._readableState.readableListening)\n      continue;\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe, readable) {\n  var s = new net.Socket({ handle: pipe });\n\n  if (readable) {\n    s.writable = false;\n    s.readable = true;\n  } else {\n    s.writable = true;\n    s.readable = false;\n  }\n\n  return s;\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  var ipc;\n  var ipcFd;\n  var i;\n\n  if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" must be an object');\n\n  // If no `stdio` option was given - use default\n  var stdio = options.stdio || 'pipe';\n\n  stdio = _validateStdio(stdio, false);\n\n  ipc = stdio.ipc;\n  ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else if (!Array.isArray(options.envPairs))\n      throw new TypeError('\"envPairs\" must be an array');\n\n    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);\n  }\n\n  if (typeof options.file === 'string')\n    this.spawnfile = options.file;\n  else\n    throw new TypeError('\"file\" must be a string');\n\n  if (Array.isArray(options.args))\n    this.spawnargs = options.args;\n  else if (options.args === undefined)\n    this.spawnargs = [];\n  else\n    throw new TypeError('\"args\" must be an array');\n\n  var err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error, not throw an exception.\n  if (err === uv.UV_EAGAIN ||\n      err === uv.UV_EMFILE ||\n      err === uv.UV_ENFILE ||\n      err === uv.UV_ENOENT) {\n    process.nextTick(onErrorNT, this, err);\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    // It's kind of silly that the de facto spec for ENOENT (the test suite)\n    // mandates that stdio _is_ set up, even if there is no process on the\n    // receiving end, but it is what it is.\n    if (err !== uv.UV_ENOENT) return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err, 'spawn');\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    if (stream.handle) {\n      // when i === 0 - we're dealing with stdin\n      // (which is the only one writable pipe)\n      stream.socket = createSocket(this.pid !== 0 ?\n          stream.handle : null, i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close', () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n      stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n      stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n      stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    this.stdio.push(stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this, ipc);\n\n  return err;\n};\n\n\nfunction onErrorNT(self, err) {\n  self._handle.onexit(err);\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    var err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === uv.UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err, 'kill');\n    } else {\n      /* Other error, almost certainly EPERM. */\n      this.emit('error', errnoException(err, 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  constructor(channel) {\n    super();\n    this.channel = channel;\n    this.refs = 0;\n  }\n  ref() {\n    if (++this.refs === 1) {\n      this.channel.ref();\n    }\n  }\n  unref() {\n    if (--this.refs === 0) {\n      this.channel.unref();\n      this.emit('unref');\n    }\n  }\n}\n\nfunction setupChannel(target, channel) {\n  target.channel = channel;\n\n  // _channel can be deprecated in version 8\n  Object.defineProperty(target, '_channel', {\n    get() { return target.channel; },\n    set(val) { target.channel = val; },\n    enumerable: true\n  });\n\n  target._handleQueue = null;\n  target._pendingHandle = null;\n\n  const control = new Control(channel);\n\n  var decoder = new StringDecoder('utf8');\n  var jsonBuffer = '';\n  channel.buffering = false;\n  channel.onread = function(nread, pool, recvHandle) {\n    // TODO(bnoordhuis) Check that nread > 0.\n    if (pool) {\n      // Linebreak is used as a message end sign\n      var chunks = decoder.write(pool).split('\\n');\n      var numCompleteChunks = chunks.length - 1;\n      // Last line does not have trailing linebreak\n      var incompleteChunk = chunks[numCompleteChunks];\n      if (numCompleteChunks === 0) {\n        jsonBuffer += incompleteChunk;\n        this.buffering = jsonBuffer.length !== 0;\n        return;\n      }\n      chunks[0] = jsonBuffer + chunks[0];\n\n      for (var i = 0; i < numCompleteChunks; i++) {\n        var message = JSON.parse(chunks[i]);\n\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (message && message.cmd === 'NODE_HANDLE')\n          handleMessage(target, message, recvHandle);\n        else\n          handleMessage(target, message, undefined);\n      }\n      jsonBuffer = incompleteChunk;\n      this.buffering = jsonBuffer.length !== 0;\n\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // object where socket lists will live\n  channel.sockets = { got: {}, send: {} };\n\n  // handlers will go through this\n  target.on('internalMessage', function(message, handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK') {\n      if (target._pendingHandle) {\n        target._pendingHandle.close();\n        target._pendingHandle = null;\n      }\n\n      assert(Array.isArray(target._handleQueue));\n      var queue = target._handleQueue;\n      target._handleQueue = null;\n\n      for (var i = 0; i < queue.length; i++) {\n        var args = queue[i];\n        target._send(args.message, args.handle, args.options, args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);\n\n    var obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle._simultaneousAccepts = false;\n      net._setSimultaneousAccepts(handle);\n    }\n\n    // Convert handle object\n    obj.got.call(this, message, handle, function(handle) {\n      handleMessage(target, message.msg, handle);\n    });\n  });\n\n  target.send = function(message, handle, options, callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined &&\n               (options === null || typeof options !== 'object')) {\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'Object');\n    }\n\n    options = Object.assign({swallowErrors: false}, options);\n\n    if (this.connected) {\n      return this._send(message, handle, options, callback);\n    }\n    const ex = new errors.Error('ERR_IPC_CHANNEL_CLOSED');\n    if (typeof callback === 'function') {\n      process.nextTick(callback, ex);\n    } else {\n      this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\n    }\n    return false;\n  };\n\n  target._send = function(message, handle, options, callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'message');\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = {swallowErrors: options};\n    }\n\n    // package messages with a handle object\n    if (handle) {\n      // this message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE',\n        type: null,\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new errors.TypeError('ERR_INVALID_HANDLE_TYPE');\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        this._handleQueue.push({\n          callback: callback,\n          handle: handle,\n          options: options,\n          message: message.msg,\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      var obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = handleConversion[message.type].send.call(target,\n                                                        message,\n                                                        handle,\n                                                        options);\n\n      // If handle was sent twice, or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts) {\n        net._setSimultaneousAccepts(handle);\n      }\n    } else if (this._handleQueue &&\n               !(message && message.cmd === 'NODE_HANDLE_ACK')) {\n      // Queue request anyway to avoid out-of-order messages.\n      this._handleQueue.push({\n        callback: callback,\n        handle: null,\n        options: options,\n        message: message,\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    var req = new WriteWrap();\n    req.async = false;\n\n    var string = JSON.stringify(message) + '\\n';\n    var err = channel.writeUtf8String(req, string, handle);\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(handle, options, target);\n      }\n\n      req.oncomplete = function() {\n        if (this.async === true)\n          control.unref();\n        if (typeof callback === 'function')\n          callback(null);\n      };\n      if (req.async === true) {\n        control.ref();\n      } else {\n        process.nextTick(function() { req.oncomplete(); });\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(handle, options);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err, 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback, ex);\n        } else {\n          this.emit('error', ex);  // FIXME(bnoordhuis) Defer to next tick.\n        }\n      }\n    }\n\n    /* If the master is > 2 read() calls behind, please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // connected will be set to false immediately when a disconnect() is\n  // requested, even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested, messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested, channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error', new errors.Error('ERR_IPC_DISCONNECTED'));\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages, disconnect immediately. Otherwise,\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n\n    if (this._pendingHandle) {\n      this._pendingHandle.close();\n      this._pendingHandle = null;\n    }\n\n    var fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read, then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message', finish);\n      this.once('internalMessage', finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  channel.readStart();\n  return control;\n}\n\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction handleMessage(target, message, handle) {\n  if (!target.channel)\n    return;\n\n  var eventName = 'message';\n  if (message !== null &&\n      typeof message === 'object' &&\n      typeof message.cmd === 'string' &&\n      message.cmd.length > INTERNAL_PREFIX.length &&\n      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {\n    eventName = 'internalMessage';\n  }\n  process.nextTick(() => {\n    target.emit(eventName, message, handle);\n  });\n}\n\nfunction nop() { }\n\nfunction _validateStdio(stdio, sync) {\n  var ipc;\n  var ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    switch (stdio) {\n      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;\n      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;\n      case 'inherit': stdio = [0, 1, 2]; break;\n      default:\n        throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'stdio', stdio);\n    }\n  } else if (!Array.isArray(stdio)) {\n    throw new errors.TypeError('ERR_INVALID_OPT_VALUE',\n                               'stdio', util.inspect(stdio));\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse, and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See http://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) stdio.push(undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = stdio.reduce(function(acc, stdio, i) {\n    function cleanup() {\n      for (var i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      acc.push({type: 'ignore'});\n    } else if (stdio === 'pipe' || typeof stdio === 'number' && stdio < 0) {\n      var a = {\n        type: 'pipe',\n        readable: i === 0,\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = new Pipe();\n\n      acc.push(a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new errors.Error('ERR_IPC_ONE_PIPE');\n        else\n          throw new errors.Error('ERR_IPC_SYNC_FORK');\n      }\n\n      ipc = new Pipe(true);\n      ipcFd = i;\n\n      acc.push({\n        type: 'pipe',\n        handle: ipc,\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      acc.push({\n        type: 'inherit',\n        fd: i\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      acc.push({\n        type: 'fd',\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      var handle = getHandleWrapType(stdio) ?\n          stdio :\n          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      acc.push({\n        type: 'wrap',\n        wrapType: getHandleWrapType(handle),\n        handle: handle\n      });\n    } else if (isUint8Array(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new errors.TypeError('ERR_INVALID_SYNC_FORK_INPUT',\n                                   util.inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'stdio',\n                                 util.inspect(stdio));\n    }\n\n    return acc;\n  }, []);\n\n  return { stdio, ipc, ipcFd };\n}\n\n\nfunction getSocketList(type, slave, key) {\n  var sockets = slave.channel.sockets[type];\n  var socketList = sockets[key];\n  if (!socketList) {\n    var Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(slave, key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);\n  }\n}\n\nmodule.exports = {\n  ChildProcess,\n  setupChannel,\n  _validateStdio,\n  getSocketList\n};\n",
  "internal/cluster/child": "'use strict';\nconst assert = require('assert');\nconst util = require('util');\nconst EventEmitter = require('events');\nconst Worker = require('internal/cluster/worker');\nconst { internal, sendHelper } = require('internal/cluster/utils');\nconst cluster = new EventEmitter();\nconst handles = {};\nconst indexes = {};\nconst noop = () => {};\n\nmodule.exports = cluster;\n\ncluster.isWorker = true;\ncluster.isMaster = false;\ncluster.worker = null;\ncluster.Worker = Worker;\n\ncluster._setupWorker = function() {\n  const worker = new Worker({\n    id: +process.env.NODE_UNIQUE_ID | 0,\n    process: process,\n    state: 'online'\n  });\n\n  cluster.worker = worker;\n\n  process.once('disconnect', () => {\n    worker.emit('disconnect');\n\n    if (!worker.exitedAfterDisconnect) {\n      // Unexpected disconnect, master exited, or some such nastiness, so\n      // worker exits immediately.\n      process.exit(0);\n    }\n  });\n\n  process.on('internalMessage', internal(worker, onmessage));\n  send({ act: 'online' });\n\n  function onmessage(message, handle) {\n    if (message.act === 'newconn')\n      onconnection(message, handle);\n    else if (message.act === 'disconnect')\n      _disconnect.call(worker, true);\n  }\n};\n\n// obj is a net#Server or a dgram#Socket object.\ncluster._getServer = function(obj, options, cb) {\n  const indexesKey = [options.address,\n                      options.port,\n                      options.addressType,\n                      options.fd ].join(':');\n\n  if (indexes[indexesKey] === undefined)\n    indexes[indexesKey] = 0;\n  else\n    indexes[indexesKey]++;\n\n  const message = util._extend({\n    act: 'queryServer',\n    index: indexes[indexesKey],\n    data: null\n  }, options);\n\n  // Set custom data on handle (i.e. tls tickets key)\n  if (obj._getServerData)\n    message.data = obj._getServerData();\n\n  send(message, (reply, handle) => {\n    if (typeof obj._setServerData === 'function')\n      obj._setServerData(reply.data);\n\n    if (handle)\n      shared(reply, handle, indexesKey, cb);  // Shared listen socket.\n    else\n      rr(reply, indexesKey, cb);              // Round-robin.\n  });\n\n  obj.once('listening', () => {\n    cluster.worker.state = 'listening';\n    const address = obj.address();\n    message.act = 'listening';\n    message.port = address && address.port || options.port;\n    send(message);\n  });\n};\n\n// Shared listen socket.\nfunction shared(message, handle, indexesKey, cb) {\n  const key = message.key;\n  // Monkey-patch the close() method so we can keep track of when it's\n  // closed. Avoids resource leaks when the handle is short-lived.\n  const close = handle.close;\n\n  handle.close = function() {\n    send({ act: 'close', key });\n    delete handles[key];\n    delete indexes[indexesKey];\n    return close.apply(this, arguments);\n  }.bind(handle);\n  assert(handles[key] === undefined);\n  handles[key] = handle;\n  cb(message.errno, handle);\n}\n\n// Round-robin. Master distributes handles across workers.\nfunction rr(message, indexesKey, cb) {\n  if (message.errno)\n    return cb(message.errno, null);\n\n  var key = message.key;\n\n  function listen(backlog) {\n    // TODO(bnoordhuis) Send a message to the master that tells it to\n    // update the backlog size. The actual backlog should probably be\n    // the largest requested size by any worker.\n    return 0;\n  }\n\n  function close() {\n    // lib/net.js treats server._handle.close() as effectively synchronous.\n    // That means there is a time window between the call to close() and\n    // the ack by the master process in which we can still receive handles.\n    // onconnection() below handles that by sending those handles back to\n    // the master.\n    if (key === undefined)\n      return;\n\n    send({ act: 'close', key });\n    delete handles[key];\n    delete indexes[indexesKey];\n    key = undefined;\n  }\n\n  function getsockname(out) {\n    if (key)\n      util._extend(out, message.sockname);\n\n    return 0;\n  }\n\n  // Faux handle. Mimics a TCPWrap with just enough fidelity to get away\n  // with it. Fools net.Server into thinking that it's backed by a real\n  // handle. Use a noop function for ref() and unref() because the control\n  // channel is going to keep the worker alive anyway.\n  const handle = { close, listen, ref: noop, unref: noop };\n\n  if (message.sockname) {\n    handle.getsockname = getsockname;  // TCP handles only.\n  }\n\n  assert(handles[key] === undefined);\n  handles[key] = handle;\n  cb(0, handle);\n}\n\n// Round-robin connection.\nfunction onconnection(message, handle) {\n  const key = message.key;\n  const server = handles[key];\n  const accepted = server !== undefined;\n\n  send({ ack: message.seq, accepted });\n\n  if (accepted)\n    server.onconnection(0, handle);\n}\n\nfunction send(message, cb) {\n  return sendHelper(process, message, null, cb);\n}\n\nfunction _disconnect(masterInitiated) {\n  this.exitedAfterDisconnect = true;\n  let waitingCount = 1;\n\n  function checkWaitingCount() {\n    waitingCount--;\n\n    if (waitingCount === 0) {\n      // If disconnect is worker initiated, wait for ack to be sure\n      // exitedAfterDisconnect is properly set in the master, otherwise, if\n      // it's master initiated there's no need to send the\n      // exitedAfterDisconnect message\n      if (masterInitiated) {\n        process.disconnect();\n      } else {\n        send({ act: 'exitedAfterDisconnect' }, () => process.disconnect());\n      }\n    }\n  }\n\n  for (var key in handles) {\n    const handle = handles[key];\n    delete handles[key];\n    waitingCount++;\n\n    if (handle.owner)\n      handle.owner.close(checkWaitingCount);\n    else\n      handle.close(checkWaitingCount);\n  }\n\n  checkWaitingCount();\n}\n\n// Extend generic Worker with methods specific to worker processes.\nWorker.prototype.disconnect = function() {\n  _disconnect.call(this);\n  return this;\n};\n\nWorker.prototype.destroy = function() {\n  this.exitedAfterDisconnect = true;\n\n  if (!this.isConnected()) {\n    process.exit(0);\n  } else {\n    send({ act: 'exitedAfterDisconnect' }, () => process.disconnect());\n    process.once('disconnect', () => process.exit(0));\n  }\n};\n",
  "internal/cluster/master": "'use strict';\nconst assert = require('assert');\nconst fork = require('child_process').fork;\nconst util = require('util');\nconst EventEmitter = require('events');\nconst RoundRobinHandle = require('internal/cluster/round_robin_handle');\nconst SharedHandle = require('internal/cluster/shared_handle');\nconst Worker = require('internal/cluster/worker');\nconst { internal, sendHelper, handles } = require('internal/cluster/utils');\nconst keys = Object.keys;\nconst cluster = new EventEmitter();\nconst intercom = new EventEmitter();\nconst SCHED_NONE = 1;\nconst SCHED_RR = 2;\n\nmodule.exports = cluster;\n\ncluster.isWorker = false;\ncluster.isMaster = true;\ncluster.Worker = Worker;\ncluster.workers = {};\ncluster.settings = {};\ncluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\ncluster.SCHED_RR = SCHED_RR;      // Master distributes connections.\n\nvar ids = 0;\nvar debugPortOffset = 1;\nvar initialized = false;\n\n// XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\nvar schedulingPolicy = {\n  'none': SCHED_NONE,\n  'rr': SCHED_RR\n}[process.env.NODE_CLUSTER_SCHED_POLICY];\n\nif (schedulingPolicy === undefined) {\n  // FIXME Round-robin doesn't perform well on Windows right now due to the\n  // way IOCP is wired up.\n  schedulingPolicy = (process.platform === 'win32') ? SCHED_NONE : SCHED_RR;\n}\n\ncluster.schedulingPolicy = schedulingPolicy;\n\ncluster.setupMaster = function(options) {\n  var settings = {\n    args: process.argv.slice(2),\n    exec: process.argv[1],\n    execArgv: process.execArgv,\n    silent: false\n  };\n  util._extend(settings, cluster.settings);\n  util._extend(settings, options || {});\n\n  // Tell V8 to write profile data for each process to a separate file.\n  // Without --logfile=v8-%p.log, everything ends up in a single, unusable\n  // file. (Unusable because what V8 logs are memory addresses and each\n  // process has its own memory mappings.)\n  if (settings.execArgv.some((s) => s.startsWith('--prof')) &&\n      !settings.execArgv.some((s) => s.startsWith('--logfile='))) {\n    settings.execArgv = settings.execArgv.concat(['--logfile=v8-%p.log']);\n  }\n\n  cluster.settings = settings;\n\n  if (initialized === true)\n    return process.nextTick(setupSettingsNT, settings);\n\n  initialized = true;\n  schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR,\n         `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\n\n  process.nextTick(setupSettingsNT, settings);\n\n  process.on('internalMessage', (message) => {\n    if (message.cmd !== 'NODE_DEBUG_ENABLED')\n      return;\n\n    var key;\n    for (key in cluster.workers) {\n      const worker = cluster.workers[key];\n\n      if (worker.state === 'online' || worker.state === 'listening') {\n        process._debugProcess(worker.process.pid);\n      } else {\n        worker.once('online', function() {\n          process._debugProcess(this.process.pid);\n        });\n      }\n    }\n  });\n};\n\nfunction setupSettingsNT(settings) {\n  cluster.emit('setup', settings);\n}\n\nfunction createWorkerProcess(id, env) {\n  var workerEnv = util._extend({}, process.env);\n  var execArgv = cluster.settings.execArgv.slice();\n  var debugPort = 0;\n\n  util._extend(workerEnv, env);\n  workerEnv.NODE_UNIQUE_ID = '' + id;\n\n  for (var i = 0; i < execArgv.length; i++) {\n    const match = execArgv[i].match(\n      /^(--inspect|--inspect-(brk|port)|--debug|--debug-(brk|port))(=\\d+)?$/\n    );\n\n    if (match) {\n      if (debugPort === 0) {\n        debugPort = process.debugPort + debugPortOffset;\n        ++debugPortOffset;\n      }\n\n      execArgv[i] = match[1] + '=' + debugPort;\n    }\n  }\n\n  return fork(cluster.settings.exec, cluster.settings.args, {\n    env: workerEnv,\n    silent: cluster.settings.silent,\n    execArgv: execArgv,\n    stdio: cluster.settings.stdio,\n    gid: cluster.settings.gid,\n    uid: cluster.settings.uid\n  });\n}\n\nfunction removeWorker(worker) {\n  assert(worker);\n  delete cluster.workers[worker.id];\n\n  if (keys(cluster.workers).length === 0) {\n    assert(keys(handles).length === 0, 'Resource leak detected.');\n    intercom.emit('disconnect');\n  }\n}\n\nfunction removeHandlesForWorker(worker) {\n  assert(worker);\n\n  for (var key in handles) {\n    const handle = handles[key];\n\n    if (handle.remove(worker))\n      delete handles[key];\n  }\n}\n\ncluster.fork = function(env) {\n  cluster.setupMaster();\n  const id = ++ids;\n  const workerProcess = createWorkerProcess(id, env);\n  const worker = new Worker({\n    id: id,\n    process: workerProcess\n  });\n\n  worker.on('message', function(message, handle) {\n    cluster.emit('message', this, message, handle);\n  });\n\n  worker.process.once('exit', (exitCode, signalCode) => {\n    /*\n     * Remove the worker from the workers list only\n     * if it has disconnected, otherwise we might\n     * still want to access it.\n     */\n    if (!worker.isConnected()) {\n      removeHandlesForWorker(worker);\n      removeWorker(worker);\n    }\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'dead';\n    worker.emit('exit', exitCode, signalCode);\n    cluster.emit('exit', worker, exitCode, signalCode);\n  });\n\n  worker.process.once('disconnect', () => {\n    /*\n     * Now is a good time to remove the handles\n     * associated with this worker because it is\n     * not connected to the master anymore.\n     */\n    removeHandlesForWorker(worker);\n\n    /*\n     * Remove the worker from the workers list only\n     * if its process has exited. Otherwise, we might\n     * still want to access it.\n     */\n    if (worker.isDead())\n      removeWorker(worker);\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'disconnected';\n    worker.emit('disconnect');\n    cluster.emit('disconnect', worker);\n  });\n\n  worker.process.on('internalMessage', internal(worker, onmessage));\n  process.nextTick(emitForkNT, worker);\n  cluster.workers[worker.id] = worker;\n  return worker;\n};\n\nfunction emitForkNT(worker) {\n  cluster.emit('fork', worker);\n}\n\ncluster.disconnect = function(cb) {\n  const workers = keys(cluster.workers);\n\n  if (workers.length === 0) {\n    process.nextTick(() => intercom.emit('disconnect'));\n  } else {\n    for (var key in workers) {\n      key = workers[key];\n\n      if (cluster.workers[key].isConnected())\n        cluster.workers[key].disconnect();\n    }\n  }\n\n  if (typeof cb === 'function')\n    intercom.once('disconnect', cb);\n};\n\nfunction onmessage(message, handle) {\n  const worker = this;\n\n  if (message.act === 'online')\n    online(worker);\n  else if (message.act === 'queryServer')\n    queryServer(worker, message);\n  else if (message.act === 'listening')\n    listening(worker, message);\n  else if (message.act === 'exitedAfterDisconnect')\n    exitedAfterDisconnect(worker, message);\n  else if (message.act === 'close')\n    close(worker, message);\n}\n\nfunction online(worker) {\n  worker.state = 'online';\n  worker.emit('online');\n  cluster.emit('online', worker);\n}\n\nfunction exitedAfterDisconnect(worker, message) {\n  worker.exitedAfterDisconnect = true;\n  send(worker, { ack: message.seq });\n}\n\nfunction queryServer(worker, message) {\n  // Stop processing if worker already disconnecting\n  if (worker.exitedAfterDisconnect)\n    return;\n\n  const args = [message.address,\n                message.port,\n                message.addressType,\n                message.fd,\n                message.index];\n  const key = args.join(':');\n  var handle = handles[key];\n\n  if (handle === undefined) {\n    var constructor = RoundRobinHandle;\n    // UDP is exempt from round-robin connection balancing for what should\n    // be obvious reasons: it's connectionless. There is nothing to send to\n    // the workers except raw datagrams and that's pointless.\n    if (schedulingPolicy !== SCHED_RR ||\n        message.addressType === 'udp4' ||\n        message.addressType === 'udp6') {\n      constructor = SharedHandle;\n    }\n\n    handles[key] = handle = new constructor(key,\n                                            message.address,\n                                            message.port,\n                                            message.addressType,\n                                            message.fd,\n                                            message.flags);\n  }\n\n  if (!handle.data)\n    handle.data = message.data;\n\n  // Set custom server data\n  handle.add(worker, (errno, reply, handle) => {\n    reply = util._extend({\n      errno: errno,\n      key: key,\n      ack: message.seq,\n      data: handles[key].data\n    }, reply);\n\n    if (errno)\n      delete handles[key];  // Gives other workers a chance to retry.\n\n    send(worker, reply, handle);\n  });\n}\n\nfunction listening(worker, message) {\n  const info = {\n    addressType: message.addressType,\n    address: message.address,\n    port: message.port,\n    fd: message.fd\n  };\n\n  worker.state = 'listening';\n  worker.emit('listening', info);\n  cluster.emit('listening', worker, info);\n}\n\n// Server in worker is closing, remove from list. The handle may have been\n// removed by a prior call to removeHandlesForWorker() so guard against that.\nfunction close(worker, message) {\n  const key = message.key;\n  const handle = handles[key];\n\n  if (handle && handle.remove(worker))\n    delete handles[key];\n}\n\nfunction send(worker, message, handle, cb) {\n  return sendHelper(worker.process, message, handle, cb);\n}\n\n// Extend generic Worker with methods specific to the master process.\nWorker.prototype.disconnect = function() {\n  this.exitedAfterDisconnect = true;\n  send(this, { act: 'disconnect' });\n  removeHandlesForWorker(this);\n  removeWorker(this);\n  return this;\n};\n\nWorker.prototype.destroy = function(signo) {\n  const proc = this.process;\n\n  signo = signo || 'SIGTERM';\n\n  if (this.isConnected()) {\n    this.once('disconnect', () => proc.kill(signo));\n    this.disconnect();\n    return;\n  }\n\n  proc.kill(signo);\n};\n",
  "internal/cluster/round_robin_handle": "'use strict';\nconst assert = require('assert');\nconst net = require('net');\nconst { sendHelper } = require('internal/cluster/utils');\nconst getOwnPropertyNames = Object.getOwnPropertyNames;\nconst uv = process.binding('uv');\n\nmodule.exports = RoundRobinHandle;\n\nfunction RoundRobinHandle(key, address, port, addressType, fd) {\n  this.key = key;\n  this.all = {};\n  this.free = [];\n  this.handles = [];\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n\n  if (fd >= 0)\n    this.server.listen({ fd });\n  else if (port >= 0)\n    this.server.listen(port, address);\n  else\n    this.server.listen(address);  // UNIX socket path.\n\n  this.server.once('listening', () => {\n    this.handle = this.server._handle;\n    this.handle.onconnection = (err, handle) => this.distribute(err, handle);\n    this.server._handle = null;\n    this.server = null;\n  });\n}\n\nRoundRobinHandle.prototype.add = function(worker, send) {\n  assert(worker.id in this.all === false);\n  this.all[worker.id] = worker;\n\n  const done = () => {\n    if (this.handle.getsockname) {\n      const out = {};\n      this.handle.getsockname(out);\n      // TODO(bnoordhuis) Check err.\n      send(null, { sockname: out }, null);\n    } else {\n      send(null, null, null);  // UNIX socket.\n    }\n\n    this.handoff(worker);  // In case there are connections pending.\n  };\n\n  if (this.server === null)\n    return done();\n\n  // Still busy binding.\n  this.server.once('listening', done);\n  this.server.once('error', (err) => {\n    // Hack: translate 'EADDRINUSE' error string back to numeric error code.\n    // It works but ideally we'd have some backchannel between the net and\n    // cluster modules for stuff like this.\n    const errno = uv['UV_' + err.errno];\n    send(errno, null);\n  });\n};\n\nRoundRobinHandle.prototype.remove = function(worker) {\n  if (worker.id in this.all === false)\n    return false;\n\n  delete this.all[worker.id];\n  const index = this.free.indexOf(worker);\n\n  if (index !== -1)\n    this.free.splice(index, 1);\n\n  if (getOwnPropertyNames(this.all).length !== 0)\n    return false;\n\n  for (var handle; handle = this.handles.shift(); handle.close())\n    ;\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\nRoundRobinHandle.prototype.distribute = function(err, handle) {\n  this.handles.push(handle);\n  const worker = this.free.shift();\n\n  if (worker)\n    this.handoff(worker);\n};\n\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (worker.id in this.all === false) {\n    return;  // Worker is closing (or has closed) the server.\n  }\n\n  const handle = this.handles.shift();\n\n  if (handle === undefined) {\n    this.free.push(worker);  // Add to ready queue again.\n    return;\n  }\n\n  const message = { act: 'newconn', key: this.key };\n\n  sendHelper(worker.process, message, handle, (reply) => {\n    if (reply.accepted)\n      handle.close();\n    else\n      this.distribute(0, handle);  // Worker is shutting down. Send to another.\n\n    this.handoff(worker);\n  });\n};\n",
  "internal/cluster/shared_handle": "'use strict';\nconst assert = require('assert');\nconst dgram = require('dgram');\nconst net = require('net');\n\nmodule.exports = SharedHandle;\n\nfunction SharedHandle(key, address, port, addressType, fd, flags) {\n  this.key = key;\n  this.workers = [];\n  this.handle = null;\n  this.errno = 0;\n\n  // FIXME(bnoordhuis) Polymorphic return type for lack of a better solution.\n  var rval;\n\n  if (addressType === 'udp4' || addressType === 'udp6')\n    rval = dgram._createSocketHandle(address, port, addressType, fd, flags);\n  else\n    rval = net._createServerHandle(address, port, addressType, fd);\n\n  if (typeof rval === 'number')\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\n\nSharedHandle.prototype.add = function(worker, send) {\n  assert(this.workers.indexOf(worker) === -1);\n  this.workers.push(worker);\n  send(this.errno, null, this.handle);\n};\n\nSharedHandle.prototype.remove = function(worker) {\n  const index = this.workers.indexOf(worker);\n\n  if (index === -1)\n    return false; // The worker wasn't sharing this handle.\n\n  this.workers.splice(index, 1);\n\n  if (this.workers.length !== 0)\n    return false;\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n",
  "internal/cluster/utils": "'use strict';\nconst util = require('util');\n\nmodule.exports = {\n  sendHelper,\n  internal,\n  handles: {} // Used in tests.\n};\n\nconst callbacks = {};\nvar seq = 0;\n\nfunction sendHelper(proc, message, handle, cb) {\n  if (!proc.connected)\n    return false;\n\n  // Mark message as internal. See INTERNAL_PREFIX in lib/child_process.js\n  message = util._extend({ cmd: 'NODE_CLUSTER' }, message);\n\n  if (typeof cb === 'function')\n    callbacks[seq] = cb;\n\n  message.seq = seq;\n  seq += 1;\n  return proc.send(message, handle);\n}\n\n// Returns an internalMessage listener that hands off normal messages\n// to the callback but intercepts and redirects ACK messages.\nfunction internal(worker, cb) {\n  return function onInternalMessage(message, handle) {\n    if (message.cmd !== 'NODE_CLUSTER')\n      return;\n\n    var fn = cb;\n\n    if (message.ack !== undefined && callbacks[message.ack] !== undefined) {\n      fn = callbacks[message.ack];\n      delete callbacks[message.ack];\n    }\n\n    fn.apply(worker, arguments);\n  };\n}\n",
  "internal/cluster/worker": "'use strict';\nconst EventEmitter = require('events');\nconst internalUtil = require('internal/util');\nconst util = require('util');\nconst defineProperty = Object.defineProperty;\nconst suicideDeprecationMessage =\n    'worker.suicide is deprecated. Please use worker.exitedAfterDisconnect.';\n\nmodule.exports = Worker;\n\n// Common Worker implementation shared between the cluster master and workers.\nfunction Worker(options) {\n  if (!(this instanceof Worker))\n    return new Worker(options);\n\n  EventEmitter.call(this);\n\n  if (options === null || typeof options !== 'object')\n    options = {};\n\n  this.exitedAfterDisconnect = undefined;\n\n  defineProperty(this, 'suicide', {\n    get: internalUtil.deprecate(\n      () => this.exitedAfterDisconnect,\n      suicideDeprecationMessage, 'DEP0007'),\n    set: internalUtil.deprecate(\n      (val) => { this.exitedAfterDisconnect = val; },\n      suicideDeprecationMessage, 'DEP0007'),\n    enumerable: true\n  });\n\n  this.state = options.state || 'none';\n  this.id = options.id | 0;\n\n  if (options.process) {\n    this.process = options.process;\n    this.process.on('error', (code, signal) =>\n      this.emit('error', code, signal)\n    );\n    this.process.on('message', (message, handle) =>\n      this.emit('message', message, handle)\n    );\n  }\n}\n\nutil.inherits(Worker, EventEmitter);\n\nWorker.prototype.kill = function() {\n  this.destroy.apply(this, arguments);\n};\n\nWorker.prototype.send = function() {\n  return this.process.send.apply(this.process, arguments);\n};\n\nWorker.prototype.isDead = function() {\n  return this.process.exitCode != null || this.process.signalCode != null;\n};\n\nWorker.prototype.isConnected = function() {\n  return this.process.connected;\n};\n",
  "internal/errors": "'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nconst kCode = Symbol('code');\nconst messages = new Map();\n\nvar util;\nfunction lazyUtil() {\n  if (!util)\n    util = require('util');\n  return util;\n}\n\nvar assert;\nfunction lazyAssert() {\n  if (!assert)\n    assert = require('assert');\n  return assert;\n}\n\nfunction makeNodeError(Base) {\n  return class NodeError extends Base {\n    constructor(key, ...args) {\n      super(message(key, args));\n      this[kCode] = key;\n      Error.captureStackTrace(this, NodeError);\n    }\n\n    get name() {\n      return `${super.name} [${this[kCode]}]`;\n    }\n\n    get code() {\n      return this[kCode];\n    }\n  };\n}\n\nclass AssertionError extends Error {\n  constructor(options) {\n    if (typeof options !== 'object' || options === null) {\n      throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n    }\n    const util = lazyUtil();\n    const assert = lazyAssert();\n    const message = options.message ||\n                    `${util.inspect(options.actual).slice(0, 128)} ` +\n                    `${options.operator} ` +\n                    util.inspect(options.expected).slice(0, 128);\n\n    super(message);\n    this.generatedMessage = !options.message;\n    this.name = 'AssertionError [ERR_ASSERTION]';\n    this.code = 'ERR_ASSERTION';\n    this.actual = options.actual;\n    this.expected = options.expected;\n    this.operator = options.operator;\n    const stackStartFunction = options.stackStartFunction || assert.fail;\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n}\n\nfunction message(key, args) {\n  const assert = lazyAssert();\n  assert.strictEqual(typeof key, 'string');\n  const util = lazyUtil();\n  const msg = messages.get(key);\n  assert(msg, `An invalid error message key was used: ${key}.`);\n  let fmt = util.format;\n  if (typeof msg === 'function') {\n    fmt = msg;\n  } else {\n    if (args === undefined || args.length === 0)\n      return msg;\n    args.unshift(msg);\n  }\n  return String(fmt.apply(null, args));\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val) {\n  messages.set(sym, typeof val === 'function' ? val : String(val));\n}\n\nmodule.exports = exports = {\n  message,\n  Error: makeNodeError(Error),\n  TypeError: makeNodeError(TypeError),\n  RangeError: makeNodeError(RangeError),\n  AssertionError,\n  E // This is exported only to facilitate testing.\n};\n\n// To declare an error message, use the E(sym, val) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value');\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\nE('ERR_ARG_NOT_ITERABLE', '%s must be iterable');\nE('ERR_ASSERTION', (msg) => msg);\nE('ERR_INVALID_ARG_TYPE', invalidArgType);\nE('ERR_INVALID_CALLBACK', 'callback must be a function');\nE('ERR_INVALID_FILE_URL_HOST', 'File URL host %s');\nE('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');\nE('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');\nE('ERR_INVALID_OPT_VALUE',\n  (name, value) => {\n    return `The value \"${String(value)}\" is invalid for option \"${name}\"`;\n  });\nE('ERR_INVALID_SYNC_FORK_INPUT',\n  (value) => {\n    return 'Asynchronous forks do not support Buffer, Uint8Array or string' +\n           `input: ${value}`;\n  });\nE('ERR_INVALID_THIS', 'Value of \"this\" must be of type %s');\nE('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');\nE('ERR_INVALID_URL', 'Invalid URL: %s');\nE('ERR_INVALID_URL_SCHEME',\n  (expected) => `The URL must be ${oneOf(expected, 'scheme')}`);\nE('ERR_IPC_CHANNEL_CLOSED', 'channel closed');\nE('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');\nE('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');\nE('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');\nE('ERR_MISSING_ARGS', missingArgs);\nE('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');\nE('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');\nE('ERR_UNKNOWN_BUILTIN_MODULE', (id) => `No such built-in module: ${id}`);\nE('ERR_UNKNOWN_SIGNAL', (signal) => `Unknown signal: ${signal}`);\nE('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');\nE('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');\nE('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');\nE('ERR_SOCKET_BAD_TYPE',\n  'Bad socket type specified. Valid types are: udp4, udp6');\nE('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');\nE('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');\nE('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');\n// Add new errors from here...\n\nfunction invalidArgType(name, expected, actual) {\n  const assert = lazyAssert();\n  assert(name, 'name is required');\n  var msg = `The \"${name}\" argument must be ${oneOf(expected, 'type')}`;\n  if (arguments.length >= 3) {\n    msg += `. Received type ${actual !== null ? typeof actual : 'null'}`;\n  }\n  return msg;\n}\n\nfunction missingArgs(...args) {\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  let msg = 'The ';\n  const len = args.length;\n  args = args.map((a) => `\"${a}\"`);\n  switch (len) {\n    case 1:\n      msg += `${args[0]} argument`;\n      break;\n    case 2:\n      msg += `${args[0]} and ${args[1]} arguments`;\n      break;\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += `, and ${args[len - 1]} arguments`;\n      break;\n  }\n  return `${msg} must be specified`;\n}\n\nfunction oneOf(expected, thing) {\n  assert(expected, 'expected is required');\n  assert(typeof thing === 'string', 'thing is required');\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    assert(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n",
  "internal/freelist": "'use strict';\n\nclass FreeList {\n  constructor(name, max, ctor) {\n    this.name = name;\n    this.ctor = ctor;\n    this.max = max;\n    this.list = [];\n  }\n\n  alloc() {\n    return this.list.length ? this.list.pop() :\n                              this.ctor.apply(this, arguments);\n  }\n\n  free(obj) {\n    if (this.list.length < this.max) {\n      this.list.push(obj);\n      return true;\n    }\n    return false;\n  }\n}\n\nmodule.exports = FreeList;\n",
  "internal/fs": "'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst Writable = require('stream').Writable;\nconst fs = require('fs');\nconst util = require('util');\n\nconst {\n  O_APPEND,\n  O_CREAT,\n  O_EXCL,\n  O_RDONLY,\n  O_RDWR,\n  O_SYNC,\n  O_TRUNC,\n  O_WRONLY\n} = process.binding('constants').fs;\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new Error(`Unknown encoding: ${encoding}`);\n  }\n}\n\nfunction stringToFlags(flag) {\n  if (typeof flag === 'number') {\n    return flag;\n  }\n\n  switch (flag) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n  }\n\n  throw new Error('Unknown file open flag: ' + flag);\n}\n\n// Temporary hack for process.stdout and process.stderr when piped to files.\nfunction SyncWriteStream(fd, options) {\n  Writable.call(this);\n\n  options = options || {};\n\n  this.fd = fd;\n  this.readable = false;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n\n  this.on('end', () => this._destroy());\n}\n\nutil.inherits(SyncWriteStream, Writable);\n\nSyncWriteStream.prototype._write = function(chunk, encoding, cb) {\n  fs.writeSync(this.fd, chunk, 0, chunk.length);\n  cb();\n  return true;\n};\n\nSyncWriteStream.prototype._destroy = function() {\n  if (this.fd === null) // already destroy()ed\n    return;\n\n  if (this.autoClose)\n    fs.closeSync(this.fd);\n\n  this.fd = null;\n  return true;\n};\n\nSyncWriteStream.prototype.destroySoon =\nSyncWriteStream.prototype.destroy = function() {\n  this._destroy();\n  this.emit('close');\n  return true;\n};\n\nmodule.exports = {\n  assertEncoding,\n  stringToFlags,\n  SyncWriteStream,\n  realpathCacheKey: Symbol('realpathCacheKey')\n};\n",
  "internal/http": "'use strict';\n\nfunction ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n}\n\nmodule.exports = {\n  outHeadersKey: Symbol('outHeadersKey'),\n  ondrain,\n};\n",
  "internal/linkedlist": "'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n}\n\n// show the most idle item\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// remove a item from its list\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// remove a item from its list and place at the end.\nfunction append(list, item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // items are linked  with _idleNext -> (older) and _idlePrev -> (newer)\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // the list _idleNext points to tail (newest) and _idlePrev to head (oldest)\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init,\n  peek,\n  remove,\n  append,\n  isEmpty\n};\n",
  "internal/net": "'use strict';\n\n// Check that the port number is not NaN when coerced to a number,\n// is an integer and that it falls within the legal range of port numbers.\nfunction isLegalPort(port) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && port.trim().length === 0))\n    return false;\n  return +port === (+port >>> 0) && port <= 0xFFFF;\n}\n\nmodule.exports = {\n  isLegalPort,\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n",
  "internal/module": "'use strict';\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\nfunction makeRequireFunction(mod) {\n  const Module = mod.constructor;\n\n  function require(path) {\n    try {\n      exports.requireDepth += 1;\n      return mod.require(path);\n    } finally {\n      exports.requireDepth -= 1;\n    }\n  }\n\n  function resolve(request) {\n    return Module._resolveFilename(request, mod);\n  }\n\n  require.resolve = resolve;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF, the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Find end of shebang line and slice it off\n */\nfunction stripShebang(content) {\n  // Remove shebang\n  var contLen = content.length;\n  if (contLen >= 2) {\n    if (content.charCodeAt(0) === 35/*#*/ &&\n        content.charCodeAt(1) === 33/*!*/) {\n      if (contLen === 2) {\n        // Exact match\n        content = '';\n      } else {\n        // Find end of shebang line and slice it off\n        var i = 2;\n        for (; i < contLen; ++i) {\n          var code = content.charCodeAt(i);\n          if (code === 10/*\\n*/ || code === 13/*\\r*/)\n            break;\n        }\n        if (i === contLen)\n          content = '';\n        else {\n          // Note that this actually includes the newline character(s) in the\n          // new output. This duplicates the behavior of the regular expression\n          // that was previously used to replace the shebang line\n          content = content.slice(i);\n        }\n      }\n    }\n  }\n  return content;\n}\n\nconst builtinLibs = [\n  'assert', 'async_hooks', 'buffer', 'child_process', 'cluster', 'crypto',\n  'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'net', 'os',\n  'path', 'punycode', 'querystring', 'readline', 'repl', 'stream',\n  'string_decoder', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib'\n];\n\nfunction addBuiltinLibsToObject(object) {\n  // Make built-in modules available directly (loaded lazily).\n  builtinLibs.forEach((name) => {\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    Object.defineProperty(object, name, {\n      get: () => {\n        const lib = require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        Object.defineProperty(object, name, {\n          get: () => lib,\n          set: setReal,\n          configurable: true,\n          enumerable: false\n        });\n\n        return lib;\n      },\n      set: setReal,\n      configurable: true,\n      enumerable: false\n    });\n  });\n}\n\nmodule.exports = exports = {\n  addBuiltinLibsToObject,\n  builtinLibs,\n  makeRequireFunction,\n  requireDepth: 0,\n  stripBOM,\n  stripShebang\n};\n",
  "internal/process/next_tick": "'use strict';\n\n// This value is used to prevent the nextTickQueue from becoming too\n// large and cause the process to run out of memory. When this value\n// is reached the nextTimeQueue array will be shortend (see tickDone\n// for details).\nconst kMaxCallbacksPerLoop = 1e4;\n\nexports.setup = setupNextTick;\n// Will be overwritten when setupNextTick() is called.\nexports.nextTick = null;\n\nfunction setupNextTick() {\n  const async_wrap = process.binding('async_wrap');\n  const async_hooks = require('async_hooks');\n  const promises = require('internal/process/promises');\n  const errors = require('internal/errors');\n  const emitPendingUnhandledRejections = promises.setup(scheduleMicrotasks);\n  const initTriggerId = async_hooks.initTriggerId;\n  // Two arrays that share state between C++ and JS.\n  const { async_hook_fields, async_uid_fields } = async_wrap;\n  // Used to change the state of the async id stack.\n  const { pushAsyncIds, popAsyncIds } = async_wrap;\n  // The needed emit*() functions.\n  const { emitInit, emitBefore, emitAfter, emitDestroy } = async_hooks;\n  // Grab the constants necessary for working with internal arrays.\n  const { kInit, kBefore, kAfter, kDestroy, kAsyncUidCntr, kInitTriggerId } =\n      async_wrap.constants;\n  const { async_id_symbol, trigger_id_symbol } = async_wrap;\n  var nextTickQueue = [];\n  var microtasksScheduled = false;\n\n  // Used to run V8's micro task queue.\n  var _runMicrotasks = {};\n\n  // *Must* match Environment::TickInfo::Fields in src/env.h.\n  var kIndex = 0;\n  var kLength = 1;\n\n  process.nextTick = nextTick;\n  // Needs to be accessible from beyond this scope.\n  process._tickCallback = _tickCallback;\n  process._tickDomainCallback = _tickDomainCallback;\n\n  // Set the nextTick() function for internal usage.\n  exports.nextTick = internalNextTick;\n\n  // This tickInfo thing is used so that the C++ code in src/node.cc\n  // can have easy access to our nextTick state, and avoid unnecessary\n  // calls into JS land.\n  const tickInfo = process._setupNextTick(_tickCallback, _runMicrotasks);\n\n  _runMicrotasks = _runMicrotasks.runMicrotasks;\n\n  function tickDone() {\n    if (tickInfo[kLength] !== 0) {\n      if (tickInfo[kLength] <= tickInfo[kIndex]) {\n        nextTickQueue = [];\n        tickInfo[kLength] = 0;\n      } else {\n        nextTickQueue.splice(0, tickInfo[kIndex]);\n        tickInfo[kLength] = nextTickQueue.length;\n      }\n    }\n    tickInfo[kIndex] = 0;\n  }\n\n  function scheduleMicrotasks() {\n    if (microtasksScheduled)\n      return;\n\n    const tickObject =\n        new TickObject(runMicrotasksCallback, undefined, null);\n    // For the moment all microtasks come from the void until the PromiseHook\n    // API is implemented.\n    tickObject[async_id_symbol] = 0;\n    tickObject[trigger_id_symbol] = 0;\n    nextTickQueue.push(tickObject);\n\n    tickInfo[kLength]++;\n    microtasksScheduled = true;\n  }\n\n  function runMicrotasksCallback() {\n    microtasksScheduled = false;\n    _runMicrotasks();\n\n    if (tickInfo[kIndex] < tickInfo[kLength] ||\n        emitPendingUnhandledRejections())\n      scheduleMicrotasks();\n  }\n\n  function _combinedTickCallback(args, callback) {\n    if (args === undefined) {\n      callback();\n    } else {\n      switch (args.length) {\n        case 1:\n          callback(args[0]);\n          break;\n        case 2:\n          callback(args[0], args[1]);\n          break;\n        case 3:\n          callback(args[0], args[1], args[2]);\n          break;\n        default:\n          callback.apply(null, args);\n      }\n    }\n  }\n\n  // TODO(trevnorris): Using std::stack of Environment::AsyncHooks::ids_stack_\n  // is much slower here than was the Float64Array stack used in a previous\n  // implementation. Problem is the Float64Array stack was a bit brittle.\n  // Investigate how to harden that implementation and possibly reintroduce it.\n  function nextTickEmitBefore(asyncId, triggerId) {\n    if (async_hook_fields[kBefore] > 0)\n      emitBefore(asyncId, triggerId);\n    else\n      pushAsyncIds(asyncId, triggerId);\n  }\n\n  function nextTickEmitAfter(asyncId) {\n    if (async_hook_fields[kAfter] > 0)\n      emitAfter(asyncId);\n    else\n      popAsyncIds(asyncId);\n  }\n\n  // Run callbacks that have no domain.\n  // Using domains will cause this to be overridden.\n  function _tickCallback() {\n    do {\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        const tock = nextTickQueue[tickInfo[kIndex]++];\n        const callback = tock.callback;\n        const args = tock.args;\n\n        // CHECK(Number.isSafeInteger(tock[async_id_symbol]))\n        // CHECK(tock[async_id_symbol] > 0)\n        // CHECK(Number.isSafeInteger(tock[trigger_id_symbol]))\n        // CHECK(tock[trigger_id_symbol] > 0)\n\n        nextTickEmitBefore(tock[async_id_symbol], tock[trigger_id_symbol]);\n        // emitDestroy() places the async_id_symbol into an asynchronous queue\n        // that calls the destroy callback in the future. It's called before\n        // calling tock.callback so destroy will be called even if the callback\n        // throws an exception that is handles by 'uncaughtException' or a\n        // domain.\n        // TODO(trevnorris): This is a bit of a hack. It relies on the fact\n        // that nextTick() doesn't allow the event loop to proceed, but if\n        // any async hooks are enabled during the callback's execution then\n        // this tock's after hook will be called, but not its destroy hook.\n        if (async_hook_fields[kDestroy] > 0)\n          emitDestroy(tock[async_id_symbol]);\n\n        // Using separate callback execution functions allows direct\n        // callback invocation with small numbers of arguments to avoid the\n        // performance hit associated with using `fn.apply()`\n        _combinedTickCallback(args, callback);\n\n        nextTickEmitAfter(tock[async_id_symbol]);\n\n        if (kMaxCallbacksPerLoop < tickInfo[kIndex])\n          tickDone();\n      }\n      tickDone();\n      _runMicrotasks();\n      emitPendingUnhandledRejections();\n    } while (tickInfo[kLength] !== 0);\n  }\n\n  function _tickDomainCallback() {\n    do {\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        const tock = nextTickQueue[tickInfo[kIndex]++];\n        const callback = tock.callback;\n        const domain = tock.domain;\n        const args = tock.args;\n        if (domain)\n          domain.enter();\n\n        // CHECK(Number.isSafeInteger(tock[async_id_symbol]))\n        // CHECK(tock[async_id_symbol] > 0)\n        // CHECK(Number.isSafeInteger(tock[trigger_id_symbol]))\n        // CHECK(tock[trigger_id_symbol] > 0)\n\n        nextTickEmitBefore(tock[async_id_symbol], tock[trigger_id_symbol]);\n        // TODO(trevnorris): See comment in _tickCallback() as to why this\n        // isn't a good solution.\n        if (async_hook_fields[kDestroy] > 0)\n          emitDestroy(tock[async_id_symbol]);\n\n        // Using separate callback execution functions allows direct\n        // callback invocation with small numbers of arguments to avoid the\n        // performance hit associated with using `fn.apply()`\n        _combinedTickCallback(args, callback);\n\n        nextTickEmitAfter(tock[async_id_symbol]);\n\n        if (kMaxCallbacksPerLoop < tickInfo[kIndex])\n          tickDone();\n        if (domain)\n          domain.exit();\n      }\n      tickDone();\n      _runMicrotasks();\n      emitPendingUnhandledRejections();\n    } while (tickInfo[kLength] !== 0);\n  }\n\n  function TickObject(callback, args, domain) {\n    this.callback = callback;\n    this.domain = domain;\n    this.args = args;\n    this[async_id_symbol] = -1;\n    this[trigger_id_symbol] = -1;\n  }\n\n  function setupInit(tickObject, triggerId) {\n    tickObject[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    tickObject[trigger_id_symbol] = triggerId || initTriggerId();\n    if (async_hook_fields[kInit] > 0) {\n      emitInit(tickObject[async_id_symbol],\n               'TickObject',\n               tickObject[trigger_id_symbol],\n               tickObject);\n    }\n  }\n\n  function nextTick(callback) {\n    if (typeof callback !== 'function')\n      throw new errors.TypeError('ERR_INVALID_CALLBACK');\n    // on the way out, don't bother. it won't get fired anyway.\n    if (process._exiting)\n      return;\n\n    var args;\n    if (arguments.length > 1) {\n      args = new Array(arguments.length - 1);\n      for (var i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n    }\n\n    var obj = new TickObject(callback, args, process.domain || null);\n    setupInit(obj, null);\n    nextTickQueue.push(obj);\n    tickInfo[kLength]++;\n  }\n\n  function internalNextTick(triggerId, callback) {\n    if (typeof callback !== 'function')\n      throw new TypeError('callback is not a function');\n    // CHECK(Number.isSafeInteger(triggerId) || triggerId === null)\n    // CHECK(triggerId > 0 || triggerId === null)\n\n    if (process._exiting)\n      return;\n\n    var args;\n    if (arguments.length > 2) {\n      args = new Array(arguments.length - 2);\n      for (var i = 2; i < arguments.length; i++)\n        args[i - 2] = arguments[i];\n    }\n\n    var obj = new TickObject(callback, args, process.domain || null);\n    setupInit(obj, triggerId);\n    // The call to initTriggerId() was skipped, so clear kInitTriggerId.\n    async_uid_fields[kInitTriggerId] = 0;\n    nextTickQueue.push(obj);\n    tickInfo[kLength]++;\n  }\n}\n",
  "internal/process/promises": "'use strict';\n\nconst promiseRejectEvent = process._promiseRejectEvent;\nconst hasBeenNotifiedProperty = new WeakMap();\nconst promiseToGuidProperty = new WeakMap();\nconst pendingUnhandledRejections = [];\nlet lastPromiseId = 1;\n\nexports.setup = setupPromises;\n\nfunction getAsynchronousRejectionWarningObject(uid) {\n  return new Error('Promise rejection was handled ' +\n                   `asynchronously (rejection id: ${uid})`);\n}\n\nfunction setupPromises(scheduleMicrotasks) {\n  process._setupPromises(function(event, promise, reason) {\n    if (event === promiseRejectEvent.unhandled)\n      unhandledRejection(promise, reason);\n    else if (event === promiseRejectEvent.handled)\n      rejectionHandled(promise);\n    else\n      require('assert').fail(null, null, 'unexpected PromiseRejectEvent');\n  });\n\n  function unhandledRejection(promise, reason) {\n    hasBeenNotifiedProperty.set(promise, false);\n    promiseToGuidProperty.set(promise, lastPromiseId++);\n    addPendingUnhandledRejection(promise, reason);\n  }\n\n  function rejectionHandled(promise) {\n    const hasBeenNotified = hasBeenNotifiedProperty.get(promise);\n    if (hasBeenNotified !== undefined) {\n      hasBeenNotifiedProperty.delete(promise);\n      const uid = promiseToGuidProperty.get(promise);\n      promiseToGuidProperty.delete(promise);\n      if (hasBeenNotified === true) {\n        let warning = null;\n        if (!process.listenerCount('rejectionHandled')) {\n          // Generate the warning object early to get a good stack trace.\n          warning = getAsynchronousRejectionWarningObject(uid);\n        }\n        process.nextTick(function() {\n          if (!process.emit('rejectionHandled', promise)) {\n            if (warning === null)\n              warning = getAsynchronousRejectionWarningObject(uid);\n            warning.name = 'PromiseRejectionHandledWarning';\n            warning.id = uid;\n            process.emitWarning(warning);\n          }\n        });\n      }\n\n    }\n  }\n\n  function emitWarning(uid, reason) {\n    const warning = new Error('Unhandled promise rejection ' +\n                              `(rejection id: ${uid}): ${String(reason)}`);\n    warning.name = 'UnhandledPromiseRejectionWarning';\n    warning.id = uid;\n    if (reason instanceof Error) {\n      warning.stack = reason.stack;\n    }\n    process.emitWarning(warning);\n    if (!deprecationWarned) {\n      deprecationWarned = true;\n      process.emitWarning(\n        'Unhandled promise rejections are deprecated. In the future, ' +\n        'promise rejections that are not handled will terminate the ' +\n        'Node.js process with a non-zero exit code.',\n        'DeprecationWarning', 'DEP0018');\n    }\n  }\n  var deprecationWarned = false;\n  function emitPendingUnhandledRejections() {\n    let hadListeners = false;\n    while (pendingUnhandledRejections.length > 0) {\n      const promise = pendingUnhandledRejections.shift();\n      const reason = pendingUnhandledRejections.shift();\n      if (hasBeenNotifiedProperty.get(promise) === false) {\n        hasBeenNotifiedProperty.set(promise, true);\n        const uid = promiseToGuidProperty.get(promise);\n        if (!process.emit('unhandledRejection', reason, promise)) {\n          emitWarning(uid, reason);\n        } else {\n          hadListeners = true;\n        }\n      }\n    }\n    return hadListeners;\n  }\n\n  function addPendingUnhandledRejection(promise, reason) {\n    pendingUnhandledRejections.push(promise, reason);\n    scheduleMicrotasks();\n  }\n\n  return emitPendingUnhandledRejections;\n}\n",
  "internal/process/stdio": "'use strict';\n\nexports.setup = setupStdio;\n\nvar errors;\n\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\nfunction setupStdio() {\n  var stdin;\n  var stdout;\n  var stderr;\n\n  function getStdout() {\n    if (stdout) return stdout;\n    stdout = createWritableStdioStream(1);\n    stdout.destroySoon = stdout.destroy;\n    stdout._destroy = function(er, cb) {\n      // avoid errors if we already emitted\n      const errors = lazyErrors();\n      er = er || new errors.Error('ERR_STDOUT_CLOSE');\n      cb(er);\n    };\n    if (stdout.isTTY) {\n      process.on('SIGWINCH', () => stdout._refreshSize());\n    }\n    return stdout;\n  }\n\n  function getStderr() {\n    if (stderr) return stderr;\n    stderr = createWritableStdioStream(2);\n    stderr.destroySoon = stderr.destroy;\n    stderr._destroy = function(er, cb) {\n      // avoid errors if we already emitted\n      const errors = lazyErrors();\n      er = er || new errors.Error('ERR_STDERR_CLOSE');\n      cb(er);\n    };\n    if (stderr.isTTY) {\n      process.on('SIGWINCH', () => stderr._refreshSize());\n    }\n    return stderr;\n  }\n\n  function getStdin() {\n    if (stdin) return stdin;\n\n    const tty_wrap = process.binding('tty_wrap');\n    const fd = 0;\n\n    switch (tty_wrap.guessHandleType(fd)) {\n      case 'TTY':\n        var tty = require('tty');\n        stdin = new tty.ReadStream(fd, {\n          highWaterMark: 0,\n          readable: true,\n          writable: false\n        });\n        break;\n\n      case 'FILE':\n        var fs = require('fs');\n        stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\n        break;\n\n      case 'PIPE':\n      case 'TCP':\n        var net = require('net');\n\n        // It could be that process has been started with an IPC channel\n        // sitting on fd=0, in such case the pipe for this fd is already\n        // present and creating a new one will lead to the assertion failure\n        // in libuv.\n        if (process.channel && process.channel.fd === fd) {\n          stdin = new net.Socket({\n            handle: process.channel,\n            readable: true,\n            writable: false\n          });\n        } else {\n          stdin = new net.Socket({\n            fd: fd,\n            readable: true,\n            writable: false\n          });\n        }\n        // Make sure the stdin can't be `.end()`-ed\n        stdin._writableState.ended = true;\n        break;\n\n      default:\n        // Probably an error on in uv_guess_handle()\n        const errors = lazyErrors();\n        throw new errors.Error('ERR_UNKNOWN_STDIN_TYPE');\n    }\n\n    // For supporting legacy API we put the FD here.\n    stdin.fd = fd;\n\n    // stdin starts out life in a paused state, but node doesn't\n    // know yet.  Explicitly to readStop() it to put it in the\n    // not-reading state.\n    if (stdin._handle && stdin._handle.readStop) {\n      stdin._handle.reading = false;\n      stdin._readableState.reading = false;\n      stdin._handle.readStop();\n    }\n\n    // if the user calls stdin.pause(), then we need to stop reading\n    // immediately, so that the process can close down.\n    stdin.on('pause', () => {\n      if (!stdin._handle)\n        return;\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    });\n\n    return stdin;\n  }\n\n  Object.defineProperty(process, 'stdout', {\n    configurable: true,\n    enumerable: true,\n    get: getStdout\n  });\n\n  Object.defineProperty(process, 'stderr', {\n    configurable: true,\n    enumerable: true,\n    get: getStderr\n  });\n\n  Object.defineProperty(process, 'stdin', {\n    configurable: true,\n    enumerable: true,\n    get: getStdin\n  });\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nfunction createWritableStdioStream(fd) {\n  var stream;\n  const tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      var tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n\n    case 'FILE':\n      var fs = require('internal/fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n      stream._type = 'pipe';\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      const errors = lazyErrors();\n      throw new errors.Error('ERR_UNKNOWN_STREAM_TYPE');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n",
  "internal/process/warning": "'use strict';\n\nconst config = process.binding('config');\nconst prefix = `(${process.release.name}:${process.pid}) `;\n\nexports.setup = setupProcessWarnings;\n\nvar errors;\nvar fs;\nvar cachedFd;\nvar acquiringFd = false;\nfunction nop() {}\n\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\nfunction lazyFs() {\n  if (!fs)\n    fs = require('fs');\n  return fs;\n}\n\nfunction writeOut(message) {\n  if (console && typeof console.error === 'function')\n    return console.error(message);\n  process._rawDebug(message);\n}\n\nfunction onClose(fd) {\n  return function() {\n    lazyFs().close(fd, nop);\n  };\n}\n\nfunction onOpen(cb) {\n  return function(err, fd) {\n    acquiringFd = false;\n    if (fd !== undefined) {\n      cachedFd = fd;\n      process.on('exit', onClose(fd));\n    }\n    cb(err, fd);\n    process.emit('_node_warning_fd_acquired', err, fd);\n  };\n}\n\nfunction onAcquired(message) {\n  // make a best effort attempt at writing the message\n  // to the fd. Errors are ignored at this point.\n  return function(err, fd) {\n    if (err)\n      return writeOut(message);\n    lazyFs().appendFile(fd, `${message}\\n`, nop);\n  };\n}\n\nfunction acquireFd(cb) {\n  if (cachedFd === undefined && !acquiringFd) {\n    acquiringFd = true;\n    lazyFs().open(config.warningFile, 'a', onOpen(cb));\n  } else if (cachedFd !== undefined && !acquiringFd) {\n    cb(null, cachedFd);\n  } else {\n    process.once('_node_warning_fd_acquired', cb);\n  }\n}\n\nfunction output(message) {\n  if (typeof config.warningFile === 'string') {\n    acquireFd(onAcquired(message));\n    return;\n  }\n  writeOut(message);\n}\n\nfunction doEmitWarning(warning) {\n  return function() {\n    process.emit('warning', warning);\n  };\n}\n\nfunction setupProcessWarnings() {\n  if (!process.noProcessWarnings && process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning', (warning) => {\n      if (!(warning instanceof Error)) return;\n      const isDeprecation = warning.name === 'DeprecationWarning';\n      if (isDeprecation && process.noDeprecation) return;\n      const trace = process.traceProcessWarnings ||\n                    (isDeprecation && process.traceDeprecation);\n      let msg = `${prefix}`;\n      if (warning.code)\n        msg += `[${warning.code}] `;\n      if (trace && warning.stack) {\n        msg += `${warning.stack}`;\n      } else {\n        const toString =\n          typeof warning.toString === 'function' ?\n            warning.toString : Error.prototype.toString;\n        msg += `${toString.apply(warning)}`;\n      }\n      if (typeof warning.detail === 'string') {\n        msg += `\\n${warning.detail}`;\n      }\n      output(msg);\n    });\n  }\n\n  // process.emitWarning(error)\n  // process.emitWarning(str[, type[, code]][, ctor])\n  // process.emitWarning(str[, options])\n  process.emitWarning = function(warning, type, code, ctor, now) {\n    const errors = lazyErrors();\n    var detail;\n    if (type !== null && typeof type === 'object' && !Array.isArray(type)) {\n      ctor = type.ctor;\n      code = type.code;\n      if (typeof type.detail === 'string')\n        detail = type.detail;\n      type = type.type || 'Warning';\n    } else if (typeof type === 'function') {\n      ctor = type;\n      code = undefined;\n      type = 'Warning';\n    }\n    if (typeof code === 'function') {\n      ctor = code;\n      code = undefined;\n    }\n    if (code !== undefined && typeof code !== 'string')\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'code', 'string');\n    if (type !== undefined && typeof type !== 'string')\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'type', 'string');\n    if (warning === undefined || typeof warning === 'string') {\n      warning = new Error(warning);\n      warning.name = String(type || 'Warning');\n      if (code !== undefined) warning.code = code;\n      if (detail !== undefined) warning.detail = detail;\n      Error.captureStackTrace(warning, ctor || process.emitWarning);\n    }\n    if (!(warning instanceof Error)) {\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                                 'warning', ['Error', 'string']);\n    }\n    if (warning.name === 'DeprecationWarning') {\n      if (process.noDeprecation)\n        return;\n      if (process.throwDeprecation)\n        throw warning;\n    }\n    if (now) process.emit('warning', warning);\n    else process.nextTick(doEmitWarning(warning));\n  };\n}\n",
  "internal/process": "'use strict';\n\nvar _lazyConstants = null;\n\nfunction lazyConstants() {\n  if (!_lazyConstants) {\n    _lazyConstants = process.binding('constants').os.signals;\n  }\n  return _lazyConstants;\n}\n\nconst assert = process.assert = function(x, msg) {\n  if (!x) throw new Error(msg || 'assertion error');\n};\n\n\n// Set up the process.cpuUsage() function.\nfunction setup_cpuUsage() {\n  // Get the native function, which will be replaced with a JS version.\n  const _cpuUsage = process.cpuUsage;\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  process.cpuUsage = function cpuUsage(prevValue) {\n    // If a previous value was passed in, ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        throw new TypeError('value of user property of argument is invalid');\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        throw new TypeError('value of system property of argument is invalid');\n      }\n    }\n\n    // Call the native function to get the current values.\n    const errmsg = _cpuUsage(cpuValues);\n    if (errmsg) {\n      throw new Error('unable to obtain CPU usage: ' + errmsg);\n    }\n\n    // If a previous value was passed in, return diff of current from previous.\n    if (prevValue) return {\n      user: cpuValues[0] - prevValue.user,\n      system: cpuValues[1] - prevValue.system\n    };\n\n    // If no previous value passed in, return current value.\n    return {\n      user: cpuValues[0],\n      system: cpuValues[1]\n    };\n\n    // Ensure that a previously passed in value is valid. Currently, the native\n    // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n    function previousValueIsValid(num) {\n      return Number.isFinite(num) &&\n          num <= Number.MAX_SAFE_INTEGER &&\n          num >= 0;\n    }\n  };\n}\n\n// The 3 entries filled in by the original process.hrtime contains\n// the upper/lower 32 bits of the second part of the value,\n// and the remaining nanoseconds of the value.\nfunction setup_hrtime() {\n  const _hrtime = process.hrtime;\n  const hrValues = new Uint32Array(3);\n\n  process.hrtime = function hrtime(time) {\n    _hrtime(hrValues);\n\n    if (time !== undefined) {\n      if (Array.isArray(time) && time.length === 2) {\n        const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n        const nsec = hrValues[2] - time[1];\n        const needsBorrow = nsec < 0;\n        return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];\n      }\n\n      throw new TypeError('process.hrtime() only accepts an Array tuple');\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1],\n      hrValues[2]\n    ];\n  };\n}\n\nfunction setupMemoryUsage() {\n  const memoryUsage_ = process.memoryUsage;\n  const memValues = new Float64Array(4);\n\n  process.memoryUsage = function memoryUsage() {\n    memoryUsage_(memValues);\n    return {\n      rss: memValues[0],\n      heapTotal: memValues[1],\n      heapUsed: memValues[2],\n      external: memValues[3]\n    };\n  };\n}\n\nfunction setupConfig(_source) {\n  // NativeModule._source\n  // used for `process.config`, but not a real module\n  var config = _source.config;\n  delete _source.config;\n\n  // strip the gyp comment line at the beginning\n  config = config.split('\\n')\n      .slice(1)\n      .join('\\n')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/'/g, '\"');\n\n  process.config = JSON.parse(config, function(key, value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  });\n  const processConfig = process.binding('config');\n  if (typeof Intl !== 'undefined' && Intl.hasOwnProperty('v8BreakIterator')) {\n    const oldV8BreakIterator = Intl.v8BreakIterator;\n    const des = Object.getOwnPropertyDescriptor(Intl, 'v8BreakIterator');\n    des.value = require('internal/util').deprecate(function v8BreakIterator() {\n      if (processConfig.hasSmallICU && !processConfig.icuDataDir) {\n        // Intl.v8BreakIterator() would crash w/ fatal error, so throw instead.\n        throw new Error('v8BreakIterator: full ICU data not installed. ' +\n                        'See https://github.com/nodejs/node/wiki/Intl');\n      }\n      return Reflect.construct(oldV8BreakIterator, arguments);\n    }, 'Intl.v8BreakIterator is deprecated and will be removed soon.',\n                                                   'DEP0017');\n    Object.defineProperty(Intl, 'v8BreakIterator', des);\n  }\n}\n\n\nfunction setupKillAndExit() {\n\n  process.exit = function(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit', process.exitCode || 0);\n    }\n    process.reallyExit(process.exitCode || 0);\n  };\n\n  process.kill = function(pid, sig) {\n    var err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new TypeError('invalid pid');\n    }\n\n    // preserve null signal\n    if (0 === sig) {\n      err = process._kill(pid, 0);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (lazyConstants()[sig]) {\n        err = process._kill(pid, lazyConstants()[sig]);\n      } else {\n        throw new Error(`Unknown signal: ${sig}`);\n      }\n    }\n\n    if (err) {\n      const errnoException = require('util')._errnoException;\n      throw errnoException(err, 'kill');\n    }\n\n    return true;\n  };\n}\n\n\nfunction setupSignalHandlers() {\n  // Load events module in order to access prototype elements on process like\n  // process.addListener.\n  const signalWraps = {};\n\n  function isSignal(event) {\n    return typeof event === 'string' && lazyConstants()[event] !== undefined;\n  }\n\n  // Detect presence of a listener for the special signal types\n  process.on('newListener', function(type, listener) {\n    if (isSignal(type) &&\n        !signalWraps.hasOwnProperty(type)) {\n      const Signal = process.binding('signal_wrap').Signal;\n      const wrap = new Signal();\n\n      wrap.unref();\n\n      wrap.onsignal = function() { process.emit(type); };\n\n      const signum = lazyConstants()[type];\n      const err = wrap.start(signum);\n      if (err) {\n        wrap.close();\n        const errnoException = require('util')._errnoException;\n        throw errnoException(err, 'uv_signal_start');\n      }\n\n      signalWraps[type] = wrap;\n    }\n  });\n\n  process.on('removeListener', function(type, listener) {\n    if (signalWraps.hasOwnProperty(type) && this.listenerCount(type) === 0) {\n      signalWraps[type].close();\n      delete signalWraps[type];\n    }\n  });\n}\n\n\nfunction setupChannel() {\n  // If we were spawned with env NODE_CHANNEL_FD then load that up and\n  // start parsing data from that stream.\n  if (process.env.NODE_CHANNEL_FD) {\n    const fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const cp = require('child_process');\n\n    // Load tcp_wrap to avoid situation where we might immediately receive\n    // a message.\n    // FIXME is this really necessary?\n    process.binding('tcp_wrap');\n\n    cp._forkChild(fd);\n    assert(process.send);\n  }\n}\n\n\nfunction setupRawDebug() {\n  const format = require('util').format;\n  const rawDebug = process._rawDebug;\n  process._rawDebug = function() {\n    rawDebug(format.apply(null, arguments));\n  };\n}\n\nmodule.exports = {\n  setup_cpuUsage,\n  setup_hrtime,\n  setupMemoryUsage,\n  setupConfig,\n  setupKillAndExit,\n  setupSignalHandlers,\n  setupChannel,\n  setupRawDebug\n};\n",
  "internal/querystring": "'use strict';\n\nconst hexTable = new Array(256);\nfor (var i = 0; i < 256; ++i)\n  hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n\nconst isHexTable = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 64 - 79\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 96 - 111\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 112 - 127\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 128 ...\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  // ... 256\n];\n\nmodule.exports = {\n  hexTable,\n  isHexTable\n};\n",
  "internal/process/write-coverage": "'use strict';\nconst process = require('process');\nconst path = require('path');\nconst fs = require('fs');\nconst mkdirSync = fs.mkdirSync;\nconst writeFileSync = fs.writeFileSync;\n\nfunction writeCoverage() {\n  if (!global.__coverage__) {\n    return;\n  }\n\n  const dirname = path.join(path.dirname(process.execPath), '.coverage');\n  const filename = `coverage-${process.pid}-${Date.now()}.json`;\n  try {\n    mkdirSync(dirname);\n  } catch (err) {\n    if (err.code !== 'EEXIST') {\n      console.error(err);\n      return;\n    }\n  }\n\n  const target = path.join(dirname, filename);\n  const coverageInfo = JSON.stringify(global.__coverage__);\n  try {\n    writeFileSync(target, coverageInfo);\n  } catch (err) {\n    console.error(err);\n  }\n}\n\nfunction setup() {\n  const reallyReallyExit = process.reallyExit;\n\n  process.reallyExit = function(code) {\n    writeCoverage();\n    reallyReallyExit(code);\n  };\n\n  process.on('exit', writeCoverage);\n}\n\nexports.setup = setup;\n",
  "internal/readline": "'use strict';\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/master/index.js\n// License: MIT, authors: @sindresorhus, Qix-, and arjunmehta\n// Matches all ansi escape code sequences in a string\nconst ansi =\n  /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;\n\nconst kEscape = '\\x1b';\n\nvar getStringWidth;\nvar isFullWidthCodePoint;\n\nfunction CSI(strings, ...args) {\n  let ret = `${kEscape}[`;\n  for (var n = 0; n < strings.length; n++) {\n    ret += strings[n];\n    if (n < args.length)\n      ret += args[n];\n  }\n  return ret;\n}\n\nCSI.kEscape = kEscape;\nCSI.kClearToBeginning = CSI`1K`;\nCSI.kClearToEnd = CSI`0K`;\nCSI.kClearLine = CSI`2K`;\nCSI.kClearScreenDown = CSI`0J`;\n\nif (process.binding('config').hasIntl) {\n  const icu = process.binding('icu');\n  getStringWidth = function getStringWidth(str, options) {\n    options = options || {};\n    if (!Number.isInteger(str))\n      str = stripVTControlCharacters(String(str));\n    return icu.getStringWidth(str,\n                              Boolean(options.ambiguousAsFullWidth),\n                              Boolean(options.expandEmojiSequence));\n  };\n  isFullWidthCodePoint =\n    function isFullWidthCodePoint(code, options) {\n      if (typeof code !== 'number')\n        return false;\n      return icu.getStringWidth(code, options) === 2;\n    };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str) {\n    if (Number.isInteger(str))\n      return isFullWidthCodePoint(str) ? 2 : 1;\n\n    let width = 0;\n\n    str = stripVTControlCharacters(String(str));\n\n    for (var i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n\n      if (code >= 0x10000) { // surrogates\n        i++;\n      }\n\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  isFullWidthCodePoint = function isFullWidthCodePoint(code) {\n    if (!Number.isInteger(code)) {\n      return false;\n    }\n\n    // Code points are derived from:\n    // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    if (code >= 0x1100 && (\n        code <= 0x115f ||  // Hangul Jamo\n        0x2329 === code || // LEFT-POINTING ANGLE BRACKET\n        0x232a === code || // RIGHT-POINTING ANGLE BRACKET\n        // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n        (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||\n        // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n        0x3250 <= code && code <= 0x4dbf ||\n        // CJK Unified Ideographs .. Yi Radicals\n        0x4e00 <= code && code <= 0xa4c6 ||\n        // Hangul Jamo Extended-A\n        0xa960 <= code && code <= 0xa97c ||\n        // Hangul Syllables\n        0xac00 <= code && code <= 0xd7a3 ||\n        // CJK Compatibility Ideographs\n        0xf900 <= code && code <= 0xfaff ||\n        // Vertical Forms\n        0xfe10 <= code && code <= 0xfe19 ||\n        // CJK Compatibility Forms .. Small Form Variants\n        0xfe30 <= code && code <= 0xfe6b ||\n        // Halfwidth and Fullwidth Forms\n        0xff01 <= code && code <= 0xff60 ||\n        0xffe0 <= code && code <= 0xffe6 ||\n        // Kana Supplement\n        0x1b000 <= code && code <= 0x1b001 ||\n        // Enclosed Ideographic Supplement\n        0x1f200 <= code && code <= 0x1f251 ||\n        // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n        0x20000 <= code && code <= 0x3fffd)) {\n      return true;\n    }\n\n    return false;\n  };\n}\n\n/**\n * Tries to remove all VT control characters. Use to estimate displayed\n * string width. May be buggy due to not running a real state machine\n */\nfunction stripVTControlCharacters(str) {\n  return str.replace(ansi, '');\n}\n\n\n/*\n  Some patterns seen in terminal key escape codes, derived from combos seen\n  at http://www.midnight-commander.org/browser/lib/tty/key.c\n\n  ESC letter\n  ESC [ letter\n  ESC [ modifier letter\n  ESC [ 1 ; modifier letter\n  ESC [ num char\n  ESC [ num ; modifier char\n  ESC O letter\n  ESC O modifier letter\n  ESC O 1 ; modifier letter\n  ESC N letter\n  ESC [ [ num ; modifier char\n  ESC [ [ 1 ; modifier letter\n  ESC ESC [ num char\n  ESC ESC O letter\n\n  - char is usually ~ but $ and ^ also happen with rxvt\n  - modifier is 1 +\n                (shift     * 1) +\n                (left_alt  * 2) +\n                (ctrl      * 4) +\n                (right_alt * 8)\n  - two leading ESCs apparently mean the same as one leading ESC\n*/\nfunction* emitKeys(stream) {\n  while (true) {\n    let ch = yield;\n    let s = ch;\n    let escaped = false;\n    const key = {\n      sequence: null,\n      name: undefined,\n      ctrl: false,\n      meta: false,\n      shift: false\n    };\n\n    if (ch === kEscape) {\n      escaped = true;\n      s += (ch = yield);\n\n      if (ch === kEscape) {\n        s += (ch = yield);\n      }\n    }\n\n    if (escaped && (ch === 'O' || ch === '[')) {\n      // ansi escape sequence\n      let code = ch;\n      let modifier = 0;\n\n      if (ch === 'O') {\n        // ESC O letter\n        // ESC O modifier letter\n        s += (ch = yield);\n\n        if (ch >= '0' && ch <= '9') {\n          modifier = (ch >> 0) - 1;\n          s += (ch = yield);\n        }\n\n        code += ch;\n      } else if (ch === '[') {\n        // ESC [ letter\n        // ESC [ modifier letter\n        // ESC [ [ modifier letter\n        // ESC [ [ num char\n        s += (ch = yield);\n\n        if (ch === '[') {\n          // \\x1b[[A\n          //      ^--- escape codes might have a second bracket\n          code += ch;\n          s += (ch = yield);\n        }\n\n        /*\n         * Here and later we try to buffer just enough data to get\n         * a complete ascii sequence.\n         *\n         * We have basically two classes of ascii characters to process:\n         *\n         *\n         * 1. `\\x1b[24;5~` should be parsed as { code: '[24~', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+F12 in xterm.\n         *\n         *  - `;5` part is optional, e.g. it could be `\\x1b[24~`\n         *  - first part can contain one or two digits\n         *\n         * So the generic regexp is like /^\\d\\d?(;\\d)?[~^$]$/\n         *\n         *\n         * 2. `\\x1b[1;5H` should be parsed as { code: '[H', modifier: 5 }\n         *\n         * This particular example is featuring Ctrl+Home in xterm.\n         *\n         *  - `1;5` part is optional, e.g. it could be `\\x1b[H`\n         *  - `1;` part is optional, e.g. it could be `\\x1b[5H`\n         *\n         * So the generic regexp is like /^((\\d;)?\\d)?[A-Za-z]$/\n         *\n         */\n        const cmdStart = s.length - 1;\n\n        // skip one or two leading digits\n        if (ch >= '0' && ch <= '9') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += (ch = yield);\n          }\n        }\n\n        // skip modifier\n        if (ch === ';') {\n          s += (ch = yield);\n\n          if (ch >= '0' && ch <= '9') {\n            s += (ch = yield);\n          }\n        }\n\n        /*\n         * We buffered enough data, now trying to extract code\n         * and modifier from it\n         */\n        const cmd = s.slice(cmdStart);\n        let match;\n\n        if ((match = cmd.match(/^(\\d\\d?)(;(\\d))?([~^$])$/))) {\n          code += match[1] + match[4];\n          modifier = (match[3] || 1) - 1;\n        } else if ((match = cmd.match(/^((\\d;)?(\\d))?([A-Za-z])$/))) {\n          code += match[4];\n          modifier = (match[3] || 1) - 1;\n        } else {\n          code += cmd;\n        }\n      }\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      switch (code) {\n        /* xterm/gnome ESC O letter */\n        case 'OP': key.name = 'f1'; break;\n        case 'OQ': key.name = 'f2'; break;\n        case 'OR': key.name = 'f3'; break;\n        case 'OS': key.name = 'f4'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[11~': key.name = 'f1'; break;\n        case '[12~': key.name = 'f2'; break;\n        case '[13~': key.name = 'f3'; break;\n        case '[14~': key.name = 'f4'; break;\n\n        /* from Cygwin and used in libuv */\n        case '[[A': key.name = 'f1'; break;\n        case '[[B': key.name = 'f2'; break;\n        case '[[C': key.name = 'f3'; break;\n        case '[[D': key.name = 'f4'; break;\n        case '[[E': key.name = 'f5'; break;\n\n        /* common */\n        case '[15~': key.name = 'f5'; break;\n        case '[17~': key.name = 'f6'; break;\n        case '[18~': key.name = 'f7'; break;\n        case '[19~': key.name = 'f8'; break;\n        case '[20~': key.name = 'f9'; break;\n        case '[21~': key.name = 'f10'; break;\n        case '[23~': key.name = 'f11'; break;\n        case '[24~': key.name = 'f12'; break;\n\n        /* xterm ESC [ letter */\n        case '[A': key.name = 'up'; break;\n        case '[B': key.name = 'down'; break;\n        case '[C': key.name = 'right'; break;\n        case '[D': key.name = 'left'; break;\n        case '[E': key.name = 'clear'; break;\n        case '[F': key.name = 'end'; break;\n        case '[H': key.name = 'home'; break;\n\n        /* xterm/gnome ESC O letter */\n        case 'OA': key.name = 'up'; break;\n        case 'OB': key.name = 'down'; break;\n        case 'OC': key.name = 'right'; break;\n        case 'OD': key.name = 'left'; break;\n        case 'OE': key.name = 'clear'; break;\n        case 'OF': key.name = 'end'; break;\n        case 'OH': key.name = 'home'; break;\n\n        /* xterm/rxvt ESC [ number ~ */\n        case '[1~': key.name = 'home'; break;\n        case '[2~': key.name = 'insert'; break;\n        case '[3~': key.name = 'delete'; break;\n        case '[4~': key.name = 'end'; break;\n        case '[5~': key.name = 'pageup'; break;\n        case '[6~': key.name = 'pagedown'; break;\n\n        /* putty */\n        case '[[5~': key.name = 'pageup'; break;\n        case '[[6~': key.name = 'pagedown'; break;\n\n        /* rxvt */\n        case '[7~': key.name = 'home'; break;\n        case '[8~': key.name = 'end'; break;\n\n        /* rxvt keys with modifiers */\n        case '[a': key.name = 'up'; key.shift = true; break;\n        case '[b': key.name = 'down'; key.shift = true; break;\n        case '[c': key.name = 'right'; key.shift = true; break;\n        case '[d': key.name = 'left'; key.shift = true; break;\n        case '[e': key.name = 'clear'; key.shift = true; break;\n\n        case '[2$': key.name = 'insert'; key.shift = true; break;\n        case '[3$': key.name = 'delete'; key.shift = true; break;\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\n        case '[7$': key.name = 'home'; key.shift = true; break;\n        case '[8$': key.name = 'end'; key.shift = true; break;\n\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n        /* misc. */\n        case '[Z': key.name = 'tab'; key.shift = true; break;\n        default: key.name = 'undefined'; break;\n      }\n    } else if (ch === '\\r') {\n      // carriage return\n      key.name = 'return';\n    } else if (ch === '\\n') {\n      // enter, should have been called linefeed\n      key.name = 'enter';\n    } else if (ch === '\\t') {\n      // tab\n      key.name = 'tab';\n    } else if (ch === '\\b' || ch === '\\x7f') {\n      // backspace or ctrl+h\n      key.name = 'backspace';\n      key.meta = escaped;\n    } else if (ch === kEscape) {\n      // escape key\n      key.name = 'escape';\n      key.meta = escaped;\n    } else if (ch === ' ') {\n      key.name = 'space';\n      key.meta = escaped;\n    } else if (!escaped && ch <= '\\x1a') {\n      // ctrl+letter\n      key.name = String.fromCharCode(ch.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\n      key.ctrl = true;\n    } else if (/^[0-9A-Za-z]$/.test(ch)) {\n      // letter, number, shift+letter\n      key.name = ch.toLowerCase();\n      key.shift = /^[A-Z]$/.test(ch);\n      key.meta = escaped;\n    } else if (escaped) {\n      // Escape sequence timeout\n      key.name = ch.length ? undefined : 'escape';\n      key.meta = true;\n    }\n\n    key.sequence = s;\n\n    if (s.length !== 0 && (key.name !== undefined || escaped)) {\n      /* Named character or sequence */\n      stream.emit('keypress', escaped ? undefined : s, key);\n    } else if (s.length === 1) {\n      /* Single unnamed character, e.g. \".\" */\n      stream.emit('keypress', s, key);\n    }\n    /* Unrecognized or broken escape sequence, don't emit anything */\n  }\n}\n\nmodule.exports = {\n  emitKeys,\n  getStringWidth,\n  isFullWidthCodePoint,\n  stripVTControlCharacters,\n  CSI\n};\n",
  "internal/repl": "'use strict';\n\nconst Interface = require('readline').Interface;\nconst REPL = require('repl');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\nconst util = require('util');\nconst debug = util.debuglog('repl');\n\nmodule.exports = Object.create(REPL);\nmodule.exports.createInternalRepl = createRepl;\n\n// XXX(chrisdickinson): The 15ms debounce value is somewhat arbitrary.\n// The debounce is to guard against code pasted into the REPL.\nconst kDebounceHistoryMS = 15;\n\nfunction createRepl(env, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = null;\n  }\n  opts = util._extend({\n    ignoreUndefined: false,\n    terminal: process.stdout.isTTY,\n    useGlobal: true,\n    breakEvalOnSigint: true\n  }, opts);\n\n  if (parseInt(env.NODE_NO_READLINE)) {\n    opts.terminal = false;\n  }\n  // the \"dumb\" special terminal, as defined by terminfo, doesn't support\n  // ANSI colour control codes.\n  // see http://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n  if (parseInt(env.NODE_DISABLE_COLORS) || env.TERM === 'dumb') {\n    opts.useColors = false;\n  }\n\n  opts.replMode = {\n    'strict': REPL.REPL_MODE_STRICT,\n    'sloppy': REPL.REPL_MODE_SLOPPY\n  }[String(env.NODE_REPL_MODE).toLowerCase().trim()];\n\n  if (opts.replMode === undefined) {\n    opts.replMode = REPL.REPL_MODE_SLOPPY;\n  }\n\n  const historySize = Number(env.NODE_REPL_HISTORY_SIZE);\n  if (!isNaN(historySize) && historySize > 0) {\n    opts.historySize = historySize;\n  } else {\n    // XXX(chrisdickinson): set here to avoid affecting existing applications\n    // using repl instances.\n    opts.historySize = 1000;\n  }\n\n  const repl = REPL.start(opts);\n  if (opts.terminal) {\n    return setupHistory(repl, env.NODE_REPL_HISTORY,\n                        env.NODE_REPL_HISTORY_FILE, cb);\n  }\n\n  repl._historyPrev = _replHistoryMessage;\n  cb(null, repl);\n}\n\nfunction setupHistory(repl, historyPath, oldHistoryPath, ready) {\n  // Empty string disables persistent history.\n\n  if (typeof historyPath === 'string')\n    historyPath = historyPath.trim();\n\n  if (historyPath === '') {\n    repl._historyPrev = _replHistoryMessage;\n    return ready(null, repl);\n  }\n\n  if (!historyPath) {\n    try {\n      historyPath = path.join(os.homedir(), '.node_repl_history');\n    } catch (err) {\n      repl._writeToOutput('\\nError: Could not get the home directory.\\n' +\n                          'REPL session history will not be persisted.\\n');\n      repl._refreshLine();\n\n      debug(err.stack);\n      repl._historyPrev = _replHistoryMessage;\n      return ready(null, repl);\n    }\n  }\n\n  var timer = null;\n  var writing = false;\n  var pending = false;\n  repl.pause();\n  // History files are conventionally not readable by others:\n  // https://github.com/nodejs/node/issues/3392\n  // https://github.com/nodejs/node/pull/3394\n  fs.open(historyPath, 'a+', 0o0600, oninit);\n\n  function oninit(err, hnd) {\n    if (err) {\n      // Cannot open history file.\n      // Don't crash, just don't persist history.\n      repl._writeToOutput('\\nError: Could not open history file.\\n' +\n                          'REPL session history will not be persisted.\\n');\n      repl._refreshLine();\n      debug(err.stack);\n\n      repl._historyPrev = _replHistoryMessage;\n      repl.resume();\n      return ready(null, repl);\n    }\n    fs.close(hnd, onclose);\n  }\n\n  function onclose(err) {\n    if (err) {\n      return ready(err);\n    }\n    fs.readFile(historyPath, 'utf8', onread);\n  }\n\n  function onread(err, data) {\n    if (err) {\n      return ready(err);\n    }\n\n    if (data) {\n      repl.history = data.split(/[\\n\\r]+/, repl.historySize);\n    } else if (oldHistoryPath === historyPath) {\n      // If pre-v3.0, the user had set NODE_REPL_HISTORY_FILE to\n      // ~/.node_repl_history, warn the user about it and proceed.\n      repl._writeToOutput(\n          '\\nThe old repl history file has the same name and location as ' +\n          `the new one i.e., ${historyPath} and is empty.\\nUsing it as is.\\n`);\n      repl._refreshLine();\n\n    } else if (oldHistoryPath) {\n      // Grab data from the older pre-v3.0 JSON NODE_REPL_HISTORY_FILE format.\n      repl._writeToOutput(\n          '\\nConverting old JSON repl history to line-separated history.\\n' +\n          `The new repl history file can be found at ${historyPath}.\\n`);\n      repl._refreshLine();\n\n      try {\n        // Pre-v3.0, repl history was stored as JSON.\n        // Try and convert it to line separated history.\n        const oldReplJSONHistory = fs.readFileSync(oldHistoryPath, 'utf8');\n\n        // Only attempt to use the history if there was any.\n        if (oldReplJSONHistory) repl.history = JSON.parse(oldReplJSONHistory);\n\n        if (!Array.isArray(repl.history)) {\n          throw new Error('Expected array, got ' + typeof repl.history);\n        }\n        repl.history = repl.history.slice(0, repl.historySize);\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          return ready(\n            new Error(`Could not parse history data in ${oldHistoryPath}.`));\n        }\n      }\n    }\n\n    fs.open(historyPath, 'r+', onhandle);\n  }\n\n  function onhandle(err, hnd) {\n    if (err) {\n      return ready(err);\n    }\n    fs.ftruncate(hnd, 0, (err) => {\n      repl._historyHandle = hnd;\n      repl.on('line', online);\n\n      // reading the file data out erases it\n      repl.once('flushHistory', function() {\n        repl.resume();\n        ready(null, repl);\n      });\n      flushHistory();\n    });\n  }\n\n  // ------ history listeners ------\n  function online() {\n    repl._flushing = true;\n\n    if (timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(flushHistory, kDebounceHistoryMS);\n  }\n\n  function flushHistory() {\n    timer = null;\n    if (writing) {\n      pending = true;\n      return;\n    }\n    writing = true;\n    const historyData = repl.history.join(os.EOL);\n    fs.write(repl._historyHandle, historyData, 0, 'utf8', onwritten);\n  }\n\n  function onwritten(err, data) {\n    writing = false;\n    if (pending) {\n      pending = false;\n      online();\n    } else {\n      repl._flushing = Boolean(timer);\n      if (!repl._flushing) {\n        repl.emit('flushHistory');\n      }\n    }\n  }\n}\n\n\nfunction _replHistoryMessage() {\n  if (this.history.length === 0) {\n    this._writeToOutput(\n        '\\nPersistent history support disabled. ' +\n        'Set the NODE_REPL_HISTORY environment\\nvariable to ' +\n        'a valid, user-writable path to enable.\\n'\n    );\n    this._refreshLine();\n  }\n  this._historyPrev = Interface.prototype._historyPrev;\n  return this._historyPrev();\n}\n",
  "internal/socket_list": "'use strict';\n\nconst EventEmitter = require('events');\n\n// This object keep track of the socket there are sended\nclass SocketListSend extends EventEmitter {\n  constructor(child, key) {\n    super();\n    this.key = key;\n    this.child = child;\n  }\n\n  _request(msg, cmd, callback) {\n    var self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child.send(msg);\n\n    function onclose() {\n      self.child.removeListener('internalMessage', onreply);\n      callback(new Error('child closed before reply'));\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect', onclose);\n      self.child.removeListener('internalMessage', onreply);\n\n      callback(null, msg);\n    }\n\n    this.child.once('disconnect', onclose);\n    this.child.on('internalMessage', onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE',\n      key: this.key\n    }, 'NODE_SOCKET_ALL_CLOSED', callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT',\n      key: this.key\n    }, 'NODE_SOCKET_COUNT', function(err, msg) {\n      if (err) return callback(err);\n      callback(null, msg.count);\n    });\n  }\n}\n\n\n// This object keep track of the socket there are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child, key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child.send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED',\n        key: self.key\n      });\n    }\n\n    this.child.on('internalMessage', (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty', onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child.send({\n          cmd: 'NODE_SOCKET_COUNT',\n          key: this.key,\n          count: this.connections\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify previous owner of socket about its state change\n    obj.socket.once('close', () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty', this);\n    });\n  }\n}\n\nmodule.exports = {SocketListSend, SocketListReceive};\n",
  "internal/test/unicode": "'use strict';\n\n// This module exists entirely for regression testing purposes.\n// See `test/parallel/test-internal-unicode.js`.\n\nmodule.exports = '✓';\n",
  "internal/url": "'use strict';\n\nconst util = require('util');\nconst {\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\n\nconst { getConstructorOf } = require('internal/util');\nconst errors = require('internal/errors');\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII,\n  domainToUnicode: _domainToUnicode,\n  encodeAuth,\n  toUSVString: _toUSVString,\n  parse: _parse,\n  setURLConstructor,\n  URL_FLAGS_CANNOT_BE_BASE,\n  URL_FLAGS_HAS_FRAGMENT,\n  URL_FLAGS_HAS_HOST,\n  URL_FLAGS_HAS_PASSWORD,\n  URL_FLAGS_HAS_PATH,\n  URL_FLAGS_HAS_QUERY,\n  URL_FLAGS_HAS_USERNAME,\n  URL_FLAGS_SPECIAL,\n  kFragment,\n  kHost,\n  kHostname,\n  kPathStart,\n  kPort,\n  kQuery,\n  kSchemeStart\n} = process.binding('url');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = Object.getPrototypeOf(\n  Object.getPrototypeOf([][Symbol.iterator]())\n);\n\nconst unpairedSurrogateRe =\n    /([^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5, `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = unpairedSurrogateRe.exec(str);\n  if (!match)\n    return str;\n  return _toUSVString(str, match.index);\n}\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme, host, port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard, with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction onParseComplete(flags, protocol, username, password,\n                         host, port, path, query, fragment) {\n  var ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams], query);\n}\n\nfunction onParseError(flags, input) {\n  const error = new errors.TypeError('ERR_INVALID_URL', input);\n  error.input = input;\n  throw error;\n}\n\n// Reused by URL constructor and URL#href setter.\nfunction parse(url, input, base) {\n  const base_context = base ? base[context] : undefined;\n  url[context] = new URLContext();\n  _parse(input.trim(), -1, base_context, undefined,\n         onParseComplete.bind(url), onParseError);\n}\n\nfunction onParseProtocolComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n}\n\nfunction onParseHostComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n  if (port !== null)\n    ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].port = port;\n}\n\nfunction onParsePathComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags, protocol, username, password,\n                               host, port, path, query, fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input, base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    if (base !== undefined &&\n        (!base[searchParams] || !base[searchParams][searchParams])) {\n      base = new URL(base);\n    }\n    parse(this, input, base);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host, scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [util.inspect.custom](depth, opts) {\n    if (this == null ||\n        Object.getPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return opts.stylize('[Object]', 'special');\n\n    var ctor = getConstructorOf(this);\n\n    var obj = Object.create({\n      constructor: ctor === null ? URL : ctor\n    });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return util.inspect(obj, opts);\n  }\n}\n\nObject.defineProperties(URL.prototype, {\n  [kFormat]: {\n    enumerable: false,\n    configurable: false,\n    // eslint-disable-next-line func-name-matching\n    value: function format(options) {\n      if (options && typeof options !== 'object')\n        throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n      options = Object.assign({\n        fragment: true,\n        unicode: false,\n        search: true,\n        auth: true\n      }, options);\n      const ctx = this[context];\n      var ret = ctx.scheme;\n      if (ctx.host !== null) {\n        ret += '//';\n        const has_username = ctx.username !== '';\n        const has_password = ctx.password !== '';\n        if (options.auth && (has_username || has_password)) {\n          if (has_username)\n            ret += ctx.username;\n          if (has_password)\n            ret += `:${ctx.password}`;\n          ret += '@';\n        }\n        ret += options.unicode ?\n          domainToUnicode(this.host) : this.host;\n      } else if (ctx.scheme === 'file:') {\n        ret += '//';\n      }\n      if (this.pathname)\n        ret += this.pathname;\n      if (options.search && ctx.query !== null)\n        ret += `?${ctx.query}`;\n      if (options.fragment && ctx.fragment !== null)\n        ret += `#${ctx.fragment}`;\n      return ret;\n    }\n  },\n  [Symbol.toStringTag]: {\n    configurable: true,\n    value: 'URL'\n  },\n  toString: {\n    // https://heycam.github.io/webidl/#es-stringifier\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toString() {\n      return this[kFormat]({});\n    }\n  },\n  href: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[kFormat]({});\n    },\n    set(input) {\n      // toUSVString is not needed.\n      input = `${input}`;\n      parse(this, input);\n    }\n  },\n  origin: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      // Refs: https://url.spec.whatwg.org/#concept-url-origin\n      const ctx = this[context];\n      switch (ctx.scheme) {\n        case 'blob:':\n          if (ctx.path.length > 0) {\n            try {\n              return (new URL(ctx.path[0])).origin;\n            } catch (err) {\n              // fall through... do nothing\n            }\n          }\n          return kOpaqueOrigin;\n        case 'ftp:':\n        case 'gopher:':\n        case 'http:':\n        case 'https:':\n        case 'ws:':\n        case 'wss:':\n          return serializeTupleOrigin(ctx.scheme, ctx.host, ctx.port);\n      }\n      return kOpaqueOrigin;\n    }\n  },\n  protocol: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].scheme;\n    },\n    set(scheme) {\n      // toUSVString is not needed.\n      scheme = `${scheme}`;\n      if (scheme.length === 0)\n        return;\n      const ctx = this[context];\n      if (ctx.scheme === 'file:' &&\n          (ctx.host === '' || ctx.host === null)) {\n        return;\n      }\n      _parse(scheme, kSchemeStart, null, ctx,\n             onParseProtocolComplete.bind(this));\n    }\n  },\n  username: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].username;\n    },\n    set(username) {\n      // toUSVString is not needed.\n      username = `${username}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (username === '') {\n        ctx.username = '';\n        ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n        return;\n      }\n      ctx.username = encodeAuth(username);\n      ctx.flags |= URL_FLAGS_HAS_USERNAME;\n    }\n  },\n  password: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].password;\n    },\n    set(password) {\n      // toUSVString is not needed.\n      password = `${password}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (password === '') {\n        ctx.password = '';\n        ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n        return;\n      }\n      ctx.password = encodeAuth(password);\n      ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n    }\n  },\n  host: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      var ret = ctx.host || '';\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n      return ret;\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHost, null, ctx, onParseHostComplete.bind(this));\n    }\n  },\n  hostname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].host || '';\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHostname, null, ctx, onParseHostnameComplete.bind(this));\n    }\n  },\n  port: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const port = this[context].port;\n      return port === null ? '' : String(port);\n    },\n    set(port) {\n      // toUSVString is not needed.\n      port = `${port}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (port === '') {\n        ctx.port = null;\n        return;\n      }\n      _parse(port, kPort, null, ctx, onParsePortComplete.bind(this));\n    }\n  },\n  pathname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      if (this[cannotBeBase])\n        return ctx.path[0];\n      if (ctx.path.length === 0)\n        return '';\n      return `/${ctx.path.join('/')}`;\n    },\n    set(path) {\n      // toUSVString is not needed.\n      path = `${path}`;\n      if (this[cannotBeBase])\n        return;\n      _parse(path, kPathStart, null, this[context],\n             onParsePathComplete.bind(this));\n    }\n  },\n  search: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { query } = this[context];\n      if (query === null || query === '')\n        return '';\n      return `?${query}`;\n    },\n    set(search) {\n      const ctx = this[context];\n      search = toUSVString(search);\n      if (search === '') {\n        ctx.query = null;\n        ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n      } else {\n        if (search[0] === '?') search = search.slice(1);\n        ctx.query = '';\n        ctx.flags |= URL_FLAGS_HAS_QUERY;\n        if (search) {\n          _parse(search, kQuery, null, ctx, onParseSearchComplete.bind(this));\n        }\n      }\n      initSearchParams(this[searchParams], search);\n    }\n  },\n  searchParams: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[searchParams];\n    }\n  },\n  hash: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { fragment } = this[context];\n      if (fragment === null || fragment === '')\n        return '';\n      return `#${fragment}`;\n    },\n    set(hash) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      hash = `${hash}`;\n      if (!hash) {\n        ctx.fragment = null;\n        ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n        return;\n      }\n      if (hash[0] === '#') hash = hash.slice(1);\n      ctx.fragment = '';\n      ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n      _parse(hash, kFragment, null, ctx, onParseHashComplete.bind(this));\n    }\n  },\n  toJSON: {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toJSON() {\n      return this[kFormat]({});\n    }\n  }\n});\n\nfunction update(url, params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url, init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  var pairStart = 0;\n  var lastPos = 0;\n  var seenSep = false;\n  var buf = '';\n  var encoded = false;\n  var encodeCheck = 0;\n  var i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator\n    if (code === 38/*&*/) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key, add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === 61/*=*/) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === 43/*+*/) {\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === 37/*%*/) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        // eslint-disable-next-line no-extra-boolean-cast\n        if (!!isHexTable[code]) {\n          if (++encodeCheck === 3)\n            encoded = true;\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += qs.slice(lastPos, i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  out.push(buf);\n\n  // If `buf` is the key, add an empty value.\n  if (!seenSep)\n    out.push('');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = [\n//0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 0x70 - 0x7F\n];\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\nfunction escapeParam(str) {\n  const len = str.length;\n  if (len === 0)\n    return '';\n\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < len; i++) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscape[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += paramHexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += paramHexTable[0xC0 | (c >> 6)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += paramHexTable[0xE0 | (c >> 12)] +\n             paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < len)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else {\n      // This branch should never happen because all URLSearchParams entries\n      // should already be converted to USVString. But, included for\n      // completion's sake anyway.\n      c2 = 0;\n    }\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += paramHexTable[0xF0 | (c >> 18)] +\n           paramHexTable[0x80 | ((c >> 12) & 0x3F)] +\n           paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n           paramHexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < len)\n    return out + str.slice(lastPos);\n  return out;\n}\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  var output = `${escapeParam(array[0])}=${escapeParam(array[1])}`;\n  for (var i = 2; i < len; i += 2)\n    output += `&${escapeParam(array[i])}=${escapeParam(array[i + 1])}`;\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto, classStr, obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  Object.defineProperty(proto, Symbol.toStringTag, {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of Object.keys(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n  for (const key of Object.getOwnPropertySymbols(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is '', but as undefined and '' have\n  // the same result, undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method === this[Symbol.iterator]) {\n        // While the spec does not have this branch, we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new errors.TypeError('ERR_ARG_NOT_ITERABLE', 'Query pairs');\n        }\n\n        // sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function') {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          pairs.push(Array.from(pair));\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          const key = toUSVString(pair[0]);\n          const value = toUSVString(pair[1]);\n          this[searchParams].push(key, value);\n        }\n      } else {\n        // record<USVString, USVString>\n        this[searchParams] = [];\n        for (var key of Object.keys(init)) {\n          key = toUSVString(key);\n          const value = toUSVString(init[key]);\n          this[searchParams].push(key, value);\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this, init);\n    }\n\n    // \"associated url object\"\n    this[context] = null;\n  }\n\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    var separator = ', ';\n    var innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    var innerInspect = (v) => util.inspect(v, innerOpts);\n\n    var list = this[searchParams];\n    var output = [];\n    for (var i = 0; i < list.length; i += 2)\n      output.push(`${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    var colorRe = /\\u001b\\[\\d\\d?m/g;\n    var length = output.reduce(\n      (prev, cur) => prev + cur.replace(colorRe, '').length + separator.length,\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n  ${output.join(',\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ${output.join(separator)} }`;\n    } else {\n      return `${this.constructor.name} {}`;\n    }\n  }\n}\n\n// for merge sort\nfunction merge(out, start, mid, end, lBuffer, rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  var l, r, o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\ndefineIDLClass(URLSearchParams.prototype, 'URLSearchParams', {\n  append(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    this[searchParams].push(name, value);\n    update(this[context], this);\n  },\n\n  delete(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context], this);\n  },\n\n  get(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  },\n\n  getAll(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  },\n\n  has(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  set(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`, in `list`, set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    var found = false;\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i, 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise, append a new name-value pair whose name is `name` and value\n    // is `value`, to `list`.\n    if (!found) {\n      list.push(name, value);\n    }\n\n    update(this[context], this);\n  },\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n    if (len <= 2) {\n      return;\n    }\n\n    // arbitrary number found through testing\n    if (len < 100) {\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (var i = 2; i < len; i += 2) {\n        var curKey = a[i];\n        var curVal = a[i + 1];\n        var j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (var step = 2; step < len; step *= 2) {\n        for (var start = 0; start < len - 2; start += 2 * step) {\n          var mid = start + step;\n          var end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a, start, mid, end, lBuffer, rBuffer);\n        }\n      }\n    }\n\n    update(this[context], this);\n  },\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key+value');\n  },\n\n  forEach(callback, thisArg = undefined) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (typeof callback !== 'function') {\n      throw new errors.TypeError('ERR_INVALID_CALLBACK');\n    }\n\n    let list = this[searchParams];\n\n    var i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg, value, key, this);\n      // in case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  },\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key');\n  },\n\n  values() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'value');\n  },\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return serializeParams(this[searchParams]);\n  }\n});\n\n// https://heycam.github.io/webidl/#es-iterable-entries\nObject.defineProperty(URLSearchParams.prototype, Symbol.iterator, {\n  writable: true,\n  configurable: true,\n  value: URLSearchParams.prototype.entries\n});\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target, kind) {\n  const iterator = Object.create(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = Object.create(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype, 'URLSearchParamsIterator', {\n  next() {\n    if (!this ||\n        Object.getPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n    }\n\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name, value];\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  },\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    const innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const output = target[searchParams].slice(index).reduce((prev, cur, i) => {\n      const key = i % 2 === 0;\n      if (kind === 'key' && key) {\n        prev.push(cur);\n      } else if (kind === 'value' && !key) {\n        prev.push(cur);\n      } else if (kind === 'key+value' && !key) {\n        prev.push([target[searchParams][index + i - 1], cur]);\n      }\n      return prev;\n    }, []);\n    const breakLn = util.inspect(output, innerOpts).includes('\\n');\n    const outputStrs = output.map((p) => util.inspect(p, innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${outputStrs.join(',\\n  ')}`;\n    } else {\n      outputStr = ` ${outputStrs.join(', ')}`;\n    }\n    return `${this[Symbol.toStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToOptions(url) {\n  var options = {\n    protocol: url.protocol,\n    host: url.host,\n    hostname: url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname}${url.search}`,\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  var hostname = url.hostname;\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        return new errors.TypeError(\n          'ERR_INVALID_FILE_URL_PATH',\n          'must not include encoded \\\\ or / characters');\n      }\n    }\n  }\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set, then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `//${domainToUnicode(hostname)}${pathname}`;\n  } else {\n    // Otherwise, it's a local path that requires a drive letter\n    var letter = pathname.codePointAt(1) | 0x20;\n    var sep = pathname[2];\n    if (letter < 97 || letter > 122 ||   // a..z A..Z\n        (sep !== ':')) {\n      return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                  'must be absolute');\n    }\n    return pathname.slice(1);\n  }\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    return new errors.TypeError('ERR_INVALID_FILE_URL_HOST',\n                                `must be \"localhost\" or empty on ${platform}`);\n  }\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                    'must not include encoded / characters');\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction getPathFromURL(path) {\n  if (path == null || !path[searchParams] ||\n      !path[searchParams][searchParams]) {\n    return path;\n  }\n  if (path.protocol !== 'file:')\n    return new errors.TypeError('ERR_INVALID_URL_SCHEME', 'file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\nfunction NativeURL(ctx) {\n  this[context] = ctx;\n}\nNativeURL.prototype = URL.prototype;\n\nfunction constructUrl(flags, protocol, username, password,\n                      host, port, path, query, fragment) {\n  var ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  const url = new NativeURL(ctx);\n  url[searchParams] = new URLSearchParams();\n  url[searchParams][context] = url;\n  initSearchParams(url[searchParams], query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString,\n  getPathFromURL,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  urlToOptions,\n  formatSymbol: kFormat,\n  searchParamsSymbol: searchParams\n};\n",
  "internal/util": "'use strict';\n\nconst errors = require('internal/errors');\nconst binding = process.binding('util');\nconst signals = process.binding('constants').os.signals;\n\nconst { createPromise, promiseResolve, promiseReject } = binding;\n\nconst kArrowMessagePrivateSymbolIndex = binding['arrow_message_private_symbol'];\nconst kDecoratedPrivateSymbolIndex = binding['decorated_private_symbol'];\nconst noCrypto = !process.versions.openssl;\n\nfunction isError(e) {\n  return objectToString(e) === '[object Error]' || e instanceof Error;\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nfunction deprecate(fn, msg, code) {\n  // Allow for deprecating things in the process of starting up.\n  if (global.process === undefined) {\n    return function(...args) {\n      return deprecate(fn, msg).apply(this, args);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  if (code !== undefined && typeof code !== 'string')\n    throw new TypeError('`code` argument must be a string');\n\n  var warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        process.emitWarning(msg, 'DeprecationWarning', code, deprecated);\n      } else {\n        process.emitWarning(msg, 'DeprecationWarning', deprecated);\n      }\n    }\n    if (new.target) {\n      return Reflect.construct(fn, args, new.target);\n    }\n    return fn.apply(this, args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      binding.getHiddenValue(err, kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = binding.getHiddenValue(err, kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    binding.setHiddenValue(err, kDecoratedPrivateSymbolIndex, true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new Error('Node.js is not compiled with openssl crypto support');\n}\n\n// The loop should only run at most twice, retrying with lowercased enc\n// if there is no match in the first pass.\n// We use a loop instead of branching to retry with a helper\n// function in order to avoid the performance hit.\n// Return undefined if there is no match.\nfunction normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\nfunction filterDuplicateStrings(items, low) {\n  const map = new Map();\n  for (var i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = item.toLowerCase();\n    if (low) {\n      map.set(key, key);\n    } else {\n      map.set(key, item);\n    }\n  }\n  return Array.from(map.values()).sort();\n}\n\nfunction cachedResult(fn) {\n  var result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return result.slice();\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return Reflect.construct(type, args, new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  Object.defineProperties(fn, {\n    name: {value: type.name},\n    length: {value: type.length}\n  });\n  Object.setPrototypeOf(fn, type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = Object.create(null);\n  for (var key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[signal.toUpperCase()];\n    if (signalName) return signalName;\n  }\n\n  throw new errors.Error('ERR_UNKNOWN_SIGNAL', signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = Object.getPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nconst kCustomPromisifiedSymbol = Symbol('util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nfunction promisify(orig) {\n  if (typeof orig !== 'function') {\n    const errors = require('internal/errors');\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'original', 'function');\n  }\n\n  if (orig[kCustomPromisifiedSymbol]) {\n    const fn = orig[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The [util.promisify.custom] property must be ' +\n                          'a function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['stdout', 'stderr'] for child_process.exec.\n  const argumentNames = orig[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    const promise = createPromise();\n    try {\n      orig.call(this, ...args, (err, ...values) => {\n        if (err) {\n          promiseReject(promise, err);\n        } else if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (var i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          promiseResolve(promise, obj);\n        } else {\n          promiseResolve(promise, values[0]);\n        }\n      });\n    } catch (err) {\n      promiseReject(promise, err);\n    }\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(orig));\n\n  Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(orig));\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\nmodule.exports = {\n  assertCrypto,\n  cachedResult,\n  convertToValidSignal,\n  createClassWrapper,\n  decorateErrorStack,\n  deprecate,\n  filterDuplicateStrings,\n  getConstructorOf,\n  isError,\n  normalizeEncoding,\n  objectToString,\n  promisify,\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol,\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: Symbol('util.inspect.custom'),\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation, just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('node.isEncoding')\n};\n",
  "internal/v8_prof_polyfill": "// Copyright 2012 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Node polyfill\nconst fs = require('fs');\nconst cp = require('child_process');\nconst os = {\n  system: function(name, args) {\n    if (process.platform === 'linux' && name === 'nm') {\n      // Filter out vdso and vsyscall entries.\n      const arg = args[args.length - 1];\n      if (arg === '[vdso]' ||\n          arg == '[vsyscall]' ||\n          /^[0-9a-f]+-[0-9a-f]+$/.test(arg)) {\n        return '';\n      }\n    }\n    let out = cp.spawnSync(name, args).stdout.toString();\n    // Auto c++filt names, but not [iItT]\n    if (process.platform === 'darwin' && name === 'nm')\n      out = macCppfiltNm(out);\n    return out;\n  }\n};\nconst print = console.log;\nfunction read(fileName) {\n  return fs.readFileSync(fileName, 'utf8');\n}\nconst quit = process.exit;\n\n// Polyfill \"readline()\".\nconst logFile = arguments[arguments.length - 1];\ntry {\n  fs.accessSync(logFile);\n} catch(e) {\n  console.error('Please provide a valid isolate file as the final argument.');\n  process.exit(1);\n}\nconst fd = fs.openSync(logFile, 'r');\nconst buf = Buffer.allocUnsafe(4096);\nconst dec = new (require('string_decoder').StringDecoder)('utf-8');\nvar line = '';\nversionCheck();\nfunction readline() {\n  while (true) {\n    const lineBreak = line.indexOf('\\n');\n    if (lineBreak !== -1) {\n      const res = line.slice(0, lineBreak);\n      line = line.slice(lineBreak + 1);\n      return res;\n    }\n    const bytes = fs.readSync(fd, buf, 0, buf.length);\n    line += dec.write(buf.slice(0, bytes));\n    if (line.length === 0) {\n      return '';\n    }\n  }\n}\n\nfunction versionCheck() {\n  // v8-version looks like \"v8-version,$major,$minor,$build,$patch,$candidate\"\n  // whereas process.versions.v8 is either \"$major.$minor.$build\" or\n  // \"$major.$minor.$build.$patch\".\n  var firstLine = readline();\n  line = firstLine + '\\n' + line;\n  firstLine = firstLine.split(',');\n  const curVer = process.versions.v8.split('.');\n  if (firstLine.length !== 6 && firstLine[0] !== 'v8-version') {\n    console.log('Unable to read v8-version from log file.');\n    return;\n  }\n  // Compare major, minor and build; ignore the patch and candidate fields.\n  for (var i = 0; i < 3; i++) {\n    if (curVer[i] !== firstLine[i + 1]) {\n      console.log('Testing v8 version different from logging version');\n      return;\n    }\n  }\n}\n\nfunction macCppfiltNm(out) {\n  // Re-grouped copy-paste from `tickprocessor.js`\n  const FUNC_RE = /^([0-9a-fA-F]{8,16} [iItT] )(.*)$/gm;\n  let entries = out.match(FUNC_RE);\n  if (entries === null)\n    return out;\n\n  entries = entries.map((entry) => {\n    return entry.replace(/^[0-9a-fA-F]{8,16} [iItT] /, '')\n  });\n\n  let filtered;\n  try {\n    filtered = cp.spawnSync('c++filt', [ '-p' , '-i' ], {\n      input: entries.join('\\n')\n    }).stdout.toString();\n  } catch (e) {\n    return out;\n  }\n\n  let i = 0;\n  filtered = filtered.split(/\\n/g);\n  return out.replace(FUNC_RE, (all, prefix, postfix) => {\n    return prefix + (filtered[i++] || postfix);\n  });\n}\n",
  "internal/v8_prof_processor": "/* eslint-disable strict */\nconst scriptFiles = [\n  'internal/v8_prof_polyfill',\n  'v8/tools/splaytree',\n  'v8/tools/codemap',\n  'v8/tools/csvparser',\n  'v8/tools/consarray',\n  'v8/tools/profile',\n  'v8/tools/profile_view',\n  'v8/tools/logreader',\n  'v8/tools/tickprocessor',\n  'v8/tools/SourceMap',\n  'v8/tools/tickprocessor-driver'\n];\nvar script = '';\n\nscriptFiles.forEach(function(s) {\n  script += process.binding('natives')[s] + '\\n';\n});\n\nconst tickArguments = [];\nif (process.platform === 'darwin') {\n  tickArguments.push('--mac');\n} else if (process.platform === 'win32') {\n  tickArguments.push('--windows');\n}\ntickArguments.push.apply(tickArguments, process.argv.slice(1));\nscript = `(function() {\n  arguments = ${JSON.stringify(tickArguments)};\n  ${script}\n})()`;\neval(script);\n",
  "internal/streams/lazy_transform": "// LazyTransform is a special type of Transform stream that is lazily loaded.\n// This is used for performance with bi-API-ship: when two APIs are available\n// for the stream, one conventional and one non-conventional.\n'use strict';\n\nconst stream = require('stream');\nconst util = require('util');\nconst crypto = require('crypto');\n\nmodule.exports = LazyTransform;\n\nfunction LazyTransform(options) {\n  this._options = options;\n  this.writable = true;\n  this.readable = true;\n}\nutil.inherits(LazyTransform, stream.Transform);\n\nfunction makeGetter(name) {\n  return function() {\n    stream.Transform.call(this, this._options);\n    this._writableState.decodeStrings = false;\n\n    if (!this._options || !this._options.defaultEncoding) {\n      this._writableState.defaultEncoding = crypto.DEFAULT_ENCODING;\n    }\n\n    return this[name];\n  };\n}\n\nfunction makeSetter(name) {\n  return function(val) {\n    Object.defineProperty(this, name, {\n      value: val,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  };\n}\n\nObject.defineProperties(LazyTransform.prototype, {\n  _readableState: {\n    get: makeGetter('_readableState'),\n    set: makeSetter('_readableState'),\n    configurable: true,\n    enumerable: true\n  },\n  _writableState: {\n    get: makeGetter('_writableState'),\n    set: makeSetter('_writableState'),\n    configurable: true,\n    enumerable: true\n  },\n  _transformState: {\n    get: makeGetter('_transformState'),\n    set: makeSetter('_transformState'),\n    configurable: true,\n    enumerable: true\n  }\n});\n",
  "internal/streams/BufferList": "'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v, next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v, next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    if (this.length === 1)\n      return this.head.data;\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n};\n",
  "internal/streams/legacy": "'use strict';\n\nconst EE = require('events');\nconst util = require('util');\n\nfunction Stream() {\n  EE.call(this);\n}\nutil.inherits(Stream, EE);\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nmodule.exports = Stream;\n",
  "internal/streams/destroy": "'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState &&\n    this._readableState.destroyed;\n  const writableDestroyed = this._writableState &&\n    this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err &&\n               (!this._writableState || !this._writableState.errorEmitted)) {\n      process.nextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, (err) => {\n    if (!cb && err) {\n      process.nextTick(emitErrorNT, this, err);\n      if (this._writableState) {\n        this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy,\n  undestroy\n};\n",
  "v8/tools/splaytree": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Constructs a Splay tree.  A splay tree is a self-balancing binary\n * search tree with the additional property that recently accessed\n * elements are quick to access again. It performs basic operations\n * such as insertion, look-up and removal in O(log(n)) amortized time.\n *\n * @constructor\n */\nfunction SplayTree() {\n};\n\n\n/**\n * Pointer to the root node of the tree.\n *\n * @type {SplayTree.Node}\n * @private\n */\nSplayTree.prototype.root_ = null;\n\n\n/**\n * @return {boolean} Whether the tree is empty.\n */\nSplayTree.prototype.isEmpty = function() {\n  return !this.root_;\n};\n\n\n\n/**\n * Inserts a node into the tree with the specified key and value if\n * the tree does not already contain a node with the specified key. If\n * the value is inserted, it becomes the root of the tree.\n *\n * @param {number} key Key to insert into the tree.\n * @param {*} value Value to insert into the tree.\n */\nSplayTree.prototype.insert = function(key, value) {\n  if (this.isEmpty()) {\n    this.root_ = new SplayTree.Node(key, value);\n    return;\n  }\n  // Splay on the key to move the last node on the search path for\n  // the key to the root of the tree.\n  this.splay_(key);\n  if (this.root_.key == key) {\n    return;\n  }\n  var node = new SplayTree.Node(key, value);\n  if (key > this.root_.key) {\n    node.left = this.root_;\n    node.right = this.root_.right;\n    this.root_.right = null;\n  } else {\n    node.right = this.root_;\n    node.left = this.root_.left;\n    this.root_.left = null;\n  }\n  this.root_ = node;\n};\n\n\n/**\n * Removes a node with the specified key from the tree if the tree\n * contains a node with this key. The removed node is returned. If the\n * key is not found, an exception is thrown.\n *\n * @param {number} key Key to find and remove from the tree.\n * @return {SplayTree.Node} The removed node.\n */\nSplayTree.prototype.remove = function(key) {\n  if (this.isEmpty()) {\n    throw Error('Key not found: ' + key);\n  }\n  this.splay_(key);\n  if (this.root_.key != key) {\n    throw Error('Key not found: ' + key);\n  }\n  var removed = this.root_;\n  if (!this.root_.left) {\n    this.root_ = this.root_.right;\n  } else {\n    var right = this.root_.right;\n    this.root_ = this.root_.left;\n    // Splay to make sure that the new root has an empty right child.\n    this.splay_(key);\n    // Insert the original right child as the right child of the new\n    // root.\n    this.root_.right = right;\n  }\n  return removed;\n};\n\n\n/**\n * Returns the node having the specified key or null if the tree doesn't contain\n * a node with the specified key.\n *\n * @param {number} key Key to find in the tree.\n * @return {SplayTree.Node} Node having the specified key.\n */\nSplayTree.prototype.find = function(key) {\n  if (this.isEmpty()) {\n    return null;\n  }\n  this.splay_(key);\n  return this.root_.key == key ? this.root_ : null;\n};\n\n\n/**\n * @return {SplayTree.Node} Node having the minimum key value.\n */\nSplayTree.prototype.findMin = function() {\n  if (this.isEmpty()) {\n    return null;\n  }\n  var current = this.root_;\n  while (current.left) {\n    current = current.left;\n  }\n  return current;\n};\n\n\n/**\n * @return {SplayTree.Node} Node having the maximum key value.\n */\nSplayTree.prototype.findMax = function(opt_startNode) {\n  if (this.isEmpty()) {\n    return null;\n  }\n  var current = opt_startNode || this.root_;\n  while (current.right) {\n    current = current.right;\n  }\n  return current;\n};\n\n\n/**\n * @return {SplayTree.Node} Node having the maximum key value that\n *     is less or equal to the specified key value.\n */\nSplayTree.prototype.findGreatestLessThan = function(key) {\n  if (this.isEmpty()) {\n    return null;\n  }\n  // Splay on the key to move the node with the given key or the last\n  // node on the search path to the top of the tree.\n  this.splay_(key);\n  // Now the result is either the root node or the greatest node in\n  // the left subtree.\n  if (this.root_.key <= key) {\n    return this.root_;\n  } else if (this.root_.left) {\n    return this.findMax(this.root_.left);\n  } else {\n    return null;\n  }\n};\n\n\n/**\n * @return {Array<*>} An array containing all the values of tree's nodes paired\n *     with keys.\n */\nSplayTree.prototype.exportKeysAndValues = function() {\n  var result = [];\n  this.traverse_(function(node) { result.push([node.key, node.value]); });\n  return result;\n};\n\n\n/**\n * @return {Array<*>} An array containing all the values of tree's nodes.\n */\nSplayTree.prototype.exportValues = function() {\n  var result = [];\n  this.traverse_(function(node) { result.push(node.value); });\n  return result;\n};\n\n\n/**\n * Perform the splay operation for the given key. Moves the node with\n * the given key to the top of the tree.  If no node has the given\n * key, the last node on the search path is moved to the top of the\n * tree. This is the simplified top-down splaying algorithm from:\n * \"Self-adjusting Binary Search Trees\" by Sleator and Tarjan\n *\n * @param {number} key Key to splay the tree on.\n * @private\n */\nSplayTree.prototype.splay_ = function(key) {\n  if (this.isEmpty()) {\n    return;\n  }\n  // Create a dummy node.  The use of the dummy node is a bit\n  // counter-intuitive: The right child of the dummy node will hold\n  // the L tree of the algorithm.  The left child of the dummy node\n  // will hold the R tree of the algorithm.  Using a dummy node, left\n  // and right will always be nodes and we avoid special cases.\n  var dummy, left, right;\n  dummy = left = right = new SplayTree.Node(null, null);\n  var current = this.root_;\n  while (true) {\n    if (key < current.key) {\n      if (!current.left) {\n        break;\n      }\n      if (key < current.left.key) {\n        // Rotate right.\n        var tmp = current.left;\n        current.left = tmp.right;\n        tmp.right = current;\n        current = tmp;\n        if (!current.left) {\n          break;\n        }\n      }\n      // Link right.\n      right.left = current;\n      right = current;\n      current = current.left;\n    } else if (key > current.key) {\n      if (!current.right) {\n        break;\n      }\n      if (key > current.right.key) {\n        // Rotate left.\n        var tmp = current.right;\n        current.right = tmp.left;\n        tmp.left = current;\n        current = tmp;\n        if (!current.right) {\n          break;\n        }\n      }\n      // Link left.\n      left.right = current;\n      left = current;\n      current = current.right;\n    } else {\n      break;\n    }\n  }\n  // Assemble.\n  left.right = current.left;\n  right.left = current.right;\n  current.left = dummy.right;\n  current.right = dummy.left;\n  this.root_ = current;\n};\n\n\n/**\n * Performs a preorder traversal of the tree.\n *\n * @param {function(SplayTree.Node)} f Visitor function.\n * @private\n */\nSplayTree.prototype.traverse_ = function(f) {\n  var nodesToVisit = [this.root_];\n  while (nodesToVisit.length > 0) {\n    var node = nodesToVisit.shift();\n    if (node == null) {\n      continue;\n    }\n    f(node);\n    nodesToVisit.push(node.left);\n    nodesToVisit.push(node.right);\n  }\n};\n\n\n/**\n * Constructs a Splay tree node.\n *\n * @param {number} key Key.\n * @param {*} value Value.\n */\nSplayTree.Node = function(key, value) {\n  this.key = key;\n  this.value = value;\n};\n\n\n/**\n * @type {SplayTree.Node}\n */\nSplayTree.Node.prototype.left = null;\n\n\n/**\n * @type {SplayTree.Node}\n */\nSplayTree.Node.prototype.right = null;\n",
  "v8/tools/codemap": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Constructs a mapper that maps addresses into code entries.\n *\n * @constructor\n */\nfunction CodeMap() {\n  /**\n   * Dynamic code entries. Used for JIT compiled code.\n   */\n  this.dynamics_ = new SplayTree();\n\n  /**\n   * Name generator for entries having duplicate names.\n   */\n  this.dynamicsNameGen_ = new CodeMap.NameGenerator();\n\n  /**\n   * Static code entries. Used for statically compiled code.\n   */\n  this.statics_ = new SplayTree();\n\n  /**\n   * Libraries entries. Used for the whole static code libraries.\n   */\n  this.libraries_ = new SplayTree();\n\n  /**\n   * Map of memory pages occupied with static code.\n   */\n  this.pages_ = [];\n};\n\n\n/**\n * The number of alignment bits in a page address.\n */\nCodeMap.PAGE_ALIGNMENT = 12;\n\n\n/**\n * Page size in bytes.\n */\nCodeMap.PAGE_SIZE =\n    1 << CodeMap.PAGE_ALIGNMENT;\n\n\n/**\n * Adds a dynamic (i.e. moveable and discardable) code entry.\n *\n * @param {number} start The starting address.\n * @param {CodeMap.CodeEntry} codeEntry Code entry object.\n */\nCodeMap.prototype.addCode = function(start, codeEntry) {\n  this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);\n  this.dynamics_.insert(start, codeEntry);\n};\n\n\n/**\n * Moves a dynamic code entry. Throws an exception if there is no dynamic\n * code entry with the specified starting address.\n *\n * @param {number} from The starting address of the entry being moved.\n * @param {number} to The destination address.\n */\nCodeMap.prototype.moveCode = function(from, to) {\n  var removedNode = this.dynamics_.remove(from);\n  this.deleteAllCoveredNodes_(this.dynamics_, to, to + removedNode.value.size);\n  this.dynamics_.insert(to, removedNode.value);\n};\n\n\n/**\n * Discards a dynamic code entry. Throws an exception if there is no dynamic\n * code entry with the specified starting address.\n *\n * @param {number} start The starting address of the entry being deleted.\n */\nCodeMap.prototype.deleteCode = function(start) {\n  var removedNode = this.dynamics_.remove(start);\n};\n\n\n/**\n * Adds a library entry.\n *\n * @param {number} start The starting address.\n * @param {CodeMap.CodeEntry} codeEntry Code entry object.\n */\nCodeMap.prototype.addLibrary = function(\n    start, codeEntry) {\n  this.markPages_(start, start + codeEntry.size);\n  this.libraries_.insert(start, codeEntry);\n};\n\n\n/**\n * Adds a static code entry.\n *\n * @param {number} start The starting address.\n * @param {CodeMap.CodeEntry} codeEntry Code entry object.\n */\nCodeMap.prototype.addStaticCode = function(\n    start, codeEntry) {\n  this.statics_.insert(start, codeEntry);\n};\n\n\n/**\n * @private\n */\nCodeMap.prototype.markPages_ = function(start, end) {\n  for (var addr = start; addr <= end;\n       addr += CodeMap.PAGE_SIZE) {\n    this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;\n  }\n};\n\n\n/**\n * @private\n */\nCodeMap.prototype.deleteAllCoveredNodes_ = function(tree, start, end) {\n  var to_delete = [];\n  var addr = end - 1;\n  while (addr >= start) {\n    var node = tree.findGreatestLessThan(addr);\n    if (!node) break;\n    var start2 = node.key, end2 = start2 + node.value.size;\n    if (start2 < end && start < end2) to_delete.push(start2);\n    addr = start2 - 1;\n  }\n  for (var i = 0, l = to_delete.length; i < l; ++i) tree.remove(to_delete[i]);\n};\n\n\n/**\n * @private\n */\nCodeMap.prototype.isAddressBelongsTo_ = function(addr, node) {\n  return addr >= node.key && addr < (node.key + node.value.size);\n};\n\n\n/**\n * @private\n */\nCodeMap.prototype.findInTree_ = function(tree, addr) {\n  var node = tree.findGreatestLessThan(addr);\n  return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;\n};\n\n\n/**\n * Finds a code entry that contains the specified address. Both static and\n * dynamic code entries are considered.\n *\n * @param {number} addr Address.\n */\nCodeMap.prototype.findEntry = function(addr) {\n  var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;\n  if (pageAddr in this.pages_) {\n    // Static code entries can contain \"holes\" of unnamed code.\n    // In this case, the whole library is assigned to this address.\n    return this.findInTree_(this.statics_, addr) ||\n        this.findInTree_(this.libraries_, addr);\n  }\n  var min = this.dynamics_.findMin();\n  var max = this.dynamics_.findMax();\n  if (max != null && addr < (max.key + max.value.size) && addr >= min.key) {\n    var dynaEntry = this.findInTree_(this.dynamics_, addr);\n    if (dynaEntry == null) return null;\n    // Dedupe entry name.\n    if (!dynaEntry.nameUpdated_) {\n      dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);\n      dynaEntry.nameUpdated_ = true;\n    }\n    return dynaEntry;\n  }\n  return null;\n};\n\n\n/**\n * Returns a dynamic code entry using its starting address.\n *\n * @param {number} addr Address.\n */\nCodeMap.prototype.findDynamicEntryByStartAddress =\n    function(addr) {\n  var node = this.dynamics_.find(addr);\n  return node ? node.value : null;\n};\n\n\n/**\n * Returns an array of all dynamic code entries.\n */\nCodeMap.prototype.getAllDynamicEntries = function() {\n  return this.dynamics_.exportValues();\n};\n\n\n/**\n * Returns an array of pairs of all dynamic code entries and their addresses.\n */\nCodeMap.prototype.getAllDynamicEntriesWithAddresses = function() {\n  return this.dynamics_.exportKeysAndValues();\n};\n\n\n/**\n * Returns an array of all static code entries.\n */\nCodeMap.prototype.getAllStaticEntries = function() {\n  return this.statics_.exportValues();\n};\n\n\n/**\n * Returns an array of pairs of all static code entries and their addresses.\n */\nCodeMap.prototype.getAllStaticEntriesWithAddresses = function() {\n  return this.statics_.exportKeysAndValues();\n};\n\n\n/**\n * Returns an array of all libraries entries.\n */\nCodeMap.prototype.getAllLibrariesEntries = function() {\n  return this.libraries_.exportValues();\n};\n\n\n/**\n * Creates a code entry object.\n *\n * @param {number} size Code entry size in bytes.\n * @param {string} opt_name Code entry name.\n * @param {string} opt_type Code entry type, e.g. SHARED_LIB, CPP.\n * @constructor\n */\nCodeMap.CodeEntry = function(size, opt_name, opt_type) {\n  this.size = size;\n  this.name = opt_name || '';\n  this.type = opt_type || '';\n  this.nameUpdated_ = false;\n};\n\n\nCodeMap.CodeEntry.prototype.getName = function() {\n  return this.name;\n};\n\n\nCodeMap.CodeEntry.prototype.toString = function() {\n  return this.name + ': ' + this.size.toString(16);\n};\n\n\nCodeMap.NameGenerator = function() {\n  this.knownNames_ = {};\n};\n\n\nCodeMap.NameGenerator.prototype.getName = function(name) {\n  if (!(name in this.knownNames_)) {\n    this.knownNames_[name] = 0;\n    return name;\n  }\n  var count = ++this.knownNames_[name];\n  return name + ' {' + count + '}';\n};\n",
  "v8/tools/consarray": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Constructs a ConsArray object. It is used mainly for tree traversal.\n * In this use case we have lots of arrays that we need to iterate\n * sequentally. The internal Array implementation is horribly slow\n * when concatenating on large (10K items) arrays due to memory copying.\n * That's why we avoid copying memory and insead build a linked list\n * of arrays to iterate through.\n *\n * @constructor\n */\nfunction ConsArray() {\n  this.tail_ = new ConsArray.Cell(null, null);\n  this.currCell_ = this.tail_;\n  this.currCellPos_ = 0;\n};\n\n\n/**\n * Concatenates another array for iterating. Empty arrays are ignored.\n * This operation can be safely performed during ongoing ConsArray\n * iteration.\n *\n * @param {Array} arr Array to concatenate.\n */\nConsArray.prototype.concat = function(arr) {\n  if (arr.length > 0) {\n    this.tail_.data = arr;\n    this.tail_ = this.tail_.next = new ConsArray.Cell(null, null);\n  }\n};\n\n\n/**\n * Whether the end of iteration is reached.\n */\nConsArray.prototype.atEnd = function() {\n  return this.currCell_ === null ||\n      this.currCell_.data === null ||\n      this.currCellPos_ >= this.currCell_.data.length;\n};\n\n\n/**\n * Returns the current item, moves to the next one.\n */\nConsArray.prototype.next = function() {\n  var result = this.currCell_.data[this.currCellPos_++];\n  if (this.currCellPos_ >= this.currCell_.data.length) {\n    this.currCell_ = this.currCell_.next;\n    this.currCellPos_ = 0;\n  }\n  return result;\n};\n\n\n/**\n * A cell object used for constructing a list in ConsArray.\n *\n * @constructor\n */\nConsArray.Cell = function(data, next) {\n  this.data = data;\n  this.next = next;\n};\n",
  "v8/tools/csvparser": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Creates a CSV lines parser.\n */\nfunction CsvParser() {\n};\n\n\n/**\n * A regex for matching a CSV field.\n * @private\n */\nCsvParser.CSV_FIELD_RE_ = /^\"((?:[^\"]|\"\")*)\"|([^,]*)/;\n\n\n/**\n * A regex for matching a double quote.\n * @private\n */\nCsvParser.DOUBLE_QUOTE_RE_ = /\"\"/g;\n\n\n/**\n * Parses a line of CSV-encoded values. Returns an array of fields.\n *\n * @param {string} line Input line.\n */\nCsvParser.prototype.parseLine = function(line) {\n  var fieldRe = CsvParser.CSV_FIELD_RE_;\n  var doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;\n  var pos = 0;\n  var endPos = line.length;\n  var fields = [];\n  if (endPos > 0) {\n    do {\n      var fieldMatch = fieldRe.exec(line.substr(pos));\n      if (typeof fieldMatch[1] === \"string\") {\n        var field = fieldMatch[1];\n        pos += field.length + 3;  // Skip comma and quotes.\n        fields.push(field.replace(doubleQuoteRe, '\"'));\n      } else {\n        // The second field pattern will match anything, thus\n        // in the worst case the match will be an empty string.\n        var field = fieldMatch[2];\n        pos += field.length + 1;  // Skip comma.\n        fields.push(field);\n      }\n    } while (pos <= endPos);\n  }\n  return fields;\n};\n",
  "v8/tools/profile": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Creates a profile object for processing profiling-related events\n * and calculating function execution times.\n *\n * @constructor\n */\nfunction Profile() {\n  this.codeMap_ = new CodeMap();\n  this.topDownTree_ = new CallTree();\n  this.bottomUpTree_ = new CallTree();\n  this.c_entries_ = {};\n};\n\n\n/**\n * Returns whether a function with the specified name must be skipped.\n * Should be overriden by subclasses.\n *\n * @param {string} name Function name.\n */\nProfile.prototype.skipThisFunction = function(name) {\n  return false;\n};\n\n\n/**\n * Enum for profiler operations that involve looking up existing\n * code entries.\n *\n * @enum {number}\n */\nProfile.Operation = {\n  MOVE: 0,\n  DELETE: 1,\n  TICK: 2\n};\n\n\n/**\n * Enum for code state regarding its dynamic optimization.\n *\n * @enum {number}\n */\nProfile.CodeState = {\n  COMPILED: 0,\n  OPTIMIZABLE: 1,\n  OPTIMIZED: 2\n};\n\n\n/**\n * Called whenever the specified operation has failed finding a function\n * containing the specified address. Should be overriden by subclasses.\n * See the Profile.Operation enum for the list of\n * possible operations.\n *\n * @param {number} operation Operation.\n * @param {number} addr Address of the unknown code.\n * @param {number} opt_stackPos If an unknown address is encountered\n *     during stack strace processing, specifies a position of the frame\n *     containing the address.\n */\nProfile.prototype.handleUnknownCode = function(\n    operation, addr, opt_stackPos) {\n};\n\n\n/**\n * Registers a library.\n *\n * @param {string} name Code entry name.\n * @param {number} startAddr Starting address.\n * @param {number} endAddr Ending address.\n */\nProfile.prototype.addLibrary = function(\n    name, startAddr, endAddr) {\n  var entry = new CodeMap.CodeEntry(\n      endAddr - startAddr, name, 'SHARED_LIB');\n  this.codeMap_.addLibrary(startAddr, entry);\n  return entry;\n};\n\n\n/**\n * Registers statically compiled code entry.\n *\n * @param {string} name Code entry name.\n * @param {number} startAddr Starting address.\n * @param {number} endAddr Ending address.\n */\nProfile.prototype.addStaticCode = function(\n    name, startAddr, endAddr) {\n  var entry = new CodeMap.CodeEntry(\n      endAddr - startAddr, name, 'CPP');\n  this.codeMap_.addStaticCode(startAddr, entry);\n  return entry;\n};\n\n\n/**\n * Registers dynamic (JIT-compiled) code entry.\n *\n * @param {string} type Code entry type.\n * @param {string} name Code entry name.\n * @param {number} start Starting address.\n * @param {number} size Code entry size.\n */\nProfile.prototype.addCode = function(\n    type, name, start, size) {\n  var entry = new Profile.DynamicCodeEntry(size, type, name);\n  this.codeMap_.addCode(start, entry);\n  return entry;\n};\n\n\n/**\n * Registers dynamic (JIT-compiled) code entry.\n *\n * @param {string} type Code entry type.\n * @param {string} name Code entry name.\n * @param {number} start Starting address.\n * @param {number} size Code entry size.\n * @param {number} funcAddr Shared function object address.\n * @param {Profile.CodeState} state Optimization state.\n */\nProfile.prototype.addFuncCode = function(\n    type, name, start, size, funcAddr, state) {\n  // As code and functions are in the same address space,\n  // it is safe to put them in a single code map.\n  var func = this.codeMap_.findDynamicEntryByStartAddress(funcAddr);\n  if (!func) {\n    func = new Profile.FunctionEntry(name);\n    this.codeMap_.addCode(funcAddr, func);\n  } else if (func.name !== name) {\n    // Function object has been overwritten with a new one.\n    func.name = name;\n  }\n  var entry = this.codeMap_.findDynamicEntryByStartAddress(start);\n  if (entry) {\n    if (entry.size === size && entry.func === func) {\n      // Entry state has changed.\n      entry.state = state;\n    }\n  } else {\n    entry = new Profile.DynamicFuncCodeEntry(size, type, func, state);\n    this.codeMap_.addCode(start, entry);\n  }\n  return entry;\n};\n\n\n/**\n * Reports about moving of a dynamic code entry.\n *\n * @param {number} from Current code entry address.\n * @param {number} to New code entry address.\n */\nProfile.prototype.moveCode = function(from, to) {\n  try {\n    this.codeMap_.moveCode(from, to);\n  } catch (e) {\n    this.handleUnknownCode(Profile.Operation.MOVE, from);\n  }\n};\n\n\n/**\n * Reports about deletion of a dynamic code entry.\n *\n * @param {number} start Starting address.\n */\nProfile.prototype.deleteCode = function(start) {\n  try {\n    this.codeMap_.deleteCode(start);\n  } catch (e) {\n    this.handleUnknownCode(Profile.Operation.DELETE, start);\n  }\n};\n\n\n/**\n * Reports about moving of a dynamic code entry.\n *\n * @param {number} from Current code entry address.\n * @param {number} to New code entry address.\n */\nProfile.prototype.moveFunc = function(from, to) {\n  if (this.codeMap_.findDynamicEntryByStartAddress(from)) {\n    this.codeMap_.moveCode(from, to);\n  }\n};\n\n\n/**\n * Retrieves a code entry by an address.\n *\n * @param {number} addr Entry address.\n */\nProfile.prototype.findEntry = function(addr) {\n  return this.codeMap_.findEntry(addr);\n};\n\n\n/**\n * Records a tick event. Stack must contain a sequence of\n * addresses starting with the program counter value.\n *\n * @param {Array<number>} stack Stack sample.\n */\nProfile.prototype.recordTick = function(stack) {\n  var processedStack = this.resolveAndFilterFuncs_(stack);\n  this.bottomUpTree_.addPath(processedStack);\n  processedStack.reverse();\n  this.topDownTree_.addPath(processedStack);\n};\n\n\n/**\n * Translates addresses into function names and filters unneeded\n * functions.\n *\n * @param {Array<number>} stack Stack sample.\n */\nProfile.prototype.resolveAndFilterFuncs_ = function(stack) {\n  var result = [];\n  var last_seen_c_function = '';\n  var look_for_first_c_function = false;\n  for (var i = 0; i < stack.length; ++i) {\n    var entry = this.codeMap_.findEntry(stack[i]);\n    if (entry) {\n      var name = entry.getName();\n      if (i === 0 && (entry.type === 'CPP' || entry.type === 'SHARED_LIB')) {\n        look_for_first_c_function = true;\n      }\n      if (look_for_first_c_function && entry.type === 'CPP') {\n        last_seen_c_function = name;\n      }\n      if (!this.skipThisFunction(name)) {\n        result.push(name);\n      }\n    } else {\n      this.handleUnknownCode(Profile.Operation.TICK, stack[i], i);\n      if (i === 0) result.push(\"UNKNOWN\");\n    }\n    if (look_for_first_c_function &&\n        i > 0 &&\n        (!entry || entry.type !== 'CPP') &&\n        last_seen_c_function !== '') {\n      if (this.c_entries_[last_seen_c_function] === undefined) {\n        this.c_entries_[last_seen_c_function] = 0;\n      }\n      this.c_entries_[last_seen_c_function]++;\n      look_for_first_c_function = false;  // Found it, we're done.\n    }\n  }\n  return result;\n};\n\n\n/**\n * Performs a BF traversal of the top down call graph.\n *\n * @param {function(CallTree.Node)} f Visitor function.\n */\nProfile.prototype.traverseTopDownTree = function(f) {\n  this.topDownTree_.traverse(f);\n};\n\n\n/**\n * Performs a BF traversal of the bottom up call graph.\n *\n * @param {function(CallTree.Node)} f Visitor function.\n */\nProfile.prototype.traverseBottomUpTree = function(f) {\n  this.bottomUpTree_.traverse(f);\n};\n\n\n/**\n * Calculates a top down profile for a node with the specified label.\n * If no name specified, returns the whole top down calls tree.\n *\n * @param {string} opt_label Node label.\n */\nProfile.prototype.getTopDownProfile = function(opt_label) {\n  return this.getTreeProfile_(this.topDownTree_, opt_label);\n};\n\n\n/**\n * Calculates a bottom up profile for a node with the specified label.\n * If no name specified, returns the whole bottom up calls tree.\n *\n * @param {string} opt_label Node label.\n */\nProfile.prototype.getBottomUpProfile = function(opt_label) {\n  return this.getTreeProfile_(this.bottomUpTree_, opt_label);\n};\n\n\n/**\n * Helper function for calculating a tree profile.\n *\n * @param {Profile.CallTree} tree Call tree.\n * @param {string} opt_label Node label.\n */\nProfile.prototype.getTreeProfile_ = function(tree, opt_label) {\n  if (!opt_label) {\n    tree.computeTotalWeights();\n    return tree;\n  } else {\n    var subTree = tree.cloneSubtree(opt_label);\n    subTree.computeTotalWeights();\n    return subTree;\n  }\n};\n\n\n/**\n * Calculates a flat profile of callees starting from a node with\n * the specified label. If no name specified, starts from the root.\n *\n * @param {string} opt_label Starting node label.\n */\nProfile.prototype.getFlatProfile = function(opt_label) {\n  var counters = new CallTree();\n  var rootLabel = opt_label || CallTree.ROOT_NODE_LABEL;\n  var precs = {};\n  precs[rootLabel] = 0;\n  var root = counters.findOrAddChild(rootLabel);\n\n  this.topDownTree_.computeTotalWeights();\n  this.topDownTree_.traverseInDepth(\n    function onEnter(node) {\n      if (!(node.label in precs)) {\n        precs[node.label] = 0;\n      }\n      var nodeLabelIsRootLabel = node.label == rootLabel;\n      if (nodeLabelIsRootLabel || precs[rootLabel] > 0) {\n        if (precs[rootLabel] == 0) {\n          root.selfWeight += node.selfWeight;\n          root.totalWeight += node.totalWeight;\n        } else {\n          var rec = root.findOrAddChild(node.label);\n          rec.selfWeight += node.selfWeight;\n          if (nodeLabelIsRootLabel || precs[node.label] == 0) {\n            rec.totalWeight += node.totalWeight;\n          }\n        }\n        precs[node.label]++;\n      }\n    },\n    function onExit(node) {\n      if (node.label == rootLabel || precs[rootLabel] > 0) {\n        precs[node.label]--;\n      }\n    },\n    null);\n\n  if (!opt_label) {\n    // If we have created a flat profile for the whole program, we don't\n    // need an explicit root in it. Thus, replace the counters tree\n    // root with the node corresponding to the whole program.\n    counters.root_ = root;\n  } else {\n    // Propagate weights so percents can be calculated correctly.\n    counters.getRoot().selfWeight = root.selfWeight;\n    counters.getRoot().totalWeight = root.totalWeight;\n  }\n  return counters;\n};\n\n\nProfile.CEntryNode = function(name, ticks) {\n  this.name = name;\n  this.ticks = ticks;\n}\n\n\nProfile.prototype.getCEntryProfile = function() {\n  var result = [new Profile.CEntryNode(\"TOTAL\", 0)];\n  var total_ticks = 0;\n  for (var f in this.c_entries_) {\n    var ticks = this.c_entries_[f];\n    total_ticks += ticks;\n    result.push(new Profile.CEntryNode(f, ticks));\n  }\n  result[0].ticks = total_ticks;  // Sorting will keep this at index 0.\n  result.sort(function(n1, n2) {\n    return n2.ticks - n1.ticks || (n2.name < n1.name ? -1 : 1)\n  });\n  return result;\n}\n\n\n/**\n * Cleans up function entries that are not referenced by code entries.\n */\nProfile.prototype.cleanUpFuncEntries = function() {\n  var referencedFuncEntries = [];\n  var entries = this.codeMap_.getAllDynamicEntriesWithAddresses();\n  for (var i = 0, l = entries.length; i < l; ++i) {\n    if (entries[i][1].constructor === Profile.FunctionEntry) {\n      entries[i][1].used = false;\n    }\n  }\n  for (var i = 0, l = entries.length; i < l; ++i) {\n    if (\"func\" in entries[i][1]) {\n      entries[i][1].func.used = true;\n    }\n  }\n  for (var i = 0, l = entries.length; i < l; ++i) {\n    if (entries[i][1].constructor === Profile.FunctionEntry &&\n        !entries[i][1].used) {\n      this.codeMap_.deleteCode(entries[i][0]);\n    }\n  }\n};\n\n\n/**\n * Creates a dynamic code entry.\n *\n * @param {number} size Code size.\n * @param {string} type Code type.\n * @param {string} name Function name.\n * @constructor\n */\nProfile.DynamicCodeEntry = function(size, type, name) {\n  CodeMap.CodeEntry.call(this, size, name, type);\n};\n\n\n/**\n * Returns node name.\n */\nProfile.DynamicCodeEntry.prototype.getName = function() {\n  return this.type + ': ' + this.name;\n};\n\n\n/**\n * Returns raw node name (without type decoration).\n */\nProfile.DynamicCodeEntry.prototype.getRawName = function() {\n  return this.name;\n};\n\n\nProfile.DynamicCodeEntry.prototype.isJSFunction = function() {\n  return false;\n};\n\n\nProfile.DynamicCodeEntry.prototype.toString = function() {\n  return this.getName() + ': ' + this.size.toString(16);\n};\n\n\n/**\n * Creates a dynamic code entry.\n *\n * @param {number} size Code size.\n * @param {string} type Code type.\n * @param {Profile.FunctionEntry} func Shared function entry.\n * @param {Profile.CodeState} state Code optimization state.\n * @constructor\n */\nProfile.DynamicFuncCodeEntry = function(size, type, func, state) {\n  CodeMap.CodeEntry.call(this, size, '', type);\n  this.func = func;\n  this.state = state;\n};\n\nProfile.DynamicFuncCodeEntry.STATE_PREFIX = [\"\", \"~\", \"*\"];\n\n/**\n * Returns node name.\n */\nProfile.DynamicFuncCodeEntry.prototype.getName = function() {\n  var name = this.func.getName();\n  return this.type + ': ' + Profile.DynamicFuncCodeEntry.STATE_PREFIX[this.state] + name;\n};\n\n\n/**\n * Returns raw node name (without type decoration).\n */\nProfile.DynamicFuncCodeEntry.prototype.getRawName = function() {\n  return this.func.getName();\n};\n\n\nProfile.DynamicFuncCodeEntry.prototype.isJSFunction = function() {\n  return true;\n};\n\n\nProfile.DynamicFuncCodeEntry.prototype.toString = function() {\n  return this.getName() + ': ' + this.size.toString(16);\n};\n\n\n/**\n * Creates a shared function object entry.\n *\n * @param {string} name Function name.\n * @constructor\n */\nProfile.FunctionEntry = function(name) {\n  CodeMap.CodeEntry.call(this, 0, name);\n};\n\n\n/**\n * Returns node name.\n */\nProfile.FunctionEntry.prototype.getName = function() {\n  var name = this.name;\n  if (name.length == 0) {\n    name = '<anonymous>';\n  } else if (name.charAt(0) == ' ') {\n    // An anonymous function with location: \" aaa.js:10\".\n    name = '<anonymous>' + name;\n  }\n  return name;\n};\n\nProfile.FunctionEntry.prototype.toString = CodeMap.CodeEntry.prototype.toString;\n\n/**\n * Constructs a call graph.\n *\n * @constructor\n */\nfunction CallTree() {\n  this.root_ = new CallTree.Node(\n      CallTree.ROOT_NODE_LABEL);\n};\n\n\n/**\n * The label of the root node.\n */\nCallTree.ROOT_NODE_LABEL = '';\n\n\n/**\n * @private\n */\nCallTree.prototype.totalsComputed_ = false;\n\n\n/**\n * Returns the tree root.\n */\nCallTree.prototype.getRoot = function() {\n  return this.root_;\n};\n\n\n/**\n * Adds the specified call path, constructing nodes as necessary.\n *\n * @param {Array<string>} path Call path.\n */\nCallTree.prototype.addPath = function(path) {\n  if (path.length == 0) {\n    return;\n  }\n  var curr = this.root_;\n  for (var i = 0; i < path.length; ++i) {\n    curr = curr.findOrAddChild(path[i]);\n  }\n  curr.selfWeight++;\n  this.totalsComputed_ = false;\n};\n\n\n/**\n * Finds an immediate child of the specified parent with the specified\n * label, creates a child node if necessary. If a parent node isn't\n * specified, uses tree root.\n *\n * @param {string} label Child node label.\n */\nCallTree.prototype.findOrAddChild = function(label) {\n  return this.root_.findOrAddChild(label);\n};\n\n\n/**\n * Creates a subtree by cloning and merging all subtrees rooted at nodes\n * with a given label. E.g. cloning the following call tree on label 'A'\n * will give the following result:\n *\n *           <A>--<B>                                     <B>\n *          /                                            /\n *     <root>             == clone on 'A' ==>  <root>--<A>\n *          \\                                            \\\n *           <C>--<A>--<D>                                <D>\n *\n * And <A>'s selfWeight will be the sum of selfWeights of <A>'s from the\n * source call tree.\n *\n * @param {string} label The label of the new root node.\n */\nCallTree.prototype.cloneSubtree = function(label) {\n  var subTree = new CallTree();\n  this.traverse(function(node, parent) {\n    if (!parent && node.label != label) {\n      return null;\n    }\n    var child = (parent ? parent : subTree).findOrAddChild(node.label);\n    child.selfWeight += node.selfWeight;\n    return child;\n  });\n  return subTree;\n};\n\n\n/**\n * Computes total weights in the call graph.\n */\nCallTree.prototype.computeTotalWeights = function() {\n  if (this.totalsComputed_) {\n    return;\n  }\n  this.root_.computeTotalWeight();\n  this.totalsComputed_ = true;\n};\n\n\n/**\n * Traverses the call graph in preorder. This function can be used for\n * building optionally modified tree clones. This is the boilerplate code\n * for this scenario:\n *\n * callTree.traverse(function(node, parentClone) {\n *   var nodeClone = cloneNode(node);\n *   if (parentClone)\n *     parentClone.addChild(nodeClone);\n *   return nodeClone;\n * });\n *\n * @param {function(CallTree.Node, *)} f Visitor function.\n *    The second parameter is the result of calling 'f' on the parent node.\n */\nCallTree.prototype.traverse = function(f) {\n  var pairsToProcess = new ConsArray();\n  pairsToProcess.concat([{node: this.root_, param: null}]);\n  while (!pairsToProcess.atEnd()) {\n    var pair = pairsToProcess.next();\n    var node = pair.node;\n    var newParam = f(node, pair.param);\n    var morePairsToProcess = [];\n    node.forEachChild(function (child) {\n        morePairsToProcess.push({node: child, param: newParam}); });\n    pairsToProcess.concat(morePairsToProcess);\n  }\n};\n\n\n/**\n * Performs an indepth call graph traversal.\n *\n * @param {function(CallTree.Node)} enter A function called\n *     prior to visiting node's children.\n * @param {function(CallTree.Node)} exit A function called\n *     after visiting node's children.\n */\nCallTree.prototype.traverseInDepth = function(enter, exit) {\n  function traverse(node) {\n    enter(node);\n    node.forEachChild(traverse);\n    exit(node);\n  }\n  traverse(this.root_);\n};\n\n\n/**\n * Constructs a call graph node.\n *\n * @param {string} label Node label.\n * @param {CallTree.Node} opt_parent Node parent.\n */\nCallTree.Node = function(label, opt_parent) {\n  this.label = label;\n  this.parent = opt_parent;\n  this.children = {};\n};\n\n\n/**\n * Node self weight (how many times this node was the last node in\n * a call path).\n * @type {number}\n */\nCallTree.Node.prototype.selfWeight = 0;\n\n\n/**\n * Node total weight (includes weights of all children).\n * @type {number}\n */\nCallTree.Node.prototype.totalWeight = 0;\n\n\n/**\n * Adds a child node.\n *\n * @param {string} label Child node label.\n */\nCallTree.Node.prototype.addChild = function(label) {\n  var child = new CallTree.Node(label, this);\n  this.children[label] = child;\n  return child;\n};\n\n\n/**\n * Computes node's total weight.\n */\nCallTree.Node.prototype.computeTotalWeight =\n    function() {\n  var totalWeight = this.selfWeight;\n  this.forEachChild(function(child) {\n      totalWeight += child.computeTotalWeight(); });\n  return this.totalWeight = totalWeight;\n};\n\n\n/**\n * Returns all node's children as an array.\n */\nCallTree.Node.prototype.exportChildren = function() {\n  var result = [];\n  this.forEachChild(function (node) { result.push(node); });\n  return result;\n};\n\n\n/**\n * Finds an immediate child with the specified label.\n *\n * @param {string} label Child node label.\n */\nCallTree.Node.prototype.findChild = function(label) {\n  return this.children[label] || null;\n};\n\n\n/**\n * Finds an immediate child with the specified label, creates a child\n * node if necessary.\n *\n * @param {string} label Child node label.\n */\nCallTree.Node.prototype.findOrAddChild = function(label) {\n  return this.findChild(label) || this.addChild(label);\n};\n\n\n/**\n * Calls the specified function for every child.\n *\n * @param {function(CallTree.Node)} f Visitor function.\n */\nCallTree.Node.prototype.forEachChild = function(f) {\n  for (var c in this.children) {\n    f(this.children[c]);\n  }\n};\n\n\n/**\n * Walks up from the current node up to the call tree root.\n *\n * @param {function(CallTree.Node)} f Visitor function.\n */\nCallTree.Node.prototype.walkUpToRoot = function(f) {\n  for (var curr = this; curr != null; curr = curr.parent) {\n    f(curr);\n  }\n};\n\n\n/**\n * Tries to find a node with the specified path.\n *\n * @param {Array<string>} labels The path.\n * @param {function(CallTree.Node)} opt_f Visitor function.\n */\nCallTree.Node.prototype.descendToChild = function(\n    labels, opt_f) {\n  for (var pos = 0, curr = this; pos < labels.length && curr != null; pos++) {\n    var child = curr.findChild(labels[pos]);\n    if (opt_f) {\n      opt_f(child, pos);\n    }\n    curr = child;\n  }\n  return curr;\n};\n",
  "v8/tools/profile_view": "// Copyright 2009 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n/**\n * Creates a Profile View builder object.\n *\n * @param {number} samplingRate Number of ms between profiler ticks.\n * @constructor\n */\nfunction ViewBuilder(samplingRate) {\n  this.samplingRate = samplingRate;\n};\n\n\n/**\n * Builds a profile view for the specified call tree.\n *\n * @param {CallTree} callTree A call tree.\n * @param {boolean} opt_bottomUpViewWeights Whether remapping\n *     of self weights for a bottom up view is needed.\n */\nViewBuilder.prototype.buildView = function(\n    callTree, opt_bottomUpViewWeights) {\n  var head;\n  var samplingRate = this.samplingRate;\n  var createViewNode = this.createViewNode;\n  callTree.traverse(function(node, viewParent) {\n    var totalWeight = node.totalWeight * samplingRate;\n    var selfWeight = node.selfWeight * samplingRate;\n    if (opt_bottomUpViewWeights === true) {\n      if (viewParent === head) {\n        selfWeight = totalWeight;\n      } else {\n        selfWeight = 0;\n      }\n    }\n    var viewNode = createViewNode(node.label, totalWeight, selfWeight, head);\n    if (viewParent) {\n      viewParent.addChild(viewNode);\n    } else {\n      head = viewNode;\n    }\n    return viewNode;\n  });\n  var view = this.createView(head);\n  return view;\n};\n\n\n/**\n * Factory method for a profile view.\n *\n * @param {ProfileView.Node} head View head node.\n * @return {ProfileView} Profile view.\n */\nViewBuilder.prototype.createView = function(head) {\n  return new ProfileView(head);\n};\n\n\n/**\n * Factory method for a profile view node.\n *\n * @param {string} internalFuncName A fully qualified function name.\n * @param {number} totalTime Amount of time that application spent in the\n *     corresponding function and its descendants (not that depending on\n *     profile they can be either callees or callers.)\n * @param {number} selfTime Amount of time that application spent in the\n *     corresponding function only.\n * @param {ProfileView.Node} head Profile view head.\n * @return {ProfileView.Node} Profile view node.\n */\nViewBuilder.prototype.createViewNode = function(\n    funcName, totalTime, selfTime, head) {\n  return new ProfileView.Node(\n      funcName, totalTime, selfTime, head);\n};\n\n\n/**\n * Creates a Profile View object. It allows to perform sorting\n * and filtering actions on the profile.\n *\n * @param {ProfileView.Node} head Head (root) node.\n * @constructor\n */\nfunction ProfileView(head) {\n  this.head = head;\n};\n\n\n/**\n * Sorts the profile view using the specified sort function.\n *\n * @param {function(ProfileView.Node,\n *     ProfileView.Node):number} sortFunc A sorting\n *     functions. Must comply with Array.sort sorting function requirements.\n */\nProfileView.prototype.sort = function(sortFunc) {\n  this.traverse(function (node) {\n    node.sortChildren(sortFunc);\n  });\n};\n\n\n/**\n * Traverses profile view nodes in preorder.\n *\n * @param {function(ProfileView.Node)} f Visitor function.\n */\nProfileView.prototype.traverse = function(f) {\n  var nodesToTraverse = new ConsArray();\n  nodesToTraverse.concat([this.head]);\n  while (!nodesToTraverse.atEnd()) {\n    var node = nodesToTraverse.next();\n    f(node);\n    nodesToTraverse.concat(node.children);\n  }\n};\n\n\n/**\n * Constructs a Profile View node object. Each node object corresponds to\n * a function call.\n *\n * @param {string} internalFuncName A fully qualified function name.\n * @param {number} totalTime Amount of time that application spent in the\n *     corresponding function and its descendants (not that depending on\n *     profile they can be either callees or callers.)\n * @param {number} selfTime Amount of time that application spent in the\n *     corresponding function only.\n * @param {ProfileView.Node} head Profile view head.\n * @constructor\n */\nProfileView.Node = function(\n    internalFuncName, totalTime, selfTime, head) {\n  this.internalFuncName = internalFuncName;\n  this.totalTime = totalTime;\n  this.selfTime = selfTime;\n  this.head = head;\n  this.parent = null;\n  this.children = [];\n};\n\n\n/**\n * Returns a share of the function's total time in its parent's total time.\n */\nProfileView.Node.prototype.__defineGetter__(\n    'parentTotalPercent',\n    function() { return this.totalTime /\n      (this.parent ? this.parent.totalTime : this.totalTime) * 100.0; });\n\n\n/**\n * Adds a child to the node.\n *\n * @param {ProfileView.Node} node Child node.\n */\nProfileView.Node.prototype.addChild = function(node) {\n  node.parent = this;\n  this.children.push(node);\n};\n\n\n/**\n * Sorts all the node's children recursively.\n *\n * @param {function(ProfileView.Node,\n *     ProfileView.Node):number} sortFunc A sorting\n *     functions. Must comply with Array.sort sorting function requirements.\n */\nProfileView.Node.prototype.sortChildren = function(\n    sortFunc) {\n  this.children.sort(sortFunc);\n};\n",
  "v8/tools/logreader": "// Copyright 2011 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * @fileoverview Log Reader is used to process log file produced by V8.\n */\n\n\n/**\n * Base class for processing log files.\n *\n * @param {Array.<Object>} dispatchTable A table used for parsing and processing\n *     log records.\n * @param {boolean} timedRange Ignore ticks outside timed range.\n * @param {boolean} pairwiseTimedRange Ignore ticks outside pairs of timer\n *     markers.\n * @constructor\n */\nfunction LogReader(dispatchTable, timedRange, pairwiseTimedRange) {\n  /**\n   * @type {Array.<Object>}\n   */\n  this.dispatchTable_ = dispatchTable;\n\n  /**\n   * @type {boolean}\n   */\n  this.timedRange_ = timedRange;\n\n  /**\n   * @type {boolean}\n   */\n  this.pairwiseTimedRange_ = pairwiseTimedRange;\n  if (pairwiseTimedRange) {\n    this.timedRange_ = true;\n  }\n\n  /**\n   * Current line.\n   * @type {number}\n   */\n  this.lineNum_ = 0;\n\n  /**\n   * CSV lines parser.\n   * @type {CsvParser}\n   */\n  this.csvParser_ = new CsvParser();\n\n  /**\n   * Keeps track of whether we've seen a \"current-time\" tick yet.\n   * @type {boolean}\n   */\n  this.hasSeenTimerMarker_ = false;\n\n  /**\n   * List of log lines seen since last \"current-time\" tick.\n   * @type {Array.<String>}\n   */\n  this.logLinesSinceLastTimerMarker_ = [];\n};\n\n\n/**\n * Used for printing error messages.\n *\n * @param {string} str Error message.\n */\nLogReader.prototype.printError = function(str) {\n  // Do nothing.\n};\n\n\n/**\n * Processes a portion of V8 profiler event log.\n *\n * @param {string} chunk A portion of log.\n */\nLogReader.prototype.processLogChunk = function(chunk) {\n  this.processLog_(chunk.split('\\n'));\n};\n\n\n/**\n * Processes a line of V8 profiler event log.\n *\n * @param {string} line A line of log.\n */\nLogReader.prototype.processLogLine = function(line) {\n  if (!this.timedRange_) {\n    this.processLog_([line]);\n    return;\n  }\n  if (line.startsWith(\"current-time\")) {\n    if (this.hasSeenTimerMarker_) {\n      this.processLog_(this.logLinesSinceLastTimerMarker_);\n      this.logLinesSinceLastTimerMarker_ = [];\n      // In pairwise mode, a \"current-time\" line ends the timed range.\n      if (this.pairwiseTimedRange_) {\n        this.hasSeenTimerMarker_ = false;\n      }\n    } else {\n      this.hasSeenTimerMarker_ = true;\n    }\n  } else {\n    if (this.hasSeenTimerMarker_) {\n      this.logLinesSinceLastTimerMarker_.push(line);\n    } else if (!line.startsWith(\"tick\")) {\n      this.processLog_([line]);\n    }\n  }\n};\n\n\n/**\n * Processes stack record.\n *\n * @param {number} pc Program counter.\n * @param {number} func JS Function.\n * @param {Array.<string>} stack String representation of a stack.\n * @return {Array.<number>} Processed stack.\n */\nLogReader.prototype.processStack = function(pc, func, stack) {\n  var fullStack = func ? [pc, func] : [pc];\n  var prevFrame = pc;\n  for (var i = 0, n = stack.length; i < n; ++i) {\n    var frame = stack[i];\n    var firstChar = frame.charAt(0);\n    if (firstChar == '+' || firstChar == '-') {\n      // An offset from the previous frame.\n      prevFrame += parseInt(frame, 16);\n      fullStack.push(prevFrame);\n    // Filter out possible 'overflow' string.\n    } else if (firstChar != 'o') {\n      fullStack.push(parseInt(frame, 16));\n    } else {\n      print(\"dropping: \" + frame);\n    }\n  }\n  return fullStack;\n};\n\n\n/**\n * Returns whether a particular dispatch must be skipped.\n *\n * @param {!Object} dispatch Dispatch record.\n * @return {boolean} True if dispatch must be skipped.\n */\nLogReader.prototype.skipDispatch = function(dispatch) {\n  return false;\n};\n\n\n/**\n * Does a dispatch of a log record.\n *\n * @param {Array.<string>} fields Log record.\n * @private\n */\nLogReader.prototype.dispatchLogRow_ = function(fields) {\n  // Obtain the dispatch.\n  var command = fields[0];\n  if (!(command in this.dispatchTable_)) return;\n\n  var dispatch = this.dispatchTable_[command];\n\n  if (dispatch === null || this.skipDispatch(dispatch)) {\n    return;\n  }\n\n  // Parse fields.\n  var parsedFields = [];\n  for (var i = 0; i < dispatch.parsers.length; ++i) {\n    var parser = dispatch.parsers[i];\n    if (parser === null) {\n      parsedFields.push(fields[1 + i]);\n    } else if (typeof parser == 'function') {\n      parsedFields.push(parser(fields[1 + i]));\n    } else {\n      // var-args\n      parsedFields.push(fields.slice(1 + i));\n      break;\n    }\n  }\n\n  // Run the processor.\n  dispatch.processor.apply(this, parsedFields);\n};\n\n\n/**\n * Processes log lines.\n *\n * @param {Array.<string>} lines Log lines.\n * @private\n */\nLogReader.prototype.processLog_ = function(lines) {\n  for (var i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {\n    var line = lines[i];\n    if (!line) {\n      continue;\n    }\n    try {\n      var fields = this.csvParser_.parseLine(line);\n      this.dispatchLogRow_(fields);\n    } catch (e) {\n      this.printError('line ' + (this.lineNum_ + 1) + ': ' + (e.message || e));\n    }\n  }\n};\n",
  "v8/tools/tickprocessor": "// Copyright 2012 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfunction inherits(childCtor, parentCtor) {\n  childCtor.prototype.__proto__ = parentCtor.prototype;\n};\n\n\nfunction V8Profile(separateIc) {\n  Profile.call(this);\n  if (!separateIc) {\n    this.skipThisFunction = function(name) { return V8Profile.IC_RE.test(name); };\n  }\n};\ninherits(V8Profile, Profile);\n\n\nV8Profile.IC_RE =\n    /^(LoadGlobalIC: )|(Handler: )|(Stub: )|(Builtin: )|(BytecodeHandler: )|(?:CallIC|LoadIC|StoreIC)|(?:Builtin: (?:Keyed)?(?:Load|Store)IC_)/;\n\n\n/**\n * A thin wrapper around shell's 'read' function showing a file name on error.\n */\nfunction readFile(fileName) {\n  try {\n    return read(fileName);\n  } catch (e) {\n    print(fileName + ': ' + (e.message || e));\n    throw e;\n  }\n}\n\n\n/**\n * Parser for dynamic code optimization state.\n */\nfunction parseState(s) {\n  switch (s) {\n  case \"\": return Profile.CodeState.COMPILED;\n  case \"~\": return Profile.CodeState.OPTIMIZABLE;\n  case \"*\": return Profile.CodeState.OPTIMIZED;\n  }\n  throw new Error(\"unknown code state: \" + s);\n}\n\n\nfunction TickProcessor(\n    cppEntriesProvider,\n    separateIc,\n    callGraphSize,\n    ignoreUnknown,\n    stateFilter,\n    distortion,\n    range,\n    sourceMap,\n    timedRange,\n    pairwiseTimedRange,\n    onlySummary,\n    runtimeTimerFilter) {\n  LogReader.call(this, {\n      'shared-library': { parsers: [null, parseInt, parseInt, parseInt],\n          processor: this.processSharedLibrary },\n      'code-creation': {\n          parsers: [null, parseInt, parseInt, parseInt, null, 'var-args'],\n          processor: this.processCodeCreation },\n      'code-move': { parsers: [parseInt, parseInt],\n          processor: this.processCodeMove },\n      'code-delete': { parsers: [parseInt],\n          processor: this.processCodeDelete },\n      'sfi-move': { parsers: [parseInt, parseInt],\n          processor: this.processFunctionMove },\n      'active-runtime-timer': {\n        parsers: [null],\n        processor: this.processRuntimeTimerEvent },\n      'tick': {\n          parsers: [parseInt, parseInt, parseInt,\n                    parseInt, parseInt, 'var-args'],\n          processor: this.processTick },\n      'heap-sample-begin': { parsers: [null, null, parseInt],\n          processor: this.processHeapSampleBegin },\n      'heap-sample-end': { parsers: [null, null],\n          processor: this.processHeapSampleEnd },\n      'timer-event-start' : { parsers: [null, null, null],\n                              processor: this.advanceDistortion },\n      'timer-event-end' : { parsers: [null, null, null],\n                            processor: this.advanceDistortion },\n      // Ignored events.\n      'profiler': null,\n      'function-creation': null,\n      'function-move': null,\n      'function-delete': null,\n      'heap-sample-item': null,\n      'current-time': null,  // Handled specially, not parsed.\n      // Obsolete row types.\n      'code-allocate': null,\n      'begin-code-region': null,\n      'end-code-region': null },\n      timedRange,\n      pairwiseTimedRange);\n\n  this.cppEntriesProvider_ = cppEntriesProvider;\n  this.callGraphSize_ = callGraphSize;\n  this.ignoreUnknown_ = ignoreUnknown;\n  this.stateFilter_ = stateFilter;\n  this.runtimeTimerFilter_ = runtimeTimerFilter;\n  this.sourceMap = sourceMap;\n  this.deserializedEntriesNames_ = [];\n  var ticks = this.ticks_ =\n    { total: 0, unaccounted: 0, excluded: 0, gc: 0 };\n\n  distortion = parseInt(distortion);\n  // Convert picoseconds to nanoseconds.\n  this.distortion_per_entry = isNaN(distortion) ? 0 : (distortion / 1000);\n  this.distortion = 0;\n  var rangelimits = range ? range.split(\",\") : [];\n  var range_start = parseInt(rangelimits[0]);\n  var range_end = parseInt(rangelimits[1]);\n  // Convert milliseconds to nanoseconds.\n  this.range_start = isNaN(range_start) ? -Infinity : (range_start * 1000);\n  this.range_end = isNaN(range_end) ? Infinity : (range_end * 1000)\n\n  V8Profile.prototype.handleUnknownCode = function(\n      operation, addr, opt_stackPos) {\n    var op = Profile.Operation;\n    switch (operation) {\n      case op.MOVE:\n        print('Code move event for unknown code: 0x' + addr.toString(16));\n        break;\n      case op.DELETE:\n        print('Code delete event for unknown code: 0x' + addr.toString(16));\n        break;\n      case op.TICK:\n        // Only unknown PCs (the first frame) are reported as unaccounted,\n        // otherwise tick balance will be corrupted (this behavior is compatible\n        // with the original tickprocessor.py script.)\n        if (opt_stackPos == 0) {\n          ticks.unaccounted++;\n        }\n        break;\n    }\n  };\n\n  this.profile_ = new V8Profile(separateIc);\n  this.codeTypes_ = {};\n  // Count each tick as a time unit.\n  this.viewBuilder_ = new ViewBuilder(1);\n  this.lastLogFileName_ = null;\n\n  this.generation_ = 1;\n  this.currentProducerProfile_ = null;\n  this.onlySummary_ = onlySummary;\n};\ninherits(TickProcessor, LogReader);\n\n\nTickProcessor.VmStates = {\n  JS: 0,\n  GC: 1,\n  COMPILER: 2,\n  OTHER: 3,\n  EXTERNAL: 4,\n  IDLE: 5\n};\n\n\nTickProcessor.CodeTypes = {\n  CPP: 0,\n  SHARED_LIB: 1\n};\n// Otherwise, this is JS-related code. We are not adding it to\n// codeTypes_ map because there can be zillions of them.\n\n\nTickProcessor.CALL_PROFILE_CUTOFF_PCT = 2.0;\n\nTickProcessor.CALL_GRAPH_SIZE = 5;\n\n/**\n * @override\n */\nTickProcessor.prototype.printError = function(str) {\n  print(str);\n};\n\n\nTickProcessor.prototype.setCodeType = function(name, type) {\n  this.codeTypes_[name] = TickProcessor.CodeTypes[type];\n};\n\n\nTickProcessor.prototype.isSharedLibrary = function(name) {\n  return this.codeTypes_[name] == TickProcessor.CodeTypes.SHARED_LIB;\n};\n\n\nTickProcessor.prototype.isCppCode = function(name) {\n  return this.codeTypes_[name] == TickProcessor.CodeTypes.CPP;\n};\n\n\nTickProcessor.prototype.isJsCode = function(name) {\n  return name !== \"UNKNOWN\" && !(name in this.codeTypes_);\n};\n\n\nTickProcessor.prototype.processLogFile = function(fileName) {\n  this.lastLogFileName_ = fileName;\n  var line;\n  while (line = readline()) {\n    this.processLogLine(line);\n  }\n};\n\n\nTickProcessor.prototype.processLogFileInTest = function(fileName) {\n   // Hack file name to avoid dealing with platform specifics.\n  this.lastLogFileName_ = 'v8.log';\n  var contents = readFile(fileName);\n  this.processLogChunk(contents);\n};\n\n\nTickProcessor.prototype.processSharedLibrary = function(\n    name, startAddr, endAddr, aslrSlide) {\n  var entry = this.profile_.addLibrary(name, startAddr, endAddr, aslrSlide);\n  this.setCodeType(entry.getName(), 'SHARED_LIB');\n\n  var self = this;\n  var libFuncs = this.cppEntriesProvider_.parseVmSymbols(\n      name, startAddr, endAddr, aslrSlide, function(fName, fStart, fEnd) {\n    self.profile_.addStaticCode(fName, fStart, fEnd);\n    self.setCodeType(fName, 'CPP');\n  });\n};\n\n\nTickProcessor.prototype.processCodeCreation = function(\n    type, kind, start, size, name, maybe_func) {\n  name = this.deserializedEntriesNames_[start] || name;\n  if (maybe_func.length) {\n    var funcAddr = parseInt(maybe_func[0]);\n    var state = parseState(maybe_func[1]);\n    this.profile_.addFuncCode(type, name, start, size, funcAddr, state);\n  } else {\n    this.profile_.addCode(type, name, start, size);\n  }\n};\n\n\nTickProcessor.prototype.processCodeMove = function(from, to) {\n  this.profile_.moveCode(from, to);\n};\n\n\nTickProcessor.prototype.processCodeDelete = function(start) {\n  this.profile_.deleteCode(start);\n};\n\n\nTickProcessor.prototype.processFunctionMove = function(from, to) {\n  this.profile_.moveFunc(from, to);\n};\n\n\nTickProcessor.prototype.includeTick = function(vmState) {\n  if (this.stateFilter_ !== null) {\n    return this.stateFilter_ == vmState;\n  } else if (this.runtimeTimerFilter_ !== null) {\n    return this.currentRuntimeTimer == this.runtimeTimerFilter_;\n  }\n  return true;\n};\n\nTickProcessor.prototype.processRuntimeTimerEvent = function(name) {\n  this.currentRuntimeTimer = name;\n}\n\nTickProcessor.prototype.processTick = function(pc,\n                                               ns_since_start,\n                                               is_external_callback,\n                                               tos_or_external_callback,\n                                               vmState,\n                                               stack) {\n  this.distortion += this.distortion_per_entry;\n  ns_since_start -= this.distortion;\n  if (ns_since_start < this.range_start || ns_since_start > this.range_end) {\n    return;\n  }\n  this.ticks_.total++;\n  if (vmState == TickProcessor.VmStates.GC) this.ticks_.gc++;\n  if (!this.includeTick(vmState)) {\n    this.ticks_.excluded++;\n    return;\n  }\n  if (is_external_callback) {\n    // Don't use PC when in external callback code, as it can point\n    // inside callback's code, and we will erroneously report\n    // that a callback calls itself. Instead we use tos_or_external_callback,\n    // as simply resetting PC will produce unaccounted ticks.\n    pc = tos_or_external_callback;\n    tos_or_external_callback = 0;\n  } else if (tos_or_external_callback) {\n    // Find out, if top of stack was pointing inside a JS function\n    // meaning that we have encountered a frameless invocation.\n    var funcEntry = this.profile_.findEntry(tos_or_external_callback);\n    if (!funcEntry || !funcEntry.isJSFunction || !funcEntry.isJSFunction()) {\n      tos_or_external_callback = 0;\n    }\n  }\n\n  this.profile_.recordTick(this.processStack(pc, tos_or_external_callback, stack));\n};\n\n\nTickProcessor.prototype.advanceDistortion = function() {\n  this.distortion += this.distortion_per_entry;\n}\n\n\nTickProcessor.prototype.processHeapSampleBegin = function(space, state, ticks) {\n  if (space != 'Heap') return;\n  this.currentProducerProfile_ = new CallTree();\n};\n\n\nTickProcessor.prototype.processHeapSampleEnd = function(space, state) {\n  if (space != 'Heap' || !this.currentProducerProfile_) return;\n\n  print('Generation ' + this.generation_ + ':');\n  var tree = this.currentProducerProfile_;\n  tree.computeTotalWeights();\n  var producersView = this.viewBuilder_.buildView(tree);\n  // Sort by total time, desc, then by name, desc.\n  producersView.sort(function(rec1, rec2) {\n      return rec2.totalTime - rec1.totalTime ||\n          (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });\n  this.printHeavyProfile(producersView.head.children);\n\n  this.currentProducerProfile_ = null;\n  this.generation_++;\n};\n\n\nTickProcessor.prototype.printStatistics = function() {\n  print('Statistical profiling result from ' + this.lastLogFileName_ +\n        ', (' + this.ticks_.total +\n        ' ticks, ' + this.ticks_.unaccounted + ' unaccounted, ' +\n        this.ticks_.excluded + ' excluded).');\n\n  if (this.ticks_.total == 0) return;\n\n  var flatProfile = this.profile_.getFlatProfile();\n  var flatView = this.viewBuilder_.buildView(flatProfile);\n  // Sort by self time, desc, then by name, desc.\n  flatView.sort(function(rec1, rec2) {\n      return rec2.selfTime - rec1.selfTime ||\n          (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });\n  var totalTicks = this.ticks_.total;\n  if (this.ignoreUnknown_) {\n    totalTicks -= this.ticks_.unaccounted;\n  }\n  var printAllTicks = !this.onlySummary_;\n\n  // Count library ticks\n  var flatViewNodes = flatView.head.children;\n  var self = this;\n\n  var libraryTicks = 0;\n  if(printAllTicks) this.printHeader('Shared libraries');\n  this.printEntries(flatViewNodes, totalTicks, null,\n      function(name) { return self.isSharedLibrary(name); },\n      function(rec) { libraryTicks += rec.selfTime; }, printAllTicks);\n  var nonLibraryTicks = totalTicks - libraryTicks;\n\n  var jsTicks = 0;\n  if(printAllTicks) this.printHeader('JavaScript');\n  this.printEntries(flatViewNodes, totalTicks, nonLibraryTicks,\n      function(name) { return self.isJsCode(name); },\n      function(rec) { jsTicks += rec.selfTime; }, printAllTicks);\n\n  var cppTicks = 0;\n  if(printAllTicks) this.printHeader('C++');\n  this.printEntries(flatViewNodes, totalTicks, nonLibraryTicks,\n      function(name) { return self.isCppCode(name); },\n      function(rec) { cppTicks += rec.selfTime; }, printAllTicks);\n\n  this.printHeader('Summary');\n  this.printLine('JavaScript', jsTicks, totalTicks, nonLibraryTicks);\n  this.printLine('C++', cppTicks, totalTicks, nonLibraryTicks);\n  this.printLine('GC', this.ticks_.gc, totalTicks, nonLibraryTicks);\n  this.printLine('Shared libraries', libraryTicks, totalTicks, null);\n  if (!this.ignoreUnknown_ && this.ticks_.unaccounted > 0) {\n    this.printLine('Unaccounted', this.ticks_.unaccounted,\n                   this.ticks_.total, null);\n  }\n\n  if(printAllTicks) {\n    print('\\n [C++ entry points]:');\n    print('   ticks    cpp   total   name');\n    var c_entry_functions = this.profile_.getCEntryProfile();\n    var total_c_entry = c_entry_functions[0].ticks;\n    for (var i = 1; i < c_entry_functions.length; i++) {\n      c = c_entry_functions[i];\n      this.printLine(c.name, c.ticks, total_c_entry, totalTicks);\n    }\n\n    this.printHeavyProfHeader();\n    var heavyProfile = this.profile_.getBottomUpProfile();\n    var heavyView = this.viewBuilder_.buildView(heavyProfile);\n    // To show the same percentages as in the flat profile.\n    heavyView.head.totalTime = totalTicks;\n    // Sort by total time, desc, then by name, desc.\n    heavyView.sort(function(rec1, rec2) {\n        return rec2.totalTime - rec1.totalTime ||\n            (rec2.internalFuncName < rec1.internalFuncName ? -1 : 1); });\n    this.printHeavyProfile(heavyView.head.children);\n  }\n};\n\n\nfunction padLeft(s, len) {\n  s = s.toString();\n  if (s.length < len) {\n    var padLength = len - s.length;\n    if (!(padLength in padLeft)) {\n      padLeft[padLength] = new Array(padLength + 1).join(' ');\n    }\n    s = padLeft[padLength] + s;\n  }\n  return s;\n};\n\n\nTickProcessor.prototype.printHeader = function(headerTitle) {\n  print('\\n [' + headerTitle + ']:');\n  print('   ticks  total  nonlib   name');\n};\n\n\nTickProcessor.prototype.printLine = function(\n    entry, ticks, totalTicks, nonLibTicks) {\n  var pct = ticks * 100 / totalTicks;\n  var nonLibPct = nonLibTicks != null\n      ? padLeft((ticks * 100 / nonLibTicks).toFixed(1), 5) + '%  '\n      : '        ';\n  print('  ' + padLeft(ticks, 5) + '  ' +\n        padLeft(pct.toFixed(1), 5) + '%  ' +\n        nonLibPct +\n        entry);\n}\n\nTickProcessor.prototype.printHeavyProfHeader = function() {\n  print('\\n [Bottom up (heavy) profile]:');\n  print('  Note: percentage shows a share of a particular caller in the ' +\n        'total\\n' +\n        '  amount of its parent calls.');\n  print('  Callers occupying less than ' +\n        TickProcessor.CALL_PROFILE_CUTOFF_PCT.toFixed(1) +\n        '% are not shown.\\n');\n  print('   ticks parent  name');\n};\n\n\nTickProcessor.prototype.processProfile = function(\n    profile, filterP, func) {\n  for (var i = 0, n = profile.length; i < n; ++i) {\n    var rec = profile[i];\n    if (!filterP(rec.internalFuncName)) {\n      continue;\n    }\n    func(rec);\n  }\n};\n\nTickProcessor.prototype.getLineAndColumn = function(name) {\n  var re = /:([0-9]+):([0-9]+)$/;\n  var array = re.exec(name);\n  if (!array) {\n    return null;\n  }\n  return {line: array[1], column: array[2]};\n}\n\nTickProcessor.prototype.hasSourceMap = function() {\n  return this.sourceMap != null;\n};\n\n\nTickProcessor.prototype.formatFunctionName = function(funcName) {\n  if (!this.hasSourceMap()) {\n    return funcName;\n  }\n  var lc = this.getLineAndColumn(funcName);\n  if (lc == null) {\n    return funcName;\n  }\n  // in source maps lines and columns are zero based\n  var lineNumber = lc.line - 1;\n  var column = lc.column - 1;\n  var entry = this.sourceMap.findEntry(lineNumber, column);\n  var sourceFile = entry[2];\n  var sourceLine = entry[3] + 1;\n  var sourceColumn = entry[4] + 1;\n\n  return sourceFile + ':' + sourceLine + ':' + sourceColumn + ' -> ' + funcName;\n};\n\nTickProcessor.prototype.printEntries = function(\n    profile, totalTicks, nonLibTicks, filterP, callback, printAllTicks) {\n  var that = this;\n  this.processProfile(profile, filterP, function (rec) {\n    if (rec.selfTime == 0) return;\n    callback(rec);\n    var funcName = that.formatFunctionName(rec.internalFuncName);\n    if(printAllTicks) {\n      that.printLine(funcName, rec.selfTime, totalTicks, nonLibTicks);\n    }\n  });\n};\n\n\nTickProcessor.prototype.printHeavyProfile = function(profile, opt_indent) {\n  var self = this;\n  var indent = opt_indent || 0;\n  var indentStr = padLeft('', indent);\n  this.processProfile(profile, function() { return true; }, function (rec) {\n    // Cut off too infrequent callers.\n    if (rec.parentTotalPercent < TickProcessor.CALL_PROFILE_CUTOFF_PCT) return;\n    var funcName = self.formatFunctionName(rec.internalFuncName);\n    print('  ' + padLeft(rec.totalTime, 5) + '  ' +\n          padLeft(rec.parentTotalPercent.toFixed(1), 5) + '%  ' +\n          indentStr + funcName);\n    // Limit backtrace depth.\n    if (indent < 2 * self.callGraphSize_) {\n      self.printHeavyProfile(rec.children, indent + 2);\n    }\n    // Delimit top-level functions.\n    if (indent == 0) {\n      print('');\n    }\n  });\n};\n\n\nfunction CppEntriesProvider() {\n};\n\n\nCppEntriesProvider.prototype.parseVmSymbols = function(\n    libName, libStart, libEnd, libASLRSlide, processorFunc) {\n  this.loadSymbols(libName);\n\n  var prevEntry;\n\n  function addEntry(funcInfo) {\n    // Several functions can be mapped onto the same address. To avoid\n    // creating zero-sized entries, skip such duplicates.\n    // Also double-check that function belongs to the library address space.\n    if (prevEntry && !prevEntry.end &&\n        prevEntry.start < funcInfo.start &&\n        prevEntry.start >= libStart && funcInfo.start <= libEnd) {\n      processorFunc(prevEntry.name, prevEntry.start, funcInfo.start);\n    }\n    if (funcInfo.end &&\n        (!prevEntry || prevEntry.start != funcInfo.start) &&\n        funcInfo.start >= libStart && funcInfo.end <= libEnd) {\n      processorFunc(funcInfo.name, funcInfo.start, funcInfo.end);\n    }\n    prevEntry = funcInfo;\n  }\n\n  while (true) {\n    var funcInfo = this.parseNextLine();\n    if (funcInfo === null) {\n      continue;\n    } else if (funcInfo === false) {\n      break;\n    }\n    funcInfo.start += libASLRSlide;\n    if (funcInfo.start < libStart && funcInfo.start < libEnd - libStart) {\n      funcInfo.start += libStart;\n    }\n    if (funcInfo.size) {\n      funcInfo.end = funcInfo.start + funcInfo.size;\n    }\n    addEntry(funcInfo);\n  }\n  addEntry({name: '', start: libEnd});\n};\n\n\nCppEntriesProvider.prototype.loadSymbols = function(libName) {\n};\n\n\nCppEntriesProvider.prototype.parseNextLine = function() {\n  return false;\n};\n\n\nfunction UnixCppEntriesProvider(nmExec, targetRootFS) {\n  this.symbols = [];\n  this.parsePos = 0;\n  this.nmExec = nmExec;\n  this.targetRootFS = targetRootFS;\n  this.FUNC_RE = /^([0-9a-fA-F]{8,16}) ([0-9a-fA-F]{8,16} )?[tTwW] (.*)$/;\n};\ninherits(UnixCppEntriesProvider, CppEntriesProvider);\n\n\nUnixCppEntriesProvider.prototype.loadSymbols = function(libName) {\n  this.parsePos = 0;\n  libName = this.targetRootFS + libName;\n  try {\n    this.symbols = [\n      os.system(this.nmExec, ['-C', '-n', '-S', libName], -1, -1),\n      os.system(this.nmExec, ['-C', '-n', '-S', '-D', libName], -1, -1)\n    ];\n  } catch (e) {\n    // If the library cannot be found on this system let's not panic.\n    this.symbols = ['', ''];\n  }\n};\n\n\nUnixCppEntriesProvider.prototype.parseNextLine = function() {\n  if (this.symbols.length == 0) {\n    return false;\n  }\n  var lineEndPos = this.symbols[0].indexOf('\\n', this.parsePos);\n  if (lineEndPos == -1) {\n    this.symbols.shift();\n    this.parsePos = 0;\n    return this.parseNextLine();\n  }\n\n  var line = this.symbols[0].substring(this.parsePos, lineEndPos);\n  this.parsePos = lineEndPos + 1;\n  var fields = line.match(this.FUNC_RE);\n  var funcInfo = null;\n  if (fields) {\n    funcInfo = { name: fields[3], start: parseInt(fields[1], 16) };\n    if (fields[2]) {\n      funcInfo.size = parseInt(fields[2], 16);\n    }\n  }\n  return funcInfo;\n};\n\n\nfunction MacCppEntriesProvider(nmExec, targetRootFS) {\n  UnixCppEntriesProvider.call(this, nmExec, targetRootFS);\n  // Note an empty group. It is required, as UnixCppEntriesProvider expects 3 groups.\n  this.FUNC_RE = /^([0-9a-fA-F]{8,16}) ()[iItT] (.*)$/;\n};\ninherits(MacCppEntriesProvider, UnixCppEntriesProvider);\n\n\nMacCppEntriesProvider.prototype.loadSymbols = function(libName) {\n  this.parsePos = 0;\n  libName = this.targetRootFS + libName;\n\n  // It seems that in OS X `nm` thinks that `-f` is a format option, not a\n  // \"flat\" display option flag.\n  try {\n    this.symbols = [os.system(this.nmExec, ['-n', libName], -1, -1), ''];\n  } catch (e) {\n    // If the library cannot be found on this system let's not panic.\n    this.symbols = '';\n  }\n};\n\n\nfunction WindowsCppEntriesProvider(_ignored_nmExec, targetRootFS) {\n  this.targetRootFS = targetRootFS;\n  this.symbols = '';\n  this.parsePos = 0;\n};\ninherits(WindowsCppEntriesProvider, CppEntriesProvider);\n\n\nWindowsCppEntriesProvider.FILENAME_RE = /^(.*)\\.([^.]+)$/;\n\n\nWindowsCppEntriesProvider.FUNC_RE =\n    /^\\s+0001:[0-9a-fA-F]{8}\\s+([_\\?@$0-9a-zA-Z]+)\\s+([0-9a-fA-F]{8}).*$/;\n\n\nWindowsCppEntriesProvider.IMAGE_BASE_RE =\n    /^\\s+0000:00000000\\s+___ImageBase\\s+([0-9a-fA-F]{8}).*$/;\n\n\n// This is almost a constant on Windows.\nWindowsCppEntriesProvider.EXE_IMAGE_BASE = 0x00400000;\n\n\nWindowsCppEntriesProvider.prototype.loadSymbols = function(libName) {\n  libName = this.targetRootFS + libName;\n  var fileNameFields = libName.match(WindowsCppEntriesProvider.FILENAME_RE);\n  if (!fileNameFields) return;\n  var mapFileName = fileNameFields[1] + '.map';\n  this.moduleType_ = fileNameFields[2].toLowerCase();\n  try {\n    this.symbols = read(mapFileName);\n  } catch (e) {\n    // If .map file cannot be found let's not panic.\n    this.symbols = '';\n  }\n};\n\n\nWindowsCppEntriesProvider.prototype.parseNextLine = function() {\n  var lineEndPos = this.symbols.indexOf('\\r\\n', this.parsePos);\n  if (lineEndPos == -1) {\n    return false;\n  }\n\n  var line = this.symbols.substring(this.parsePos, lineEndPos);\n  this.parsePos = lineEndPos + 2;\n\n  // Image base entry is above all other symbols, so we can just\n  // terminate parsing.\n  var imageBaseFields = line.match(WindowsCppEntriesProvider.IMAGE_BASE_RE);\n  if (imageBaseFields) {\n    var imageBase = parseInt(imageBaseFields[1], 16);\n    if ((this.moduleType_ == 'exe') !=\n        (imageBase == WindowsCppEntriesProvider.EXE_IMAGE_BASE)) {\n      return false;\n    }\n  }\n\n  var fields = line.match(WindowsCppEntriesProvider.FUNC_RE);\n  return fields ?\n      { name: this.unmangleName(fields[1]), start: parseInt(fields[2], 16) } :\n      null;\n};\n\n\n/**\n * Performs very simple unmangling of C++ names.\n *\n * Does not handle arguments and template arguments. The mangled names have\n * the form:\n *\n *   ?LookupInDescriptor@JSObject@internal@v8@@...arguments info...\n */\nWindowsCppEntriesProvider.prototype.unmangleName = function(name) {\n  // Empty or non-mangled name.\n  if (name.length < 1 || name.charAt(0) != '?') return name;\n  var nameEndPos = name.indexOf('@@');\n  var components = name.substring(1, nameEndPos).split('@');\n  components.reverse();\n  return components.join('::');\n};\n\n\nfunction ArgumentsProcessor(args) {\n  this.args_ = args;\n  this.result_ = ArgumentsProcessor.DEFAULTS;\n\n  this.argsDispatch_ = {\n    '-j': ['stateFilter', TickProcessor.VmStates.JS,\n        'Show only ticks from JS VM state'],\n    '-g': ['stateFilter', TickProcessor.VmStates.GC,\n        'Show only ticks from GC VM state'],\n    '-c': ['stateFilter', TickProcessor.VmStates.COMPILER,\n        'Show only ticks from COMPILER VM state'],\n    '-o': ['stateFilter', TickProcessor.VmStates.OTHER,\n        'Show only ticks from OTHER VM state'],\n    '-e': ['stateFilter', TickProcessor.VmStates.EXTERNAL,\n        'Show only ticks from EXTERNAL VM state'],\n    '--filter-runtime-timer': ['runtimeTimerFilter', null,\n            'Show only ticks matching the given runtime timer scope'],\n    '--call-graph-size': ['callGraphSize', TickProcessor.CALL_GRAPH_SIZE,\n        'Set the call graph size'],\n    '--ignore-unknown': ['ignoreUnknown', true,\n        'Exclude ticks of unknown code entries from processing'],\n    '--separate-ic': ['separateIc', true,\n        'Separate IC entries'],\n    '--unix': ['platform', 'unix',\n        'Specify that we are running on *nix platform'],\n    '--windows': ['platform', 'windows',\n        'Specify that we are running on Windows platform'],\n    '--mac': ['platform', 'mac',\n        'Specify that we are running on Mac OS X platform'],\n    '--nm': ['nm', 'nm',\n        'Specify the \\'nm\\' executable to use (e.g. --nm=/my_dir/nm)'],\n    '--target': ['targetRootFS', '',\n        'Specify the target root directory for cross environment'],\n    '--range': ['range', 'auto,auto',\n        'Specify the range limit as [start],[end]'],\n    '--distortion': ['distortion', 0,\n        'Specify the logging overhead in picoseconds'],\n    '--source-map': ['sourceMap', null,\n        'Specify the source map that should be used for output'],\n    '--timed-range': ['timedRange', true,\n        'Ignore ticks before first and after last Date.now() call'],\n    '--pairwise-timed-range': ['pairwiseTimedRange', true,\n        'Ignore ticks outside pairs of Date.now() calls'],\n    '--only-summary': ['onlySummary', true,\n        'Print only tick summary, exclude other information']\n  };\n  this.argsDispatch_['--js'] = this.argsDispatch_['-j'];\n  this.argsDispatch_['--gc'] = this.argsDispatch_['-g'];\n  this.argsDispatch_['--compiler'] = this.argsDispatch_['-c'];\n  this.argsDispatch_['--other'] = this.argsDispatch_['-o'];\n  this.argsDispatch_['--external'] = this.argsDispatch_['-e'];\n  this.argsDispatch_['--ptr'] = this.argsDispatch_['--pairwise-timed-range'];\n};\n\n\nArgumentsProcessor.DEFAULTS = {\n  logFileName: 'v8.log',\n  platform: 'unix',\n  stateFilter: null,\n  callGraphSize: 5,\n  ignoreUnknown: false,\n  separateIc: false,\n  targetRootFS: '',\n  nm: 'nm',\n  range: 'auto,auto',\n  distortion: 0,\n  timedRange: false,\n  pairwiseTimedRange: false,\n  onlySummary: false,\n  runtimeTimerFilter: null,\n};\n\n\nArgumentsProcessor.prototype.parse = function() {\n  while (this.args_.length) {\n    var arg = this.args_.shift();\n    if (arg.charAt(0) != '-') {\n      this.result_.logFileName = arg;\n      continue;\n    }\n    var userValue = null;\n    var eqPos = arg.indexOf('=');\n    if (eqPos != -1) {\n      userValue = arg.substr(eqPos + 1);\n      arg = arg.substr(0, eqPos);\n    }\n    if (arg in this.argsDispatch_) {\n      var dispatch = this.argsDispatch_[arg];\n      this.result_[dispatch[0]] = userValue == null ? dispatch[1] : userValue;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n\nArgumentsProcessor.prototype.result = function() {\n  return this.result_;\n};\n\n\nArgumentsProcessor.prototype.printUsageAndExit = function() {\n\n  function padRight(s, len) {\n    s = s.toString();\n    if (s.length < len) {\n      s = s + (new Array(len - s.length + 1).join(' '));\n    }\n    return s;\n  }\n\n  print('Cmdline args: [options] [log-file-name]\\n' +\n        'Default log file name is \"' +\n        ArgumentsProcessor.DEFAULTS.logFileName + '\".\\n');\n  print('Options:');\n  for (var arg in this.argsDispatch_) {\n    var synonyms = [arg];\n    var dispatch = this.argsDispatch_[arg];\n    for (var synArg in this.argsDispatch_) {\n      if (arg !== synArg && dispatch === this.argsDispatch_[synArg]) {\n        synonyms.push(synArg);\n        delete this.argsDispatch_[synArg];\n      }\n    }\n    print('  ' + padRight(synonyms.join(', '), 20) + \" \" + dispatch[2]);\n  }\n  quit(2);\n};\n",
  "v8/tools/SourceMap": "// Copyright 2013 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// This is a copy from blink dev tools, see:\n// http://src.chromium.org/viewvc/blink/trunk/Source/devtools/front_end/SourceMap.js\n// revision: 153407\n\n// Added to make the file work without dev tools\nWebInspector = {};\nWebInspector.ParsedURL = {};\nWebInspector.ParsedURL.completeURL = function(){};\n// start of original file content\n\n/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Implements Source Map V3 model. See http://code.google.com/p/closure-compiler/wiki/SourceMaps\n * for format description.\n * @constructor\n * @param {string} sourceMappingURL\n * @param {SourceMapV3} payload\n */\nWebInspector.SourceMap = function(sourceMappingURL, payload)\n{\n    if (!WebInspector.SourceMap.prototype._base64Map) {\n        const base64Digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n        WebInspector.SourceMap.prototype._base64Map = {};\n        for (var i = 0; i < base64Digits.length; ++i)\n            WebInspector.SourceMap.prototype._base64Map[base64Digits.charAt(i)] = i;\n    }\n\n    this._sourceMappingURL = sourceMappingURL;\n    this._reverseMappingsBySourceURL = {};\n    this._mappings = [];\n    this._sources = {};\n    this._sourceContentByURL = {};\n    this._parseMappingPayload(payload);\n}\n\n/**\n * @param {string} sourceMapURL\n * @param {string} compiledURL\n * @param {function(WebInspector.SourceMap)} callback\n */\nWebInspector.SourceMap.load = function(sourceMapURL, compiledURL, callback)\n{\n    NetworkAgent.loadResourceForFrontend(WebInspector.resourceTreeModel.mainFrame.id, sourceMapURL, undefined, contentLoaded.bind(this));\n\n    /**\n     * @param {?Protocol.Error} error\n     * @param {number} statusCode\n     * @param {NetworkAgent.Headers} headers\n     * @param {string} content\n     */\n    function contentLoaded(error, statusCode, headers, content)\n    {\n        if (error || !content || statusCode >= 400) {\n            console.error(\"Could not load content for \" + sourceMapURL + \" : \" + (error || (\"HTTP status code: \" + statusCode)));\n            callback(null);\n            return;\n        }\n\n        if (content.slice(0, 3) === \")]}\")\n            content = content.substring(content.indexOf('\\n'));\n        try {\n            var payload = /** @type {SourceMapV3} */ (JSON.parse(content));\n            var baseURL = sourceMapURL.startsWith(\"data:\") ? compiledURL : sourceMapURL;\n            callback(new WebInspector.SourceMap(baseURL, payload));\n        } catch(e) {\n            console.error(e.message);\n            callback(null);\n        }\n    }\n}\n\nWebInspector.SourceMap.prototype = {\n    /**\n     * @return {Array.<string>}\n     */\n    sources: function()\n    {\n        return Object.keys(this._sources);\n    },\n\n    /**\n     * @param {string} sourceURL\n     * @return {string|undefined}\n     */\n    sourceContent: function(sourceURL)\n    {\n        return this._sourceContentByURL[sourceURL];\n    },\n\n    /**\n     * @param {string} sourceURL\n     * @param {WebInspector.ResourceType} contentType\n     * @return {WebInspector.ContentProvider}\n     */\n    sourceContentProvider: function(sourceURL, contentType)\n    {\n        var lastIndexOfDot = sourceURL.lastIndexOf(\".\");\n        var extension = lastIndexOfDot !== -1 ? sourceURL.substr(lastIndexOfDot + 1) : \"\";\n        var mimeType = WebInspector.ResourceType.mimeTypesForExtensions[extension.toLowerCase()];\n        var sourceContent = this.sourceContent(sourceURL);\n        if (sourceContent)\n            return new WebInspector.StaticContentProvider(contentType, sourceContent, mimeType);\n        return new WebInspector.CompilerSourceMappingContentProvider(sourceURL, contentType, mimeType);\n    },\n\n    /**\n     * @param {SourceMapV3} mappingPayload\n     */\n    _parseMappingPayload: function(mappingPayload)\n    {\n        if (mappingPayload.sections)\n            this._parseSections(mappingPayload.sections);\n        else\n            this._parseMap(mappingPayload, 0, 0);\n    },\n\n    /**\n     * @param {Array.<SourceMapV3.Section>} sections\n     */\n    _parseSections: function(sections)\n    {\n        for (var i = 0; i < sections.length; ++i) {\n            var section = sections[i];\n            this._parseMap(section.map, section.offset.line, section.offset.column);\n        }\n    },\n\n    /**\n     * @param {number} lineNumber in compiled resource\n     * @param {number} columnNumber in compiled resource\n     * @return {?Array}\n     */\n    findEntry: function(lineNumber, columnNumber)\n    {\n        var first = 0;\n        var count = this._mappings.length;\n        while (count > 1) {\n          var step = count >> 1;\n          var middle = first + step;\n          var mapping = this._mappings[middle];\n          if (lineNumber < mapping[0] || (lineNumber === mapping[0] && columnNumber < mapping[1]))\n              count = step;\n          else {\n              first = middle;\n              count -= step;\n          }\n        }\n        var entry = this._mappings[first];\n        if (!first && entry && (lineNumber < entry[0] || (lineNumber === entry[0] && columnNumber < entry[1])))\n            return null;\n        return entry;\n    },\n\n    /**\n     * @param {string} sourceURL of the originating resource\n     * @param {number} lineNumber in the originating resource\n     * @return {Array}\n     */\n    findEntryReversed: function(sourceURL, lineNumber)\n    {\n        var mappings = this._reverseMappingsBySourceURL[sourceURL];\n        for ( ; lineNumber < mappings.length; ++lineNumber) {\n            var mapping = mappings[lineNumber];\n            if (mapping)\n                return mapping;\n        }\n        return this._mappings[0];\n    },\n\n    /**\n     * @override\n     */\n    _parseMap: function(map, lineNumber, columnNumber)\n    {\n        var sourceIndex = 0;\n        var sourceLineNumber = 0;\n        var sourceColumnNumber = 0;\n        var nameIndex = 0;\n\n        var sources = [];\n        var originalToCanonicalURLMap = {};\n        for (var i = 0; i < map.sources.length; ++i) {\n            var originalSourceURL = map.sources[i];\n            var sourceRoot = map.sourceRoot || \"\";\n            if (sourceRoot && !sourceRoot.endsWith(\"/\"))\n                sourceRoot += \"/\";\n            var href = sourceRoot + originalSourceURL;\n            var url = WebInspector.ParsedURL.completeURL(this._sourceMappingURL, href) || href;\n            originalToCanonicalURLMap[originalSourceURL] = url;\n            sources.push(url);\n            this._sources[url] = true;\n\n            if (map.sourcesContent && map.sourcesContent[i])\n                this._sourceContentByURL[url] = map.sourcesContent[i];\n        }\n\n        var stringCharIterator = new WebInspector.SourceMap.StringCharIterator(map.mappings);\n        var sourceURL = sources[sourceIndex];\n\n        while (true) {\n            if (stringCharIterator.peek() === \",\")\n                stringCharIterator.next();\n            else {\n                while (stringCharIterator.peek() === \";\") {\n                    lineNumber += 1;\n                    columnNumber = 0;\n                    stringCharIterator.next();\n                }\n                if (!stringCharIterator.hasNext())\n                    break;\n            }\n\n            columnNumber += this._decodeVLQ(stringCharIterator);\n            if (this._isSeparator(stringCharIterator.peek())) {\n                this._mappings.push([lineNumber, columnNumber]);\n                continue;\n            }\n\n            var sourceIndexDelta = this._decodeVLQ(stringCharIterator);\n            if (sourceIndexDelta) {\n                sourceIndex += sourceIndexDelta;\n                sourceURL = sources[sourceIndex];\n            }\n            sourceLineNumber += this._decodeVLQ(stringCharIterator);\n            sourceColumnNumber += this._decodeVLQ(stringCharIterator);\n            if (!this._isSeparator(stringCharIterator.peek()))\n                nameIndex += this._decodeVLQ(stringCharIterator);\n\n            this._mappings.push([lineNumber, columnNumber, sourceURL, sourceLineNumber, sourceColumnNumber]);\n        }\n\n        for (var i = 0; i < this._mappings.length; ++i) {\n            var mapping = this._mappings[i];\n            var url = mapping[2];\n            if (!url)\n                continue;\n            if (!this._reverseMappingsBySourceURL[url])\n                this._reverseMappingsBySourceURL[url] = [];\n            var reverseMappings = this._reverseMappingsBySourceURL[url];\n            var sourceLine = mapping[3];\n            if (!reverseMappings[sourceLine])\n                reverseMappings[sourceLine] = [mapping[0], mapping[1]];\n        }\n    },\n\n    /**\n     * @param {string} char\n     * @return {boolean}\n     */\n    _isSeparator: function(char)\n    {\n        return char === \",\" || char === \";\";\n    },\n\n    /**\n     * @param {WebInspector.SourceMap.StringCharIterator} stringCharIterator\n     * @return {number}\n     */\n    _decodeVLQ: function(stringCharIterator)\n    {\n        // Read unsigned value.\n        var result = 0;\n        var shift = 0;\n        do {\n            var digit = this._base64Map[stringCharIterator.next()];\n            result += (digit & this._VLQ_BASE_MASK) << shift;\n            shift += this._VLQ_BASE_SHIFT;\n        } while (digit & this._VLQ_CONTINUATION_MASK);\n\n        // Fix the sign.\n        var negative = result & 1;\n        result >>= 1;\n        return negative ? -result : result;\n    },\n\n    _VLQ_BASE_SHIFT: 5,\n    _VLQ_BASE_MASK: (1 << 5) - 1,\n    _VLQ_CONTINUATION_MASK: 1 << 5\n}\n\n/**\n * @constructor\n * @param {string} string\n */\nWebInspector.SourceMap.StringCharIterator = function(string)\n{\n    this._string = string;\n    this._position = 0;\n}\n\nWebInspector.SourceMap.StringCharIterator.prototype = {\n    /**\n     * @return {string}\n     */\n    next: function()\n    {\n        return this._string.charAt(this._position++);\n    },\n\n    /**\n     * @return {string}\n     */\n    peek: function()\n    {\n        return this._string.charAt(this._position);\n    },\n\n    /**\n     * @return {boolean}\n     */\n    hasNext: function()\n    {\n        return this._position < this._string.length;\n    }\n}\n",
  "v8/tools/tickprocessor-driver": "// Copyright 2012 the V8 project authors. All rights reserved.\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n//       copyright notice, this list of conditions and the following\n//       disclaimer in the documentation and/or other materials provided\n//       with the distribution.\n//     * Neither the name of Google Inc. nor the names of its\n//       contributors may be used to endorse or promote products derived\n//       from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n// Tick Processor's code flow.\n\nfunction processArguments(args) {\n  var processor = new ArgumentsProcessor(args);\n  if (processor.parse()) {\n    return processor.result();\n  } else {\n    processor.printUsageAndExit();\n  }\n}\n\nfunction initSourceMapSupport() {\n  // Pull dev tools source maps  into our name space.\n  SourceMap = WebInspector.SourceMap;\n\n  // Overwrite the load function to load scripts synchronously.\n  SourceMap.load = function(sourceMapURL) {\n    var content = readFile(sourceMapURL);\n    var sourceMapObject = (JSON.parse(content));\n    return new SourceMap(sourceMapURL, sourceMapObject);\n  };\n}\n\nvar entriesProviders = {\n  'unix': UnixCppEntriesProvider,\n  'windows': WindowsCppEntriesProvider,\n  'mac': MacCppEntriesProvider\n};\n\nvar params = processArguments(arguments);\nvar sourceMap = null;\nif (params.sourceMap) {\n  initSourceMapSupport();\n  sourceMap = SourceMap.load(params.sourceMap);\n}\nvar tickProcessor = new TickProcessor(\n  new (entriesProviders[params.platform])(params.nm, params.targetRootFS),\n  params.separateIc,\n  params.callGraphSize,\n  params.ignoreUnknown,\n  params.stateFilter,\n  params.distortion,\n  params.range,\n  sourceMap,\n  params.timedRange,\n  params.pairwiseTimedRange,\n  params.onlySummary,\n  params.runtimeTimerFilter);\ntickProcessor.processLogFile(params.logFileName);\ntickProcessor.printStatistics();\n",
  "node-inspect/lib/_inspect": "/*\n * Copyright Node.js contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n'use strict';\nconst { spawn } = require('child_process');\nconst { EventEmitter } = require('events');\nconst net = require('net');\nconst util = require('util');\n\nconst runAsStandalone = typeof __dirname !== 'undefined';\n\nconst [ InspectClient, createRepl ] =\n  runAsStandalone ?\n  // This copy of node-inspect is on-disk, relative paths make sense.\n  [\n    require('./internal/inspect_client'),\n    require('./internal/inspect_repl')\n  ] :\n  // This copy of node-inspect is built into the node executable.\n  [\n    require('node-inspect/lib/internal/inspect_client'),\n    require('node-inspect/lib/internal/inspect_repl')\n  ];\n\nconst debuglog = util.debuglog('inspect');\n\nconst DEBUG_PORT_PATTERN = /^--(?:debug|inspect)(?:-port|-brk)?=(\\d{1,5})$/;\nfunction getDefaultPort() {\n  for (const arg of process.execArgv) {\n    const match = arg.match(DEBUG_PORT_PATTERN);\n    if (match) {\n      return +match[1];\n    }\n  }\n  return 9229;\n}\n\nfunction portIsFree(host, port, timeout = 2000) {\n  const retryDelay = 150;\n  let didTimeOut = false;\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      didTimeOut = true;\n      reject(new Error(\n        `Timeout (${timeout}) waiting for ${host}:${port} to be free`));\n    }, timeout);\n\n    function pingPort() {\n      if (didTimeOut) return;\n\n      const socket = net.connect(port, host);\n      let didRetry = false;\n      function retry() {\n        if (!didRetry && !didTimeOut) {\n          didRetry = true;\n          setTimeout(pingPort, retryDelay);\n        }\n      }\n\n      socket.on('error', (error) => {\n        if (error.code === 'ECONNREFUSED') {\n          resolve();\n        } else {\n          retry();\n        }\n      });\n      socket.on('connect', () => {\n        socket.destroy();\n        retry();\n      });\n    }\n    pingPort();\n  });\n}\n\nfunction runScript(script, scriptArgs, inspectHost, inspectPort, childPrint) {\n  return portIsFree(inspectHost, inspectPort)\n    .then(() => {\n      return new Promise((resolve) => {\n        const needDebugBrk = process.version.match(/^v(6|7)\\./);\n        const args = (needDebugBrk ?\n                          ['--inspect', `--debug-brk=${inspectPort}`] :\n                          [`--inspect-brk=${inspectPort}`])\n                         .concat([script], scriptArgs);\n        const child = spawn(process.execPath, args);\n        child.stdout.setEncoding('utf8');\n        child.stderr.setEncoding('utf8');\n        child.stdout.on('data', childPrint);\n        child.stderr.on('data', childPrint);\n\n        let output = '';\n        function waitForListenHint(text) {\n          output += text;\n          if (/Debugger listening on/.test(output)) {\n            child.stderr.removeListener('data', waitForListenHint);\n            resolve(child);\n          }\n        }\n\n        child.stderr.on('data', waitForListenHint);\n      });\n    });\n}\n\nfunction createAgentProxy(domain, client) {\n  const agent = new EventEmitter();\n  agent.then = (...args) => {\n    // TODO: potentially fetch the protocol and pretty-print it here.\n    const descriptor = {\n      [util.inspect.custom](depth, { stylize }) {\n        return stylize(`[Agent ${domain}]`, 'special');\n      },\n    };\n    return Promise.resolve(descriptor).then(...args);\n  };\n\n  return new Proxy(agent, {\n    get(target, name) {\n      if (name in target) return target[name];\n      return function callVirtualMethod(params) {\n        return client.callMethod(`${domain}.${name}`, params);\n      };\n    },\n  });\n}\n\nclass NodeInspector {\n  constructor(options, stdin, stdout) {\n    this.options = options;\n    this.stdin = stdin;\n    this.stdout = stdout;\n\n    this.paused = true;\n    this.child = null;\n\n    if (options.script) {\n      this._runScript = runScript.bind(null,\n                                       options.script,\n                                       options.scriptArgs,\n                                       options.host,\n                                       options.port,\n                                       this.childPrint.bind(this));\n    } else {\n      this._runScript = () => Promise.resolve(null);\n    }\n\n    this.client = new InspectClient(options.port, options.host);\n\n    this.domainNames = ['Debugger', 'HeapProfiler', 'Profiler', 'Runtime'];\n    this.domainNames.forEach((domain) => {\n      this[domain] = createAgentProxy(domain, this.client);\n    });\n    this.handleDebugEvent = (fullName, params) => {\n      const [domain, name] = fullName.split('.');\n      if (domain in this) {\n        this[domain].emit(name, params);\n      }\n    };\n    this.client.on('debugEvent', this.handleDebugEvent);\n    const startRepl = createRepl(this);\n\n    // Handle all possible exits\n    process.on('exit', () => this.killChild());\n    process.once('SIGTERM', process.exit.bind(process, 0));\n    process.once('SIGHUP', process.exit.bind(process, 0));\n\n    this.run()\n      .then(() => startRepl())\n      .then((repl) => {\n        this.repl = repl;\n        this.repl.on('exit', () => {\n          process.exit(0);\n        });\n        this.paused = false;\n      })\n      .then(null, (error) => process.nextTick(() => { throw error; }));\n  }\n\n  suspendReplWhile(fn) {\n    if (this.repl) {\n      this.repl.rli.pause();\n    }\n    this.stdin.pause();\n    this.paused = true;\n    return new Promise((resolve) => {\n      resolve(fn());\n    }).then(() => {\n      this.paused = false;\n      if (this.repl) {\n        this.repl.rli.resume();\n        this.repl.displayPrompt();\n      }\n      this.stdin.resume();\n    }).then(null, (error) => process.nextTick(() => { throw error; }));\n  }\n\n  killChild() {\n    this.client.reset();\n    if (this.child) {\n      this.child.kill();\n      this.child = null;\n    }\n  }\n\n  run() {\n    this.killChild();\n    const { host, port } = this.options;\n\n    return this._runScript().then((child) => {\n      this.child = child;\n\n      let connectionAttempts = 0;\n      const attemptConnect = () => {\n        ++connectionAttempts;\n        debuglog('connection attempt #%d', connectionAttempts);\n        this.stdout.write('.');\n        return this.client.connect()\n          .then(() => {\n            debuglog('connection established');\n            this.stdout.write(' ok');\n          }, (error) => {\n            debuglog('connect failed', error);\n            // If it's failed to connect 10 times then print failed message\n            if (connectionAttempts >= 10) {\n              this.stdout.write(' failed to connect, please retry\\n');\n              process.exit(1);\n            }\n\n            return new Promise((resolve) => setTimeout(resolve, 500))\n              .then(attemptConnect);\n          });\n      };\n\n      this.print(`connecting to ${host}:${port} ..`, true);\n      return attemptConnect();\n    });\n  }\n\n  clearLine() {\n    if (this.stdout.isTTY) {\n      this.stdout.cursorTo(0);\n      this.stdout.clearLine(1);\n    } else {\n      this.stdout.write('\\b');\n    }\n  }\n\n  print(text, oneline = false) {\n    this.clearLine();\n    this.stdout.write(oneline ? text : `${text}\\n`);\n  }\n\n  childPrint(text) {\n    this.print(\n      text.toString()\n        .split(/\\r\\n|\\r|\\n/g)\n        .filter((chunk) => !!chunk)\n        .map((chunk) => `< ${chunk}`)\n        .join('\\n')\n    );\n    if (!this.paused) {\n      this.repl.displayPrompt(true);\n    }\n    if (/Waiting for the debugger to disconnect\\.\\.\\.\\n$/.test(text)) {\n      this.killChild();\n    }\n  }\n}\n\nfunction parseArgv([target, ...args]) {\n  let host = '127.0.0.1';\n  let port = getDefaultPort();\n  let isRemote = false;\n  let script = target;\n  let scriptArgs = args;\n\n  const hostMatch = target.match(/^([^:]+):(\\d+)$/);\n  const portMatch = target.match(/^--port=(\\d+)$/);\n\n  if (hostMatch) {\n    // Connecting to remote debugger\n    // `node-inspect localhost:9229`\n    host = hostMatch[1];\n    port = parseInt(hostMatch[2], 10);\n    isRemote = true;\n    script = null;\n  } else if (portMatch) {\n    // start debugee on custom port\n    // `node inspect --port=9230 script.js`\n    port = parseInt(portMatch[1], 10);\n    script = args[0];\n    scriptArgs = args.slice(1);\n  } else if (args.length === 1 && /^\\d+$/.test(args[0]) && target === '-p') {\n    // Start debugger against a given pid\n    const pid = parseInt(args[0], 10);\n    try {\n      process._debugProcess(pid);\n    } catch (e) {\n      if (e.code === 'ESRCH') {\n        /* eslint-disable no-console */\n        console.error(`Target process: ${pid} doesn't exist.`);\n        /* eslint-enable no-console */\n        process.exit(1);\n      }\n      throw e;\n    }\n    script = null;\n    isRemote = true;\n  }\n\n  return {\n    host, port, isRemote, script, scriptArgs,\n  };\n}\n\nfunction startInspect(argv = process.argv.slice(2),\n                      stdin = process.stdin,\n                      stdout = process.stdout) {\n  /* eslint-disable no-console */\n  if (argv.length < 1) {\n    const invokedAs = runAsStandalone ?\n      'node-inspect' :\n      `${process.argv0} ${process.argv[1]}`;\n\n    console.error(`Usage: ${invokedAs} script.js`);\n    console.error(`       ${invokedAs} <host>:<port>`);\n    console.error(`       ${invokedAs} -p <pid>`);\n    process.exit(1);\n  }\n\n  const options = parseArgv(argv);\n  const inspector = new NodeInspector(options, stdin, stdout);\n\n  stdin.resume();\n\n  function handleUnexpectedError(e) {\n    console.error('There was an internal error in node-inspect. ' +\n                  'Please report this bug.');\n    console.error(e.message);\n    console.error(e.stack);\n    if (inspector.child) inspector.child.kill();\n    process.exit(1);\n  }\n\n  process.on('uncaughtException', handleUnexpectedError);\n  /* eslint-enable no-console */\n}\nexports.start = startInspect;\n",
  "node-inspect/lib/internal/inspect_client": "/*\n * Copyright Node.js contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n'use strict';\nconst Buffer = require('buffer').Buffer;\nconst crypto = require('crypto');\nconst { EventEmitter } = require('events');\nconst http = require('http');\nconst URL = require('url');\nconst util = require('util');\n\nconst debuglog = util.debuglog('inspect');\n\nconst kOpCodeText = 0x1;\nconst kOpCodeClose = 0x8;\n\nconst kFinalBit = 0x80;\nconst kReserved1Bit = 0x40;\nconst kReserved2Bit = 0x20;\nconst kReserved3Bit = 0x10;\nconst kOpCodeMask = 0xF;\nconst kMaskBit = 0x80;\nconst kPayloadLengthMask = 0x7F;\n\nconst kMaxSingleBytePayloadLength = 125;\nconst kMaxTwoBytePayloadLength = 0xFFFF;\nconst kTwoBytePayloadLengthField = 126;\nconst kEightBytePayloadLengthField = 127;\nconst kMaskingKeyWidthInBytes = 4;\n\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction unpackError({ code, message, data }) {\n  const err = new Error(`${message} - ${data}`);\n  err.code = code;\n  Error.captureStackTrace(err, unpackError);\n  return err;\n}\n\nfunction encodeFrameHybi17(payload) {\n  var i;\n\n  const dataLength = payload.length;\n\n  let singleByteLength;\n  let additionalLength;\n  if (dataLength > kMaxTwoBytePayloadLength) {\n    singleByteLength = kEightBytePayloadLengthField;\n    additionalLength = Buffer.alloc(8);\n    let remaining = dataLength;\n    for (i = 0; i < 8; ++i) {\n      additionalLength[7 - i] = remaining & 0xFF;\n      remaining >>= 8;\n    }\n  } else if (dataLength > kMaxSingleBytePayloadLength) {\n    singleByteLength = kTwoBytePayloadLengthField;\n    additionalLength = Buffer.alloc(2);\n    additionalLength[0] = (dataLength & 0xFF00) >> 8;\n    additionalLength[1] = dataLength & 0xFF;\n  } else {\n    additionalLength = Buffer.alloc(0);\n    singleByteLength = dataLength;\n  }\n\n  const header = Buffer.from([\n    kFinalBit | kOpCodeText,\n    kMaskBit | singleByteLength,\n  ]);\n\n  const mask = Buffer.alloc(4);\n  const masked = Buffer.alloc(dataLength);\n  for (i = 0; i < dataLength; ++i) {\n    masked[i] = payload[i] ^ mask[i % kMaskingKeyWidthInBytes];\n  }\n\n  return Buffer.concat([header, additionalLength, mask, masked]);\n}\n\nfunction decodeFrameHybi17(data) {\n  const dataAvailable = data.length;\n  const notComplete = { closed: false, payload: null, rest: data };\n  let payloadOffset = 2;\n  if ((dataAvailable - payloadOffset) < 0) return notComplete;\n\n  const firstByte = data[0];\n  const secondByte = data[1];\n\n  const final = (firstByte & kFinalBit) !== 0;\n  const reserved1 = (firstByte & kReserved1Bit) !== 0;\n  const reserved2 = (firstByte & kReserved2Bit) !== 0;\n  const reserved3 = (firstByte & kReserved3Bit) !== 0;\n  const opCode = firstByte & kOpCodeMask;\n  const masked = (secondByte & kMaskBit) !== 0;\n  const compressed = reserved1;\n  if (compressed) {\n    throw new Error('Compressed frames not supported');\n  }\n  if (!final || reserved2 || reserved3) {\n    throw new Error('Only compression extension is supported');\n  }\n\n  if (masked) {\n    throw new Error('Masked server frame - not supported');\n  }\n\n  let closed = false;\n  switch (opCode) {\n    case kOpCodeClose:\n      closed = true;\n      break;\n    case kOpCodeText:\n      break;\n    default:\n      throw new Error(`Unsupported op code ${opCode}`);\n  }\n\n  let payloadLength = secondByte & kPayloadLengthMask;\n  switch (payloadLength) {\n    case kTwoBytePayloadLengthField:\n      payloadOffset += 2;\n      payloadLength = (data[2] << 8) + data[3];\n      break;\n\n    case kEightBytePayloadLengthField:\n      payloadOffset += 8;\n      payloadLength = 0;\n      for (var i = 0; i < 8; ++i) {\n        payloadLength <<= 8;\n        payloadLength |= data[2 + i];\n      }\n      break;\n\n    default:\n      // Nothing. We already have the right size.\n  }\n  if ((dataAvailable - payloadOffset - payloadLength) < 0) return notComplete;\n\n  const payloadEnd = payloadOffset + payloadLength;\n  return {\n    payload: data.slice(payloadOffset, payloadEnd),\n    rest: data.slice(payloadEnd),\n    closed,\n  };\n}\n\nclass Client extends EventEmitter {\n  constructor(port, host) {\n    super();\n    this.handleChunk = this._handleChunk.bind(this);\n\n    this._port = port;\n    this._host = host;\n\n    this.reset();\n  }\n\n  _handleChunk(chunk) {\n    this._unprocessed = Buffer.concat([this._unprocessed, chunk]);\n\n    while (this._unprocessed.length > 2) {\n      const {\n        closed,\n        payload: payloadBuffer,\n        rest\n      } = decodeFrameHybi17(this._unprocessed);\n      this._unprocessed = rest;\n\n      if (closed) {\n        this.reset();\n        return;\n      }\n      if (payloadBuffer === null) break;\n\n      const payloadStr = payloadBuffer.toString();\n      debuglog('< %s', payloadStr);\n      const lastChar = payloadStr[payloadStr.length - 1];\n      if (payloadStr[0] !== '{' || lastChar !== '}') {\n        throw new Error(`Payload does not look like JSON: ${payloadStr}`);\n      }\n      let payload;\n      try {\n        payload = JSON.parse(payloadStr);\n      } catch (parseError) {\n        parseError.string = payloadStr;\n        throw parseError;\n      }\n\n      const { id, method, params, result, error } = payload;\n      if (id) {\n        const handler = this._pending[id];\n        if (handler) {\n          delete this._pending[id];\n          handler(error, result);\n        }\n      } else if (method) {\n        this.emit('debugEvent', method, params);\n        this.emit(method, params);\n      } else {\n        throw new Error(`Unsupported response: ${payloadStr}`);\n      }\n    }\n  }\n\n  reset() {\n    if (this._http) {\n      this._http.destroy();\n    }\n    this._http = null;\n    this._lastId = 0;\n    this._socket = null;\n    this._pending = {};\n    this._unprocessed = Buffer.alloc(0);\n  }\n\n  callMethod(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this._socket) {\n        reject(new Error('Use `run` to start the app again.'));\n        return;\n      }\n      const data = { id: ++this._lastId, method, params };\n      this._pending[data.id] = (error, result) => {\n        if (error) reject(unpackError(error));\n        else resolve(isEmpty(result) ? undefined : result);\n      };\n      const json = JSON.stringify(data);\n      debuglog('> %s', json);\n      this._socket.write(encodeFrameHybi17(Buffer.from(json)));\n    });\n  }\n\n  _fetchJSON(urlPath) {\n    return new Promise((resolve, reject) => {\n      const httpReq = http.get({\n        host: this._host,\n        port: this._port,\n        path: urlPath,\n      });\n\n      const chunks = [];\n\n      function onResponse(httpRes) {\n        function parseChunks() {\n          const resBody = Buffer.concat(chunks).toString();\n          if (httpRes.statusCode !== 200) {\n            reject(new Error(`Unexpected ${httpRes.statusCode}: ${resBody}`));\n            return;\n          }\n          try {\n            resolve(JSON.parse(resBody));\n          } catch (parseError) {\n            reject(new Error(`Response didn't contain JSON: ${resBody}`));\n            return;\n          }\n        }\n\n        httpRes.on('error', reject);\n        httpRes.on('data', (chunk) => chunks.push(chunk));\n        httpRes.on('end', parseChunks);\n      }\n\n      httpReq.on('error', reject);\n      httpReq.on('response', onResponse);\n    });\n  }\n\n  connect() {\n    return this._discoverWebsocketPath()\n      .then((urlPath) => this._connectWebsocket(urlPath));\n  }\n\n  _discoverWebsocketPath() {\n    return this._fetchJSON('/json')\n      .then(([{ webSocketDebuggerUrl }]) =>\n        URL.parse(webSocketDebuggerUrl).path);\n  }\n\n  _connectWebsocket(urlPath) {\n    this.reset();\n\n    const key1 = crypto.randomBytes(16).toString('base64');\n    debuglog('request websocket', key1);\n\n    const httpReq = this._http = http.request({\n      host: this._host,\n      port: this._port,\n      path: urlPath,\n      headers: {\n        Connection: 'Upgrade',\n        Upgrade: 'websocket',\n        'Sec-WebSocket-Key': key1,\n        'Sec-WebSocket-Version': '13',\n      },\n    });\n    httpReq.on('error', (e) => {\n      this.emit('error', e);\n    });\n    httpReq.on('response', (httpRes) => {\n      if (httpRes.statusCode >= 400) {\n        process.stderr.write(`Unexpected HTTP code: ${httpRes.statusCode}\\n`);\n        httpRes.pipe(process.stderr);\n      } else {\n        httpRes.pipe(process.stderr);\n      }\n    });\n\n    const handshakeListener = (res, socket) => {\n      // TODO: we *could* validate res.headers[sec-websocket-accept]\n      debuglog('websocket upgrade');\n\n      this._socket = socket;\n      socket.on('data', this.handleChunk);\n      socket.on('close', () => {\n        this.emit('close');\n      });\n\n      this.emit('ready');\n    };\n\n    return new Promise((resolve, reject) => {\n      this.once('error', reject);\n      this.once('ready', resolve);\n\n      httpReq.on('upgrade', handshakeListener);\n      httpReq.end();\n    });\n  }\n}\n\nmodule.exports = Client;\n",
  "node-inspect/lib/internal/inspect_repl": "/*\n * Copyright Node.js contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n'use strict';\nconst FS = require('fs');\nconst Path = require('path');\nconst Repl = require('repl');\nconst util = require('util');\nconst vm = require('vm');\n\nconst debuglog = util.debuglog('inspect');\n\nconst SHORTCUTS = {\n  cont: 'c',\n  next: 'n',\n  step: 's',\n  out: 'o',\n  backtrace: 'bt',\n  setBreakpoint: 'sb',\n  clearBreakpoint: 'cb',\n  run: 'r',\n};\n\nconst HELP = `\nrun, restart, r       Run the application or reconnect\nkill                  Kill a running application or disconnect\n\ncont, c               Resume execution\nnext, n               Continue to next line in current file\nstep, s               Step into, potentially entering a function\nout, o                Step out, leaving the current function\nbacktrace, bt         Print the current backtrace\nlist                  Print the source around the current line where execution\n                      is currently paused\n\nsetBreakpoint, sb     Set a breakpoint\nclearBreakpoint, cb   Clear a breakpoint\nbreakpoints           List all known breakpoints\nbreakOnException      Pause execution whenever an exception is thrown\nbreakOnUncaught       Pause execution whenever an exception isn't caught\nbreakOnNone           Don't pause on exceptions (this is the default)\n\nwatch(expr)           Start watching the given expression\nunwatch(expr)         Stop watching an expression\nwatchers              Print all watched expressions and their current values\n\nexec(expr)            Evaluate the expression and print the value\nrepl                  Enter a debug repl that works like exec\n\nscripts               List application scripts that are currently loaded\nscripts(true)         List all scripts (including node-internals)\n\nprofile               Start CPU profiling session.\nprofileEnd            Stop current CPU profiling session.\nprofiles              Array of completed CPU profiling sessions.\nprofiles[n].save(filepath = 'node.cpuprofile')\n                      Save CPU profiling session to disk as JSON.\n\ntakeHeapSnapshot(filepath = 'node.heapsnapshot')\n                      Take a heap snapshot and save to disk as JSON.\n`.trim();\n\nconst FUNCTION_NAME_PATTERN = /^(?:function\\*? )?([^(\\s]+)\\(/;\nfunction extractFunctionName(description) {\n  const fnNameMatch = description.match(FUNCTION_NAME_PATTERN);\n  return fnNameMatch ? `: ${fnNameMatch[1]}` : '';\n}\n\nconst NATIVES = process.binding('natives');\nfunction isNativeUrl(url) {\n  return url.replace('.js', '') in NATIVES || url === 'bootstrap_node.js';\n}\n\nfunction getRelativePath(filename) {\n  const dir = Path.join(Path.resolve(), 'x').slice(0, -1);\n\n  // Change path to relative, if possible\n  if (filename.indexOf(dir) === 0) {\n    return filename.slice(dir.length);\n  }\n  return filename;\n}\n\nfunction toCallback(promise, callback) {\n  function forward(...args) {\n    process.nextTick(() => callback(...args));\n  }\n  promise.then(forward.bind(null, null), forward);\n}\n\n// Adds spaces and prefix to number\n// maxN is a maximum number we should have space for\nfunction leftPad(n, prefix, maxN) {\n  const s = n.toString();\n  const nchars = Math.max(2, String(maxN).length) + 1;\n  const nspaces = nchars - s.length - 1;\n\n  return prefix + ' '.repeat(nspaces) + s;\n}\n\nfunction markSourceColumn(sourceText, position, useColors) {\n  if (!sourceText) return '';\n\n  const head = sourceText.slice(0, position);\n  let tail = sourceText.slice(position);\n\n  // Colourize char if stdout supports colours\n  if (useColors) {\n    tail = tail.replace(/(.+?)([^\\w]|$)/, '\\u001b[32m$1\\u001b[39m$2');\n  }\n\n  // Return source line with coloured char at `position`\n  return [head, tail].join('');\n}\n\nfunction extractErrorMessage(stack) {\n  if (!stack) return '<unknown>';\n  const m = stack.match(/^\\w+: ([^\\n]+)/);\n  return m ? m[1] : stack;\n}\n\nfunction convertResultToError(result) {\n  const { className, description } = result;\n  const err = new Error(extractErrorMessage(description));\n  err.stack = description;\n  Object.defineProperty(err, 'name', { value: className });\n  return err;\n}\n\nclass RemoteObject {\n  constructor(attributes) {\n    Object.assign(this, attributes);\n    if (this.type === 'number') {\n      this.value =\n        this.unserializableValue ? +this.unserializableValue : +this.value;\n    }\n  }\n\n  [util.inspect.custom](depth, opts) {\n    function formatProperty(prop) {\n      switch (prop.type) {\n        case 'string':\n        case 'undefined':\n          return util.inspect(prop.value, opts);\n\n        case 'number':\n        case 'boolean':\n          return opts.stylize(prop.value, prop.type);\n\n        case 'object':\n        case 'symbol':\n          if (prop.subtype === 'date') {\n            return util.inspect(new Date(prop.value), opts);\n          }\n          if (prop.subtype === 'array') {\n            return opts.stylize(prop.value, 'special');\n          }\n          return opts.stylize(prop.value, prop.subtype || 'special');\n\n        default:\n          return prop.value;\n      }\n    }\n    switch (this.type) {\n      case 'boolean':\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return util.inspect(this.value, opts);\n\n      case 'symbol':\n        return opts.stylize(this.description, 'special');\n\n      case 'function': {\n        const fnName = extractFunctionName(this.description);\n        const formatted = `[${this.className}${fnName}]`;\n        return opts.stylize(formatted, 'special');\n      }\n\n      case 'object':\n        switch (this.subtype) {\n          case 'date':\n            return util.inspect(new Date(this.description), opts);\n\n          case 'null':\n            return util.inspect(null, opts);\n\n          case 'regexp':\n            return opts.stylize(this.description, 'regexp');\n\n          default:\n            break;\n        }\n        if (this.preview) {\n          const props = this.preview.properties\n            .map((prop, idx) => {\n              const value = formatProperty(prop);\n              if (prop.name === `${idx}`) return value;\n              return `${prop.name}: ${value}`;\n            });\n          if (this.preview.overflow) {\n            props.push('...');\n          }\n          const singleLine = props.join(', ');\n          const propString =\n            singleLine.length > 60 ? props.join(',\\n  ') : singleLine;\n\n          return this.subtype === 'array' ?\n            `[ ${propString} ]` : `{ ${propString} }`;\n        }\n        return this.description;\n\n      default:\n        return this.description;\n    }\n  }\n\n  static fromEvalResult({ result, wasThrown }) {\n    if (wasThrown) return convertResultToError(result);\n    return new RemoteObject(result);\n  }\n}\n\nclass ScopeSnapshot {\n  constructor(scope, properties) {\n    Object.assign(this, scope);\n    this.properties = new Map(properties.map((prop) => {\n      const value = new RemoteObject(prop.value);\n      return [prop.name, value];\n    }));\n    this.completionGroup = properties.map((prop) => prop.name);\n  }\n\n  [util.inspect.custom](depth, opts) {\n    const type = `${this.type[0].toUpperCase()}${this.type.slice(1)}`;\n    const name = this.name ? `<${this.name}>` : '';\n    const prefix = `${type}${name} `;\n    return util.inspect(this.properties, opts)\n      .replace(/^Map /, prefix);\n  }\n}\n\nfunction copyOwnProperties(target, source) {\n  Object.getOwnPropertyNames(source).forEach((prop) => {\n    const descriptor = Object.getOwnPropertyDescriptor(source, prop);\n    Object.defineProperty(target, prop, descriptor);\n  });\n}\n\nfunction aliasProperties(target, mapping) {\n  Object.keys(mapping).forEach((key) => {\n    const descriptor = Object.getOwnPropertyDescriptor(target, key);\n    Object.defineProperty(target, mapping[key], descriptor);\n  });\n}\n\nfunction createRepl(inspector) {\n  const { Debugger, HeapProfiler, Profiler, Runtime } = inspector;\n\n  let repl; // eslint-disable-line prefer-const\n\n  // Things we want to keep around\n  const history = { control: [], debug: [] };\n  const watchedExpressions = [];\n  const knownBreakpoints = [];\n  let pauseOnExceptionState = 'none';\n  let lastCommand;\n\n  // Things we need to reset when the app restarts\n  let knownScripts;\n  let currentBacktrace;\n  let selectedFrame;\n  let exitDebugRepl;\n\n  function resetOnStart() {\n    knownScripts = {};\n    currentBacktrace = null;\n    selectedFrame = null;\n\n    if (exitDebugRepl) exitDebugRepl();\n    exitDebugRepl = null;\n  }\n  resetOnStart();\n\n  const INSPECT_OPTIONS = { colors: inspector.stdout.isTTY };\n  function inspect(value) {\n    return util.inspect(value, INSPECT_OPTIONS);\n  }\n\n  function print(value, oneline = false) {\n    const text = typeof value === 'string' ? value : inspect(value);\n    return inspector.print(text, oneline);\n  }\n\n  function getCurrentLocation() {\n    if (!selectedFrame) {\n      throw new Error('Requires execution to be paused');\n    }\n    return selectedFrame.location;\n  }\n\n  function isCurrentScript(script) {\n    return selectedFrame && getCurrentLocation().scriptId === script.scriptId;\n  }\n\n  function formatScripts(displayNatives = false) {\n    function isVisible(script) {\n      if (displayNatives) return true;\n      return !script.isNative || isCurrentScript(script);\n    }\n\n    return Object.keys(knownScripts)\n      .map((scriptId) => knownScripts[scriptId])\n      .filter(isVisible)\n      .map((script) => {\n        const isCurrent = isCurrentScript(script);\n        const { isNative, url } = script;\n        const name = `${getRelativePath(url)}${isNative ? ' <native>' : ''}`;\n        return `${isCurrent ? '*' : ' '} ${script.scriptId}: ${name}`;\n      })\n      .join('\\n');\n  }\n  function listScripts(displayNatives = false) {\n    print(formatScripts(displayNatives));\n  }\n  listScripts[util.inspect.custom] = function listWithoutInternal() {\n    return formatScripts();\n  };\n\n  const profiles = [];\n  class Profile {\n    constructor(data) {\n      this.data = data;\n    }\n\n    static createAndRegister({ profile }) {\n      const p = new Profile(profile);\n      profiles.push(p);\n      return p;\n    }\n\n    [util.inspect.custom](depth, { stylize }) {\n      const { startTime, endTime } = this.data;\n      return stylize(`[Profile ${endTime - startTime}μs]`, 'special');\n    }\n\n    save(filename = 'node.cpuprofile') {\n      const absoluteFile = Path.resolve(filename);\n      const json = JSON.stringify(this.data);\n      FS.writeFileSync(absoluteFile, json);\n      print('Saved profile to ' + absoluteFile);\n    }\n  }\n\n  class SourceSnippet {\n    constructor(location, delta, scriptSource) {\n      Object.assign(this, location);\n      this.scriptSource = scriptSource;\n      this.delta = delta;\n    }\n\n    [util.inspect.custom](depth, options) {\n      const { scriptId, lineNumber, columnNumber, delta, scriptSource } = this;\n      const start = Math.max(1, lineNumber - delta + 1);\n      const end = lineNumber + delta + 1;\n\n      const lines = scriptSource.split('\\n');\n      return lines.slice(start - 1, end).map((lineText, offset) => {\n        const i = start + offset;\n        const isCurrent = i === (lineNumber + 1);\n\n        const markedLine = isCurrent\n          ? markSourceColumn(lineText, columnNumber, options.colors)\n          : lineText;\n\n        let isBreakpoint = false;\n        knownBreakpoints.forEach(({ location }) => {\n          if (!location) return;\n          if (scriptId === location.scriptId &&\n              i === (location.lineNumber + 1)) {\n            isBreakpoint = true;\n          }\n        });\n\n        let prefixChar = ' ';\n        if (isCurrent) {\n          prefixChar = '>';\n        } else if (isBreakpoint) {\n          prefixChar = '*';\n        }\n        return `${leftPad(i, prefixChar, end)} ${markedLine}`;\n      }).join('\\n');\n    }\n  }\n\n  function getSourceSnippet(location, delta = 5) {\n    const { scriptId } = location;\n    return Debugger.getScriptSource({ scriptId })\n      .then(({ scriptSource }) =>\n        new SourceSnippet(location, delta, scriptSource));\n  }\n\n  class CallFrame {\n    constructor(callFrame) {\n      Object.assign(this, callFrame);\n    }\n\n    loadScopes() {\n      return Promise.all(\n        this.scopeChain\n          .filter((scope) => scope.type !== 'global')\n          .map((scope) => {\n            const { objectId } = scope.object;\n            return Runtime.getProperties({\n              objectId,\n              generatePreview: true,\n            }).then(({ result }) => new ScopeSnapshot(scope, result));\n          })\n      );\n    }\n\n    list(delta = 5) {\n      return getSourceSnippet(this.location, delta);\n    }\n  }\n\n  class Backtrace extends Array {\n    [util.inspect.custom]() {\n      return this.map((callFrame, idx) => {\n        const {\n          location: { scriptId, lineNumber, columnNumber },\n          functionName\n        } = callFrame;\n        const name = functionName || '(anonymous)';\n\n        const script = knownScripts[scriptId];\n        const relativeUrl =\n          (script && getRelativePath(script.url)) || '<unknown>';\n        const frameLocation =\n          `${relativeUrl}:${lineNumber + 1}:${columnNumber}`;\n\n        return `#${idx} ${name} ${frameLocation}`;\n      }).join('\\n');\n    }\n\n    static from(callFrames) {\n      return super.from(Array.from(callFrames).map((callFrame) => {\n        if (callFrame instanceof CallFrame) {\n          return callFrame;\n        }\n        return new CallFrame(callFrame);\n      }));\n    }\n  }\n\n  function prepareControlCode(input) {\n    if (input === '\\n') return lastCommand;\n    // exec process.title => exec(\"process.title\");\n    const match = input.match(/^\\s*exec\\s+([^\\n]*)/);\n    if (match) {\n      lastCommand = `exec(${JSON.stringify(match[1])})`;\n    } else {\n      lastCommand = input;\n    }\n    return lastCommand;\n  }\n\n  function evalInCurrentContext(code) {\n    // Repl asked for scope variables\n    if (code === '.scope') {\n      if (!selectedFrame) {\n        return Promise.reject(new Error('Requires execution to be paused'));\n      }\n      return selectedFrame.loadScopes().then((scopes) => {\n        return scopes.map((scope) => scope.completionGroup);\n      });\n    }\n\n    if (selectedFrame) {\n      return Debugger.evaluateOnCallFrame({\n        callFrameId: selectedFrame.callFrameId,\n        expression: code,\n        objectGroup: 'node-inspect',\n        generatePreview: true,\n      }).then(RemoteObject.fromEvalResult);\n    }\n    return Runtime.evaluate({\n      expression: code,\n      objectGroup: 'node-inspect',\n      generatePreview: true,\n    }).then(RemoteObject.fromEvalResult);\n  }\n\n  function controlEval(input, context, filename, callback) {\n    debuglog('eval:', input);\n    function returnToCallback(error, result) {\n      debuglog('end-eval:', input, error);\n      callback(error, result);\n    }\n\n    try {\n      const code = prepareControlCode(input);\n      const result = vm.runInContext(code, context, filename);\n\n      if (result && typeof result.then === 'function') {\n        toCallback(result, returnToCallback);\n        return;\n      }\n      returnToCallback(null, result);\n    } catch (e) {\n      returnToCallback(e);\n    }\n  }\n\n  function debugEval(input, context, filename, callback) {\n    debuglog('eval:', input);\n    function returnToCallback(error, result) {\n      debuglog('end-eval:', input, error);\n      callback(error, result);\n    }\n\n    try {\n      const result = evalInCurrentContext(input);\n\n      if (result && typeof result.then === 'function') {\n        toCallback(result, returnToCallback);\n        return;\n      }\n      returnToCallback(null, result);\n    } catch (e) {\n      returnToCallback(e);\n    }\n  }\n\n  function formatWatchers(verbose = false) {\n    if (!watchedExpressions.length) {\n      return Promise.resolve('');\n    }\n\n    const inspectValue = (expr) =>\n      evalInCurrentContext(expr)\n        // .then(formatValue)\n        .catch((error) => `<${error.message}>`);\n    const lastIndex = watchedExpressions.length - 1;\n\n    return Promise.all(watchedExpressions.map(inspectValue))\n      .then((values) => {\n        const lines = watchedExpressions\n          .map((expr, idx) => {\n            const prefix = `${leftPad(idx, ' ', lastIndex)}: ${expr} =`;\n            const value = inspect(values[idx], { colors: true });\n            if (value.indexOf('\\n') === -1) {\n              return `${prefix} ${value}`;\n            }\n            return `${prefix}\\n    ${value.split('\\n').join('\\n    ')}`;\n          });\n        return lines.join('\\n');\n      })\n      .then((valueList) => {\n        return verbose ? `Watchers:\\n${valueList}\\n` : valueList;\n      });\n  }\n\n  function watchers(verbose = false) {\n    return formatWatchers(verbose).then(print);\n  }\n\n  // List source code\n  function list(delta = 5) {\n    return selectedFrame.list(delta)\n      .then(null, (error) => {\n        print('You can\\'t list source code right now');\n        throw error;\n      });\n  }\n\n  function handleBreakpointResolved({ breakpointId, location }) {\n    const script = knownScripts[location.scriptId];\n    const scriptUrl = script && script.url;\n    if (scriptUrl) {\n      Object.assign(location, { scriptUrl });\n    }\n    const isExisting = knownBreakpoints.some((bp) => {\n      if (bp.breakpointId === breakpointId) {\n        Object.assign(bp, { location });\n        return true;\n      }\n      return false;\n    });\n    if (!isExisting) {\n      knownBreakpoints.push({ breakpointId, location });\n    }\n  }\n\n  function listBreakpoints() {\n    if (!knownBreakpoints.length) {\n      print('No breakpoints yet');\n      return;\n    }\n\n    function formatLocation(location) {\n      if (!location) return '<unknown location>';\n      const script = knownScripts[location.scriptId];\n      const scriptUrl = script ? script.url : location.scriptUrl;\n      return `${getRelativePath(scriptUrl)}:${location.lineNumber + 1}`;\n    }\n    const breaklist = knownBreakpoints\n      .map((bp, idx) => `#${idx} ${formatLocation(bp.location)}`)\n      .join('\\n');\n    print(breaklist);\n  }\n\n  function setBreakpoint(script, line, condition, silent) {\n    function registerBreakpoint({ breakpointId, actualLocation }) {\n      handleBreakpointResolved({ breakpointId, location: actualLocation });\n      if (actualLocation && actualLocation.scriptId) {\n        if (!silent) return getSourceSnippet(actualLocation, 5);\n      } else {\n        print(`Warning: script '${script}' was not loaded yet.`);\n      }\n      return undefined;\n    }\n\n    // setBreakpoint(): set breakpoint at current location\n    if (script === undefined) {\n      return Debugger\n        .setBreakpoint({ location: getCurrentLocation(), condition })\n        .then(registerBreakpoint);\n    }\n\n    // setBreakpoint(line): set breakpoint in current script at specific line\n    if (line === undefined && typeof script === 'number') {\n      const location = {\n        scriptId: getCurrentLocation().scriptId,\n        lineNumber: script - 1,\n      };\n      return Debugger.setBreakpoint({ location, condition })\n        .then(registerBreakpoint);\n    }\n\n    if (typeof script !== 'string') {\n      throw new TypeError(`setBreakpoint() expects a string, got ${script}`);\n    }\n\n    // setBreakpoint('fn()'): Break when a function is called\n    if (script.endsWith('()')) {\n      const debugExpr = `debug(${script.slice(0, -2)})`;\n      const debugCall = selectedFrame\n        ? Debugger.evaluateOnCallFrame({\n          callFrameId: selectedFrame.callFrameId,\n          expression: debugExpr,\n          includeCommandLineAPI: true,\n        })\n        : Runtime.evaluate({\n          expression: debugExpr,\n          includeCommandLineAPI: true,\n        });\n      return debugCall.then(({ result, wasThrown }) => {\n        if (wasThrown) return convertResultToError(result);\n        return undefined; // This breakpoint can't be removed the same way\n      });\n    }\n\n    // setBreakpoint('scriptname')\n    let scriptId = null;\n    let ambiguous = false;\n    if (knownScripts[script]) {\n      scriptId = script;\n    } else {\n      for (const id of Object.keys(knownScripts)) {\n        const scriptUrl = knownScripts[id].url;\n        if (scriptUrl && scriptUrl.indexOf(script) !== -1) {\n          if (scriptId !== null) {\n            ambiguous = true;\n          }\n          scriptId = id;\n        }\n      }\n    }\n\n    if (ambiguous) {\n      print('Script name is ambiguous');\n      return undefined;\n    }\n    if (line <= 0) {\n      print('Line should be a positive value');\n      return undefined;\n    }\n\n    if (scriptId !== null) {\n      const location = { scriptId, lineNumber: line - 1 };\n      return Debugger.setBreakpoint({ location, condition })\n        .then(registerBreakpoint);\n    }\n\n    const escapedPath = script.replace(/([/\\\\.?*()^${}|[\\]])/g, '\\\\$1');\n    const urlRegex = `^(.*[\\\\/\\\\\\\\])?${escapedPath}$`;\n\n    return Debugger\n      .setBreakpointByUrl({ urlRegex, lineNumber: line - 1, condition })\n      .then((bp) => {\n        // TODO: handle bp.locations in case the regex matches existing files\n        if (!bp.location) { // Fake it for now.\n          Object.assign(bp, {\n            actualLocation: {\n              scriptUrl: `.*/${script}$`,\n              lineNumber: line - 1,\n            },\n          });\n        }\n        return registerBreakpoint(bp);\n      });\n  }\n\n  function clearBreakpoint(url, line) {\n    const breakpoint = knownBreakpoints.find(({ location }) => {\n      if (!location) return false;\n      const script = knownScripts[location.scriptId];\n      if (!script) return false;\n      return (\n        script.url.indexOf(url) !== -1 && (location.lineNumber + 1) === line\n      );\n    });\n    if (!breakpoint) {\n      print(`Could not find breakpoint at ${url}:${line}`);\n      return Promise.resolve();\n    }\n    return Debugger.removeBreakpoint({ breakpointId: breakpoint.breakpointId })\n      .then(() => {\n        const idx = knownBreakpoints.indexOf(breakpoint);\n        knownBreakpoints.splice(idx, 1);\n      });\n  }\n\n  function restoreBreakpoints() {\n    const lastBreakpoints = knownBreakpoints.slice();\n    knownBreakpoints.length = 0;\n    const newBreakpoints = lastBreakpoints\n      .filter(({ location }) => !!location.scriptUrl)\n      .map(({ location }) =>\n        setBreakpoint(location.scriptUrl, location.lineNumber + 1));\n    if (!newBreakpoints.length) return Promise.resolve();\n    return Promise.all(newBreakpoints).then((results) => {\n      print(`${results.length} breakpoints restored.`);\n    });\n  }\n\n  function setPauseOnExceptions(state) {\n    return Debugger.setPauseOnExceptions({ state })\n      .then(() => {\n        pauseOnExceptionState = state;\n      });\n  }\n\n  Debugger.on('paused', ({ callFrames, reason /* , hitBreakpoints */ }) => {\n    // Save execution context's data\n    currentBacktrace = Backtrace.from(callFrames);\n    selectedFrame = currentBacktrace[0];\n    const { scriptId, lineNumber } = selectedFrame.location;\n\n    const breakType = reason === 'other' ? 'break' : reason;\n    const script = knownScripts[scriptId];\n    const scriptUrl = script ? getRelativePath(script.url) : '[unknown]';\n\n    const header = `${breakType} in ${scriptUrl}:${lineNumber + 1}`;\n\n    inspector.suspendReplWhile(() =>\n      Promise.all([formatWatchers(true), selectedFrame.list(2)])\n        .then(([watcherList, context]) => {\n          if (watcherList) {\n            return `${watcherList}\\n${inspect(context)}`;\n          }\n          return inspect(context);\n        }).then((breakContext) => {\n          print(`${header}\\n${breakContext}`);\n        }));\n  });\n\n  function handleResumed() {\n    currentBacktrace = null;\n    selectedFrame = null;\n  }\n\n  Debugger.on('resumed', handleResumed);\n\n  Debugger.on('breakpointResolved', handleBreakpointResolved);\n\n  Debugger.on('scriptParsed', (script) => {\n    const { scriptId, url } = script;\n    if (url) {\n      knownScripts[scriptId] = Object.assign({\n        isNative: isNativeUrl(url),\n      }, script);\n    }\n  });\n\n  Profiler.on('consoleProfileFinished', ({ profile }) => {\n    Profile.createAndRegister({ profile });\n    print([\n      'Captured new CPU profile.',\n      `Access it with profiles[${profiles.length - 1}]`\n    ].join('\\n'));\n  });\n\n  function initializeContext(context) {\n    inspector.domainNames.forEach((domain) => {\n      Object.defineProperty(context, domain, {\n        value: inspector[domain],\n        enumerable: true,\n        configurable: true,\n        writeable: false,\n      });\n    });\n\n    copyOwnProperties(context, {\n      get help() {\n        print(HELP);\n      },\n\n      get run() {\n        return inspector.run();\n      },\n\n      get kill() {\n        return inspector.killChild();\n      },\n\n      get restart() {\n        return inspector.run();\n      },\n\n      get cont() {\n        handleResumed();\n        return Debugger.resume();\n      },\n\n      get next() {\n        handleResumed();\n        return Debugger.stepOver();\n      },\n\n      get step() {\n        handleResumed();\n        return Debugger.stepInto();\n      },\n\n      get out() {\n        handleResumed();\n        return Debugger.stepOut();\n      },\n\n      get pause() {\n        return Debugger.pause();\n      },\n\n      get backtrace() {\n        return currentBacktrace;\n      },\n\n      get breakpoints() {\n        return listBreakpoints();\n      },\n\n      exec(expr) {\n        return evalInCurrentContext(expr);\n      },\n\n      get profile() {\n        return Profiler.start();\n      },\n\n      get profileEnd() {\n        return Profiler.stop()\n          .then(Profile.createAndRegister);\n      },\n\n      get profiles() {\n        return profiles;\n      },\n\n      takeHeapSnapshot(filename = 'node.heapsnapshot') {\n        return new Promise((resolve, reject) => {\n          const absoluteFile = Path.resolve(filename);\n          const writer = FS.createWriteStream(absoluteFile);\n          let totalSize;\n          let sizeWritten = 0;\n          function onProgress({ done, total, finished }) {\n            totalSize = total;\n            if (finished) {\n              print('Heap snaphost prepared.');\n            } else {\n              print(`Heap snapshot: ${done}/${total}`, true);\n            }\n          }\n          function onChunk({ chunk }) {\n            sizeWritten += chunk.length;\n            writer.write(chunk);\n            print(`Writing snapshot: ${sizeWritten}/${totalSize}`, true);\n            if (sizeWritten >= totalSize) {\n              writer.end();\n              teardown();\n              print(`Wrote snapshot: ${absoluteFile}`);\n              resolve();\n            }\n          }\n          function teardown() {\n            HeapProfiler.removeListener(\n              'reportHeapSnapshotProgress', onProgress);\n            HeapProfiler.removeListener('addHeapSnapshotChunk', onChunk);\n          }\n\n          HeapProfiler.on('reportHeapSnapshotProgress', onProgress);\n          HeapProfiler.on('addHeapSnapshotChunk', onChunk);\n\n          print('Heap snapshot: 0/0', true);\n          HeapProfiler.takeHeapSnapshot({ reportProgress: true })\n            .then(null, (error) => {\n              teardown();\n              reject(error);\n            });\n        });\n      },\n\n      get watchers() {\n        return watchers();\n      },\n\n      watch(expr) {\n        watchedExpressions.push(expr);\n      },\n\n      unwatch(expr) {\n        const index = watchedExpressions.indexOf(expr);\n\n        // Unwatch by expression\n        // or\n        // Unwatch by watcher number\n        watchedExpressions.splice(index !== -1 ? index : +expr, 1);\n      },\n\n      get repl() {\n        // Don't display any default messages\n        const listeners = repl.rli.listeners('SIGINT').slice(0);\n        repl.rli.removeAllListeners('SIGINT');\n\n        const oldContext = repl.context;\n\n        exitDebugRepl = () => {\n          // Restore all listeners\n          process.nextTick(() => {\n            listeners.forEach((listener) => {\n              repl.rli.on('SIGINT', listener);\n            });\n          });\n\n          // Exit debug repl\n          repl.eval = controlEval;\n\n          // Swap history\n          history.debug = repl.rli.history;\n          repl.rli.history = history.control;\n\n          repl.context = oldContext;\n          repl.rli.setPrompt('debug> ');\n          repl.displayPrompt();\n\n          repl.rli.removeListener('SIGINT', exitDebugRepl);\n          repl.removeListener('exit', exitDebugRepl);\n\n          exitDebugRepl = null;\n        };\n\n        // Exit debug repl on SIGINT\n        repl.rli.on('SIGINT', exitDebugRepl);\n\n        // Exit debug repl on repl exit\n        repl.on('exit', exitDebugRepl);\n\n        // Set new\n        repl.eval = debugEval;\n        repl.context = {};\n\n        // Swap history\n        history.control = repl.rli.history;\n        repl.rli.history = history.debug;\n\n        repl.rli.setPrompt('> ');\n\n        print('Press Ctrl + C to leave debug repl');\n        repl.displayPrompt();\n      },\n\n      get version() {\n        return Runtime.evaluate({\n          expression: 'process.versions.v8',\n          contextId: 1,\n          returnByValue: true,\n        }).then(({ result }) => {\n          print(result.value);\n        });\n      },\n\n      scripts: listScripts,\n\n      setBreakpoint,\n      clearBreakpoint,\n      setPauseOnExceptions,\n      get breakOnException() {\n        return setPauseOnExceptions('all');\n      },\n      get breakOnUncaught() {\n        return setPauseOnExceptions('uncaught');\n      },\n      get breakOnNone() {\n        return setPauseOnExceptions('none');\n      },\n\n      list,\n    });\n    aliasProperties(context, SHORTCUTS);\n  }\n\n  function initAfterStart() {\n    const setupTasks = [\n      Runtime.enable(),\n      Profiler.enable(),\n      Profiler.setSamplingInterval({ interval: 100 }),\n      Debugger.enable(),\n      Debugger.setPauseOnExceptions({ state: 'none' }),\n      Debugger.setAsyncCallStackDepth({ maxDepth: 0 }),\n      Debugger.setBlackboxPatterns({ patterns: [] }),\n      Debugger.setPauseOnExceptions({ state: pauseOnExceptionState }),\n      restoreBreakpoints(),\n      Runtime.runIfWaitingForDebugger(),\n    ];\n    return Promise.all(setupTasks);\n  }\n\n  return function startRepl() {\n    inspector.client.on('close', () => {\n      resetOnStart();\n    });\n    inspector.client.on('ready', () => {\n      initAfterStart();\n    });\n\n    const replOptions = {\n      prompt: 'debug> ',\n      input: inspector.stdin,\n      output: inspector.stdout,\n      eval: controlEval,\n      useGlobal: false,\n      ignoreUndefined: true,\n    };\n\n    repl = Repl.start(replOptions); // eslint-disable-line prefer-const\n    initializeContext(repl.context);\n    repl.on('reset', initializeContext);\n\n    repl.defineCommand('interrupt', () => {\n      // We want this for testing purposes where sending CTRL-C can be tricky.\n      repl.rli.emit('SIGINT');\n    });\n\n    // Init once for the initial connection\n    initAfterStart();\n\n    return repl;\n  };\n}\nmodule.exports = createRepl;\n"
}
